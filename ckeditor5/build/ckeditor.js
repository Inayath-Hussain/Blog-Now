(function (t) { const e = t["en"] = t["en"] || {}; e.dictionary = Object.assign(e.dictionary || {}, { "%0 of %1": "%0 of %1", "Align cell text to the bottom": "Align cell text to the bottom", "Align cell text to the center": "Align cell text to the center", "Align cell text to the left": "Align cell text to the left", "Align cell text to the middle": "Align cell text to the middle", "Align cell text to the right": "Align cell text to the right", "Align cell text to the top": "Align cell text to the top", "Align center": "Align center", "Align left": "Align left", "Align right": "Align right", "Align table to the left": "Align table to the left", "Align table to the right": "Align table to the right", Alignment: "Alignment", All: "All", "Almost equal to": "Almost equal to", Angle: "Angle", "Approximately equal to": "Approximately equal to", Aquamarine: "Aquamarine", Arrows: "Arrows", "Asterisk operator": "Asterisk operator", "Austral sign": "Austral sign", "back with leftwards arrow above": "back with leftwards arrow above", Background: "Background", "Bitcoin sign": "Bitcoin sign", Black: "Black", "Block quote": "Block quote", Blue: "Blue", "Blue marker": "Blue marker", Bold: "Bold", Border: "Border", "Break text": "Break text", "Bulleted List": "Bulleted List", "Bulleted list styles toolbar": "Bulleted list styles toolbar", Cancel: "Cancel", "Caption for image: %0": "Caption for image: %0", "Caption for the image": "Caption for the image", "Cedi sign": "Cedi sign", "Cell properties": "Cell properties", "Cent sign": "Cent sign", "Center table": "Center table", "Centered image": "Centered image", "Change image text alternative": "Change image text alternative", "Character categories": "Character categories", "Choose heading": "Choose heading", Circle: "Circle", Code: "Code", "Colon sign": "Colon sign", Color: "Color", "Color picker": "Color picker", Column: "Column", "Contains as member": "Contains as member", "Copyright sign": "Copyright sign", "Cruzeiro sign": "Cruzeiro sign", Currency: "Currency", "Currency sign": "Currency sign", Dashed: "Dashed", Decimal: "Decimal", "Decimal with leading zero": "Decimal with leading zero", "Decrease indent": "Decrease indent", "Degree sign": "Degree sign", "Delete column": "Delete column", "Delete row": "Delete row", "Dim grey": "Dim grey", Dimensions: "Dimensions", Disc: "Disc", "Division sign": "Division sign", "Dollar sign": "Dollar sign", "Dong sign": "Dong sign", Dotted: "Dotted", Double: "Double", "Double dagger": "Double dagger", "Double exclamation mark": "Double exclamation mark", "Double low-9 quotation mark": "Double low-9 quotation mark", "Double question mark": "Double question mark", Downloadable: "Downloadable", "downwards arrow to bar": "downwards arrow to bar", "downwards dashed arrow": "downwards dashed arrow", "downwards double arrow": "downwards double arrow", "downwards simple arrow": "downwards simple arrow", "Drachma sign": "Drachma sign", "Dropdown toolbar": "Dropdown toolbar", "Edit block": "Edit block", "Edit link": "Edit link", "Editor block content toolbar": "Editor block content toolbar", "Editor contextual toolbar": "Editor contextual toolbar", "Editor editing area: %0": "Editor editing area: %0", "Editor toolbar": "Editor toolbar", "Element of": "Element of", "Em dash": "Em dash", "Empty set": "Empty set", "En dash": "En dash", "end with leftwards arrow above": "end with leftwards arrow above", "Enter image caption": "Enter image caption", "Enter table caption": "Enter table caption", "Euro sign": "Euro sign", "Euro-currency sign": "Euro-currency sign", "Exclamation question mark": "Exclamation question mark", "For all": "For all", "Fraction slash": "Fraction slash", "French franc sign": "French franc sign", "Full size image": "Full size image", "German penny sign": "German penny sign", "Greater-than or equal to": "Greater-than or equal to", "Greater-than sign": "Greater-than sign", Green: "Green", "Green marker": "Green marker", "Green pen": "Green pen", Grey: "Grey", Groove: "Groove", "Guarani sign": "Guarani sign", "Header column": "Header column", "Header row": "Header row", Heading: "Heading", "Heading 1": "Heading 1", "Heading 2": "Heading 2", "Heading 3": "Heading 3", "Heading 4": "Heading 4", "Heading 5": "Heading 5", "Heading 6": "Heading 6", Height: "Height", Highlight: "Highlight", "Horizontal ellipsis": "Horizontal ellipsis", "Horizontal line": "Horizontal line", "Horizontal text alignment toolbar": "Horizontal text alignment toolbar", "Hryvnia sign": "Hryvnia sign", "HTML object": "HTML object", "Identical to": "Identical to", "Image resize list": "Image resize list", "Image toolbar": "Image toolbar", "image widget": "image widget", "In line": "In line", "Increase indent": "Increase indent", "Indian rupee sign": "Indian rupee sign", Infinity: "Infinity", "Insert code block": "Insert code block", "Insert column left": "Insert column left", "Insert column right": "Insert column right", "Insert image": "Insert image", "Insert media": "Insert media", "Insert paragraph after block": "Insert paragraph after block", "Insert paragraph before block": "Insert paragraph before block", "Insert row above": "Insert row above", "Insert row below": "Insert row below", "Insert table": "Insert table", Inset: "Inset", Integral: "Integral", Intersection: "Intersection", "Inverted exclamation mark": "Inverted exclamation mark", "Inverted question mark": "Inverted question mark", Italic: "Italic", Justify: "Justify", "Justify cell text": "Justify cell text", "Kip sign": "Kip sign", Latin: "Latin", "Latin capital letter a with breve": "Latin capital letter a with breve", "Latin capital letter a with macron": "Latin capital letter a with macron", "Latin capital letter a with ogonek": "Latin capital letter a with ogonek", "Latin capital letter c with acute": "Latin capital letter c with acute", "Latin capital letter c with caron": "Latin capital letter c with caron", "Latin capital letter c with circumflex": "Latin capital letter c with circumflex", "Latin capital letter c with dot above": "Latin capital letter c with dot above", "Latin capital letter d with caron": "Latin capital letter d with caron", "Latin capital letter d with stroke": "Latin capital letter d with stroke", "Latin capital letter e with breve": "Latin capital letter e with breve", "Latin capital letter e with caron": "Latin capital letter e with caron", "Latin capital letter e with dot above": "Latin capital letter e with dot above", "Latin capital letter e with macron": "Latin capital letter e with macron", "Latin capital letter e with ogonek": "Latin capital letter e with ogonek", "Latin capital letter eng": "Latin capital letter eng", "Latin capital letter g with breve": "Latin capital letter g with breve", "Latin capital letter g with cedilla": "Latin capital letter g with cedilla", "Latin capital letter g with circumflex": "Latin capital letter g with circumflex", "Latin capital letter g with dot above": "Latin capital letter g with dot above", "Latin capital letter h with circumflex": "Latin capital letter h with circumflex", "Latin capital letter h with stroke": "Latin capital letter h with stroke", "Latin capital letter i with breve": "Latin capital letter i with breve", "Latin capital letter i with dot above": "Latin capital letter i with dot above", "Latin capital letter i with macron": "Latin capital letter i with macron", "Latin capital letter i with ogonek": "Latin capital letter i with ogonek", "Latin capital letter i with tilde": "Latin capital letter i with tilde", "Latin capital letter j with circumflex": "Latin capital letter j with circumflex", "Latin capital letter k with cedilla": "Latin capital letter k with cedilla", "Latin capital letter l with acute": "Latin capital letter l with acute", "Latin capital letter l with caron": "Latin capital letter l with caron", "Latin capital letter l with cedilla": "Latin capital letter l with cedilla", "Latin capital letter l with middle dot": "Latin capital letter l with middle dot", "Latin capital letter l with stroke": "Latin capital letter l with stroke", "Latin capital letter n with acute": "Latin capital letter n with acute", "Latin capital letter n with caron": "Latin capital letter n with caron", "Latin capital letter n with cedilla": "Latin capital letter n with cedilla", "Latin capital letter o with breve": "Latin capital letter o with breve", "Latin capital letter o with double acute": "Latin capital letter o with double acute", "Latin capital letter o with macron": "Latin capital letter o with macron", "Latin capital letter r with acute": "Latin capital letter r with acute", "Latin capital letter r with caron": "Latin capital letter r with caron", "Latin capital letter r with cedilla": "Latin capital letter r with cedilla", "Latin capital letter s with acute": "Latin capital letter s with acute", "Latin capital letter s with caron": "Latin capital letter s with caron", "Latin capital letter s with cedilla": "Latin capital letter s with cedilla", "Latin capital letter s with circumflex": "Latin capital letter s with circumflex", "Latin capital letter t with caron": "Latin capital letter t with caron", "Latin capital letter t with cedilla": "Latin capital letter t with cedilla", "Latin capital letter t with stroke": "Latin capital letter t with stroke", "Latin capital letter u with breve": "Latin capital letter u with breve", "Latin capital letter u with double acute": "Latin capital letter u with double acute", "Latin capital letter u with macron": "Latin capital letter u with macron", "Latin capital letter u with ogonek": "Latin capital letter u with ogonek", "Latin capital letter u with ring above": "Latin capital letter u with ring above", "Latin capital letter u with tilde": "Latin capital letter u with tilde", "Latin capital letter w with circumflex": "Latin capital letter w with circumflex", "Latin capital letter y with circumflex": "Latin capital letter y with circumflex", "Latin capital letter y with diaeresis": "Latin capital letter y with diaeresis", "Latin capital letter z with acute": "Latin capital letter z with acute", "Latin capital letter z with caron": "Latin capital letter z with caron", "Latin capital letter z with dot above": "Latin capital letter z with dot above", "Latin capital ligature ij": "Latin capital ligature ij", "Latin capital ligature oe": "Latin capital ligature oe", "Latin small letter a with breve": "Latin small letter a with breve", "Latin small letter a with macron": "Latin small letter a with macron", "Latin small letter a with ogonek": "Latin small letter a with ogonek", "Latin small letter c with acute": "Latin small letter c with acute", "Latin small letter c with caron": "Latin small letter c with caron", "Latin small letter c with circumflex": "Latin small letter c with circumflex", "Latin small letter c with dot above": "Latin small letter c with dot above", "Latin small letter d with caron": "Latin small letter d with caron", "Latin small letter d with stroke": "Latin small letter d with stroke", "Latin small letter dotless i": "Latin small letter dotless i", "Latin small letter e with breve": "Latin small letter e with breve", "Latin small letter e with caron": "Latin small letter e with caron", "Latin small letter e with dot above": "Latin small letter e with dot above", "Latin small letter e with macron": "Latin small letter e with macron", "Latin small letter e with ogonek": "Latin small letter e with ogonek", "Latin small letter eng": "Latin small letter eng", "Latin small letter f with hook": "Latin small letter f with hook", "Latin small letter g with breve": "Latin small letter g with breve", "Latin small letter g with cedilla": "Latin small letter g with cedilla", "Latin small letter g with circumflex": "Latin small letter g with circumflex", "Latin small letter g with dot above": "Latin small letter g with dot above", "Latin small letter h with circumflex": "Latin small letter h with circumflex", "Latin small letter h with stroke": "Latin small letter h with stroke", "Latin small letter i with breve": "Latin small letter i with breve", "Latin small letter i with macron": "Latin small letter i with macron", "Latin small letter i with ogonek": "Latin small letter i with ogonek", "Latin small letter i with tilde": "Latin small letter i with tilde", "Latin small letter j with circumflex": "Latin small letter j with circumflex", "Latin small letter k with cedilla": "Latin small letter k with cedilla", "Latin small letter kra": "Latin small letter kra", "Latin small letter l with acute": "Latin small letter l with acute", "Latin small letter l with caron": "Latin small letter l with caron", "Latin small letter l with cedilla": "Latin small letter l with cedilla", "Latin small letter l with middle dot": "Latin small letter l with middle dot", "Latin small letter l with stroke": "Latin small letter l with stroke", "Latin small letter long s": "Latin small letter long s", "Latin small letter n preceded by apostrophe": "Latin small letter n preceded by apostrophe", "Latin small letter n with acute": "Latin small letter n with acute", "Latin small letter n with caron": "Latin small letter n with caron", "Latin small letter n with cedilla": "Latin small letter n with cedilla", "Latin small letter o with breve": "Latin small letter o with breve", "Latin small letter o with double acute": "Latin small letter o with double acute", "Latin small letter o with macron": "Latin small letter o with macron", "Latin small letter r with acute": "Latin small letter r with acute", "Latin small letter r with caron": "Latin small letter r with caron", "Latin small letter r with cedilla": "Latin small letter r with cedilla", "Latin small letter s with acute": "Latin small letter s with acute", "Latin small letter s with caron": "Latin small letter s with caron", "Latin small letter s with cedilla": "Latin small letter s with cedilla", "Latin small letter s with circumflex": "Latin small letter s with circumflex", "Latin small letter t with caron": "Latin small letter t with caron", "Latin small letter t with cedilla": "Latin small letter t with cedilla", "Latin small letter t with stroke": "Latin small letter t with stroke", "Latin small letter u with breve": "Latin small letter u with breve", "Latin small letter u with double acute": "Latin small letter u with double acute", "Latin small letter u with macron": "Latin small letter u with macron", "Latin small letter u with ogonek": "Latin small letter u with ogonek", "Latin small letter u with ring above": "Latin small letter u with ring above", "Latin small letter u with tilde": "Latin small letter u with tilde", "Latin small letter w with circumflex": "Latin small letter w with circumflex", "Latin small letter y with circumflex": "Latin small letter y with circumflex", "Latin small letter z with acute": "Latin small letter z with acute", "Latin small letter z with caron": "Latin small letter z with caron", "Latin small letter z with dot above": "Latin small letter z with dot above", "Latin small ligature ij": "Latin small ligature ij", "Latin small ligature oe": "Latin small ligature oe", "Left aligned image": "Left aligned image", "Left double quotation mark": "Left double quotation mark", "Left single quotation mark": "Left single quotation mark", "Left-pointing double angle quotation mark": "Left-pointing double angle quotation mark", "leftwards arrow to bar": "leftwards arrow to bar", "leftwards dashed arrow": "leftwards dashed arrow", "leftwards double arrow": "leftwards double arrow", "leftwards simple arrow": "leftwards simple arrow", "Less-than or equal to": "Less-than or equal to", "Less-than sign": "Less-than sign", "Light blue": "Light blue", "Light green": "Light green", "Light grey": "Light grey", Link: "Link", "Link image": "Link image", "Link URL": "Link URL", "Lira sign": "Lira sign", "List properties": "List properties", "Livre tournois sign": "Livre tournois sign", "Logical and": "Logical and", "Logical or": "Logical or", "Lower-latin": "Lower-latin", "Lower–roman": "Lower–roman", Macron: "Macron", "Manat sign": "Manat sign", Mathematical: "Mathematical", "Media toolbar": "Media toolbar", "Media URL": "Media URL", "media widget": "media widget", "Merge cell down": "Merge cell down", "Merge cell left": "Merge cell left", "Merge cell right": "Merge cell right", "Merge cell up": "Merge cell up", "Merge cells": "Merge cells", "Mill sign": "Mill sign", "Minus sign": "Minus sign", "Multiplication sign": "Multiplication sign", "N-ary product": "N-ary product", "N-ary summation": "N-ary summation", Nabla: "Nabla", "Naira sign": "Naira sign", "New sheqel sign": "New sheqel sign", Next: "Next", None: "None", "Nordic mark sign": "Nordic mark sign", "Not an element of": "Not an element of", "Not equal to": "Not equal to", "Not sign": "Not sign", "Numbered List": "Numbered List", "Numbered list styles toolbar": "Numbered list styles toolbar", "on with exclamation mark with left right arrow above": "on with exclamation mark with left right arrow above", "Open in a new tab": "Open in a new tab", "Open link in new tab": "Open link in new tab", "Open media in new tab": "Open media in new tab", Orange: "Orange", Original: "Original", Outset: "Outset", Overline: "Overline", Padding: "Padding", Paragraph: "Paragraph", "Paragraph sign": "Paragraph sign", "Partial differential": "Partial differential", "Paste the media URL in the input.": "Paste the media URL in the input.", "Per mille sign": "Per mille sign", "Per ten thousand sign": "Per ten thousand sign", "Peseta sign": "Peseta sign", "Peso sign": "Peso sign", "Pink marker": "Pink marker", "Plain text": "Plain text", "Plus-minus sign": "Plus-minus sign", "Pound sign": "Pound sign", "Press Enter to type after or press Shift + Enter to type before the widget": "Press Enter to type after or press Shift + Enter to type before the widget", Previous: "Previous", "Proportional to": "Proportional to", Purple: "Purple", "Question exclamation mark": "Question exclamation mark", Red: "Red", "Red pen": "Red pen", Redo: "Redo", "Registered sign": "Registered sign", "Remove color": "Remove color", "Remove Format": "Remove Format", "Remove highlight": "Remove highlight", "Resize image": "Resize image", "Resize image to %0": "Resize image to %0", "Resize image to the original size": "Resize image to the original size", "Restore default": "Restore default", "Reversed order": "Reversed order", "Reversed paragraph sign": "Reversed paragraph sign", "Rich Text Editor": "Rich Text Editor", "Rich Text Editor. Editing area: %0": "Rich Text Editor. Editing area: %0", Ridge: "Ridge", "Right aligned image": "Right aligned image", "Right double quotation mark": "Right double quotation mark", "Right single quotation mark": "Right single quotation mark", "Right-pointing double angle quotation mark": "Right-pointing double angle quotation mark", "rightwards arrow to bar": "rightwards arrow to bar", "rightwards dashed arrow": "rightwards dashed arrow", "rightwards double arrow": "rightwards double arrow", "rightwards simple arrow": "rightwards simple arrow", Row: "Row", "Ruble sign": "Ruble sign", "Rupee sign": "Rupee sign", Save: "Save", "Saving changes": "Saving changes", "Section sign": "Section sign", "Select all": "Select all", "Select column": "Select column", "Select row": "Select row", "Show more items": "Show more items", "Side image": "Side image", "Single left-pointing angle quotation mark": "Single left-pointing angle quotation mark", "Single low-9 quotation mark": "Single low-9 quotation mark", "Single right-pointing angle quotation mark": "Single right-pointing angle quotation mark", Solid: "Solid", "soon with rightwards arrow above": "soon with rightwards arrow above", "Special characters": "Special characters", "Spesmilo sign": "Spesmilo sign", "Split cell horizontally": "Split cell horizontally", "Split cell vertically": "Split cell vertically", Square: "Square", "Square root": "Square root", "Start at": "Start at", "Start index must be greater than 0.": "Start index must be greater than 0.", Strikethrough: "Strikethrough", Style: "Style", Subscript: "Subscript", Superscript: "Superscript", "Table alignment toolbar": "Table alignment toolbar", "Table cell text alignment": "Table cell text alignment", "Table properties": "Table properties", "Table toolbar": "Table toolbar", "Tenge sign": "Tenge sign", Text: "Text", "Text alignment": "Text alignment", "Text alignment toolbar": "Text alignment toolbar", "Text alternative": "Text alternative", "Text highlight toolbar": "Text highlight toolbar", 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".': 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".', "The URL must not be empty.": "The URL must not be empty.", 'The value is invalid. Try "10px" or "2em" or simply "2".': 'The value is invalid. Try "10px" or "2em" or simply "2".', "There exists": "There exists", "This link has no URL": "This link has no URL", "This media URL is not supported.": "This media URL is not supported.", "Tilde operator": "Tilde operator", "Tip: Paste the URL into the content to embed faster.": "Tip: Paste the URL into the content to embed faster.", "Toggle caption off": "Toggle caption off", "Toggle caption on": "Toggle caption on", "Toggle the circle list style": "Toggle the circle list style", "Toggle the decimal list style": "Toggle the decimal list style", "Toggle the decimal with leading zero list style": "Toggle the decimal with leading zero list style", "Toggle the disc list style": "Toggle the disc list style", "Toggle the lower–latin list style": "Toggle the lower–latin list style", "Toggle the lower–roman list style": "Toggle the lower–roman list style", "Toggle the square list style": "Toggle the square list style", "Toggle the upper–latin list style": "Toggle the upper–latin list style", "Toggle the upper–roman list style": "Toggle the upper–roman list style", "top with upwards arrow above": "top with upwards arrow above", "Trade mark sign": "Trade mark sign", "Tugrik sign": "Tugrik sign", "Turkish lira sign": "Turkish lira sign", Turquoise: "Turquoise", "Two dot leader": "Two dot leader", Underline: "Underline", Undo: "Undo", Union: "Union", Unlink: "Unlink", "up down arrow with base": "up down arrow with base", "Upload failed": "Upload failed", "Upload in progress": "Upload in progress", "Upper-latin": "Upper-latin", "Upper-roman": "Upper-roman", "upwards arrow to bar": "upwards arrow to bar", "upwards dashed arrow": "upwards dashed arrow", "upwards double arrow": "upwards double arrow", "upwards simple arrow": "upwards simple arrow", "Vertical text alignment toolbar": "Vertical text alignment toolbar", "Vulgar fraction one half": "Vulgar fraction one half", "Vulgar fraction one quarter": "Vulgar fraction one quarter", "Vulgar fraction three quarters": "Vulgar fraction three quarters", White: "White", "Widget toolbar": "Widget toolbar", Width: "Width", "Won sign": "Won sign", "Wrap text": "Wrap text", Yellow: "Yellow", "Yellow marker": "Yellow marker", "Yen sign": "Yen sign" }) })(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {}));
/*!
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */(function t(e, n) { if (typeof exports === "object" && typeof module === "object") module.exports = n(); else if (typeof define === "function" && define.amd) define([], n); else if (typeof exports === "object") exports["BalloonBlockEditor"] = n(); else e["BalloonBlockEditor"] = n() })(self, (() => (() => { "use strict"; var t = { 8180: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-content code{background-color:hsla(0,0%,78%,.3);border-radius:2px;padding:.15em}.ck.ck-editor__editable .ck-code_selected{background-color:hsla(0,0%,78%,.5)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-basic-styles/theme/code.css"], names: [], mappings: "AAKA,iBACC,kCAAuC,CAEvC,iBAAkB,CADlB,aAED,CAEA,0CACC,kCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content code {\n\tbackground-color: hsla(0, 0%, 78%, 0.3);\n\tpadding: .15em;\n\tborder-radius: 2px;\n}\n\n.ck.ck-editor__editable .ck-code_selected  {\n\tbackground-color: hsla(0, 0%, 78%, 0.5);\n}\n"], sourceRoot: "" }]); const c = a }, 636: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-content blockquote{border-left:5px solid #ccc;font-style:italic;margin-left:0;margin-right:0;overflow:hidden;padding-left:1.5em;padding-right:1.5em}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-block-quote/theme/blockquote.css"], names: [], mappings: "AAKA,uBAWC,0BAAsC,CADtC,iBAAkB,CAFlB,aAAc,CACd,cAAe,CAPf,eAAgB,CAIhB,kBAAmB,CADnB,mBAOD,CAEA,gCACC,aAAc,CACd,2BACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content blockquote {\n\t/* See #12 */\n\toverflow: hidden;\n\n\t/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */\n\tpadding-right: 1.5em;\n\tpadding-left: 1.5em;\n\n\tmargin-left: 0;\n\tmargin-right: 0;\n\tfont-style: italic;\n\tborder-left: solid 5px hsl(0, 0%, 80%);\n}\n\n.ck-content[dir="rtl"] blockquote {\n\tborder-left: 0;\n\tborder-right: solid 5px hsl(0, 0%, 80%);\n}\n'], sourceRoot: "" }]); const c = a }, 390: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-clipboard/theme/clipboard.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css"], names: [], mappings: "AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CCzBF,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CA2DF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: inline;\n\t\tposition: relative;\n\t\tpointer-events: none;\n\n\t\t& span {\n\t\t\tposition: absolute;\n\t\t\twidth: 0;\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\t& > .ck-widget__selection-handle {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t& > .ck-widget__type-around {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-clipboard-drop-target-dot-width: 12px;\n\t--ck-clipboard-drop-target-dot-height: 8px;\n\t--ck-clipboard-drop-target-color: var(--ck-color-focus-border)\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\t& span {\n\t\t\tbottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tbackground: var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-left: -1px;\n\n\t\t\t/* The triangle above the marker */\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: 50%;\n\t\t\t\ttop: calc(var(--ck-clipboard-drop-target-dot-height) * -.5);\n\n\t\t\t\ttransform: translateX(-50%);\n\t\t\t\tborder-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;\n\t\t\t\tborder-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t// Horizontal drop target (between blocks).\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: block;\n\t\tposition: relative;\n\t\twidth: 100%;\n\t\theight: 0;\n\t\tmargin: 0;\n\t\ttext-align: initial;\n\n\t\t& .ck-clipboard-drop-target__line {\n\t\t\tposition: absolute;\n\t\t\twidth: 100%;\n\t\t\theight: 0;\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-top: -1px;\n\n\t\t\t&::before {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent transparent transparent var(--ck-clipboard-drop-target-color);\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) 0 var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent var(--ck-clipboard-drop-target-color) transparent transparent;\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size)) var(--ck-clipboard-drop-target-dot-size) 0;\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\t/*\n\t * Styles of the widget that it a drop target.\n\t */\n\t& .ck-widget.ck-clipboard-drop-target-range {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\tzoom: 0.6;\n\t\toutline: none !important;\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 9085: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-content pre{background:hsla(0,0%,78%,.3);border:1px solid #c4c4c4;border-radius:2px;color:#353535;direction:ltr;font-style:normal;min-width:200px;padding:1em;tab-size:4;text-align:left;white-space:pre-wrap}.ck-content pre code{background:unset;border-radius:0;padding:0}.ck.ck-editor__editable pre{position:relative}.ck.ck-editor__editable pre[data-language]:after{content:attr(data-language);position:absolute}:root{--ck-color-code-block-label-background:#757575}.ck.ck-editor__editable pre[data-language]:after{background:var(--ck-color-code-block-label-background);color:#fff;font-family:var(--ck-font-face);font-size:10px;line-height:16px;padding:var(--ck-spacing-tiny) var(--ck-spacing-medium);right:10px;top:-1px;white-space:nowrap}.ck.ck-code-block-dropdown .ck-dropdown__panel{max-height:250px;overflow-x:hidden;overflow-y:auto}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-code-block/theme/codeblock.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-code-block/codeblock.css"], names: [], mappings: "AAKA,gBAGC,4BAAiC,CACjC,wBAAiC,CACjC,iBAAkB,CAHlB,aAAwB,CAOxB,aAAc,CAMd,iBAAkB,CAGlB,eAAgB,CAjBhB,WAAY,CAUZ,UAAW,CAHX,eAAgB,CAIhB,oBAaD,CALC,qBACC,gBAAiB,CAEjB,eAAgB,CADhB,SAED,CAGD,4BACC,iBAMD,CAJC,iDACC,2BAA4B,CAC5B,iBACD,CCjCD,MACC,8CACD,CAEA,iDAGC,sDAAuD,CAMvD,UAAuB,CAHvB,+BAAgC,CADhC,cAAe,CAEf,gBAAiB,CACjB,uDAAwD,CANxD,UAAW,CADX,QAAS,CAST,kBACD,CAEA,+CAEC,gBAAiB,CAEjB,iBAAkB,CADlB,eAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content pre {\n\tpadding: 1em;\n\tcolor: hsl(0, 0%, 20.8%);\n\tbackground: hsla(0, 0%, 78%, 0.3);\n\tborder: 1px solid hsl(0, 0%, 77%);\n\tborder-radius: 2px;\n\n\t/* Code block are language direction–agnostic. */\n\ttext-align: left;\n\tdirection: ltr;\n\n\ttab-size: 4;\n\twhite-space: pre-wrap;\n\n\t/* Don't inherit the style, e.g. when in a block quote. */\n\tfont-style: normal;\n\n\t/* Don't let the code be squashed e.g. when in a table cell. */\n\tmin-width: 200px;\n\n\t& code {\n\t\tbackground: unset;\n\t\tpadding: 0;\n\t\tborder-radius: 0;\n\t}\n}\n\n.ck.ck-editor__editable pre {\n\tposition: relative;\n\n\t&[data-language]::after {\n\t\tcontent: attr(data-language);\n\t\tposition: absolute;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-code-block-label-background: hsl(0, 0%, 46%);\n}\n\n.ck.ck-editor__editable pre[data-language]::after {\n\ttop: -1px;\n\tright: 10px;\n\tbackground: var(--ck-color-code-block-label-background);\n\n\tfont-size: 10px;\n\tfont-family: var(--ck-font-face);\n\tline-height: 16px;\n\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-medium);\n\tcolor: hsl(0, 0%, 100%);\n\twhite-space: nowrap;\n}\n\n.ck.ck-code-block-dropdown .ck-dropdown__panel {\n\t/* There could be dozens of languages available. Use scroll to prevent a 10e6px dropdown. */\n\tmax-height: 250px;\n\toverflow-y: auto;\n\toverflow-x: hidden;\n}\n"], sourceRoot: "" }]); const c = a }, 8894: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css"], names: [], mappings: "AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n\tposition: relative;\n\n\t&::before {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tcontent: attr(data-placeholder);\n\n\t\t/* See ckeditor/ckeditor5#469. */\n\t\tpointer-events: none;\n\t}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n\n/*\n * Rules for the `ck-placeholder` are loaded before the rules for `ck-reset_all` in the base CKEditor 5 DLL build.\n * This fix overwrites the incorrectly set `position: static` from `ck-reset_all`.\n * See https://github.com/ckeditor/ckeditor5/issues/11418.\n */\n.ck.ck-reset_all .ck-placeholder {\n\tposition: relative;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n\t&::before {\n\t\tcursor: text;\n\t\tcolor: var(--ck-color-engine-placeholder-text);\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 4401: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/renderer.css"], names: [], mappings: "AAMA,qDACC,YACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Elements marked by the Renderer as hidden should be invisible in the editor. */\n.ck.ck-editor__editable span[data-ck-unsafe-element] {\n\tdisplay: none;\n}\n"], sourceRoot: "" }]); const c = a }, 3230: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-heading/theme/heading.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css"], names: [], mappings: "AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-heading_heading1 {\n\tfont-size: 20px;\n}\n\n.ck.ck-heading_heading2 {\n\tfont-size: 17px;\n}\n\n.ck.ck-heading_heading3 {\n\tfont-size: 14px;\n}\n\n.ck[class*="ck-heading_heading"] {\n\tfont-weight: bold;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Resize dropdown's button label. */\n.ck.ck-dropdown.ck-heading-dropdown {\n\t& .ck-dropdown__button .ck-button__label {\n\t\twidth: 8em;\n\t}\n\n\t& .ck-dropdown__panel .ck-list__item {\n\t\tmin-width: 18em;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 713: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-highlight-marker-yellow:#fdfd77;--ck-highlight-marker-green:#62f962;--ck-highlight-marker-pink:#fc7899;--ck-highlight-marker-blue:#72ccfd;--ck-highlight-pen-red:#e71313;--ck-highlight-pen-green:#128a00}.ck-content .marker-yellow{background-color:var(--ck-highlight-marker-yellow)}.ck-content .marker-green{background-color:var(--ck-highlight-marker-green)}.ck-content .marker-pink{background-color:var(--ck-highlight-marker-pink)}.ck-content .marker-blue{background-color:var(--ck-highlight-marker-blue)}.ck-content .pen-red{background-color:transparent;color:var(--ck-highlight-pen-red)}.ck-content .pen-green{background-color:transparent;color:var(--ck-highlight-pen-green)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-highlight/theme/highlight.css"], names: [], mappings: "AAKA,MACC,oCAA+C,CAC/C,mCAA+C,CAC/C,kCAA8C,CAC9C,kCAA8C,CAC9C,8BAAwC,CACxC,gCACD,CAGC,2BACC,kDACD,CAFA,0BACC,iDACD,CAFA,yBACC,gDACD,CAFA,yBACC,gDACD,CAIA,qBAIC,4BAA6B,CAH7B,iCAID,CALA,uBAIC,4BAA6B,CAH7B,mCAID", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-highlight-marker-yellow: hsl(60, 97%, 73%);\n\t--ck-highlight-marker-green: hsl(120, 93%, 68%);\n\t--ck-highlight-marker-pink: hsl(345, 96%, 73%);\n\t--ck-highlight-marker-blue: hsl(201, 97%, 72%);\n\t--ck-highlight-pen-red: hsl(0, 85%, 49%);\n\t--ck-highlight-pen-green: hsl(112, 100%, 27%);\n}\n\n@define-mixin highlight-marker-color $color {\n\t.ck-content .marker-$color {\n\t\tbackground-color: var(--ck-highlight-marker-$color);\n\t}\n}\n\n@define-mixin highlight-pen-color $color {\n\t.ck-content .pen-$color {\n\t\tcolor: var(--ck-highlight-pen-$color);\n\n\t\t/* Override default yellow background of `<mark>` from user agent stylesheet */\n\t\tbackground-color: transparent;\n\t}\n}\n\n@mixin highlight-marker-color yellow;\n@mixin highlight-marker-color green;\n@mixin highlight-marker-color pink;\n@mixin highlight-marker-color blue;\n\n@mixin highlight-pen-color red;\n@mixin highlight-pen-color green;\n"], sourceRoot: "" }]); const c = a }, 2536: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-editor__editable .ck-horizontal-line{display:flow-root}.ck-content hr{background:#dedede;border:0;height:4px;margin:15px 0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-horizontal-line/theme/horizontalline.css"], names: [], mappings: "AAMA,yCAEC,iBACD,CAEA,eAGC,kBAA2B,CAC3B,QAAS,CAFT,UAAW,CADX,aAID", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n\n.ck-editor__editable .ck-horizontal-line {\n\t/* Necessary to render properly next to floated objects, e.g. side image case. */\n\tdisplay: flow-root;\n}\n\n.ck-content hr {\n\tmargin: 15px 0;\n\theight: 4px;\n\tbackground: hsl(0, 0%, 87%);\n\tborder: 0;\n}\n"], sourceRoot: "" }]); const c = a }, 8468: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-html-object-embed-unfocused-outline-width:1px}.ck-widget.html-object-embed{background-color:var(--ck-color-base-foreground);font-size:var(--ck-font-size-base);min-width:calc(76px + var(--ck-spacing-standard));padding:var(--ck-spacing-small);padding-top:calc(var(--ck-font-size-tiny) + var(--ck-spacing-large))}.ck-widget.html-object-embed:not(.ck-widget_selected):not(:hover){outline:var(--ck-html-object-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border)}.ck-widget.html-object-embed:before{background:#999;border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius);color:var(--ck-color-base-background);content:attr(data-html-object-embed-label);font-family:var(--ck-font-face);font-size:var(--ck-font-size-tiny);font-style:normal;font-weight:400;left:var(--ck-spacing-standard);padding:calc(var(--ck-spacing-tiny) + var(--ck-html-object-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);position:absolute;top:0;transition:background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck-widget.html-object-embed .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before{margin-left:50px}.ck-widget.html-object-embed .html-object-embed__content{pointer-events:none}div.ck-widget.html-object-embed{margin:1em auto}span.ck-widget.html-object-embed{display:inline-block}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-html-support/theme/datafilter.css"], names: [], mappings: "AAKA,MACC,kDACD,CAEA,6BAEC,gDAAiD,CADjD,kCAAmC,CAKnC,iDAAkD,CAHlD,+BAAgC,CAEhC,oEAgCD,CA7BC,kEACC,wGACD,CAEA,oCAOC,eAA4B,CAG5B,iEAAkE,CAClE,qCAAsC,CAPtC,0CAA2C,CAS3C,+BAAgC,CADhC,kCAAmC,CAVnC,iBAAkB,CADlB,eAAmB,CAKnB,+BAAgC,CAGhC,yIAA0I,CAN1I,iBAAkB,CAElB,KAAM,CAGN,0GAMD,CAGA,2HACC,gBACD,CAEA,yDAEC,mBACD,CAGD,gCACC,eACD,CAEA,iCACC,oBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-html-object-embed-unfocused-outline-width: 1px;\n}\n\n.ck-widget.html-object-embed {\n\tfont-size: var(--ck-font-size-base);\n\tbackground-color: var(--ck-color-base-foreground);\n\tpadding: var(--ck-spacing-small);\n\t/* Leave space for label */\n\tpadding-top: calc(var(--ck-font-size-tiny) + var(--ck-spacing-large));\n\tmin-width: calc(76px + var(--ck-spacing-standard));\n\n\t&:not(.ck-widget_selected):not(:hover) {\n\t\toutline: var(--ck-html-object-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border);\n\t}\n\n\t&::before {\n\t\tfont-weight: normal;\n\t\tfont-style: normal;\n\t\tposition: absolute;\n\t\tcontent: attr(data-html-object-embed-label);\n\t\ttop: 0;\n\t\tleft: var(--ck-spacing-standard);\n\t\tbackground: hsl(0deg 0% 60%);\n\t\ttransition: background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\t\tpadding: calc(var(--ck-spacing-tiny) + var(--ck-html-object-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);\n\t\tborder-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);\n\t\tcolor: var(--ck-color-base-background);\n\t\tfont-size: var(--ck-font-size-tiny);\n\t\tfont-family: var(--ck-font-face);\n\t}\n\n\t/* Make space for label. */\n\t& .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before {\n\t\tmargin-left: 50px;\n\t}\n\n\t& .html-object-embed__content {\n\t\t/* Disable user interaction with embed content */\n\t\tpointer-events: none;\n\t}\n}\n\ndiv.ck-widget.html-object-embed {\n\tmargin: 1em auto;\n}\n\nspan.ck-widget.html-object-embed {\n\tdisplay: inline-block;\n}\n\n"], sourceRoot: "" }]); const c = a }, 9048: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image-inline.ck-widget_selected,.ck.ck-editor__editable .image.ck-widget_selected{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/image.css"], names: [], mappings: "AAMC,mBAEC,UAAW,CADX,aAAc,CAOd,gBAAkB,CAGlB,cAAe,CARf,iBAuBD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD,CAGD,0BAYC,sBAAuB,CANvB,mBAAoB,CAGpB,cAoBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAWA,2GACC,SAUD,CAHC,qEACC,YACD,CAOA,0FACC,cACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content {\n\t& .image {\n\t\tdisplay: table;\n\t\tclear: both;\n\t\ttext-align: center;\n\n\t\t/* Make sure there is some space between the content and the image. Center image by default. */\n\t\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\t \tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\t\tmargin: 0.9em auto;\n\n\t\t/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\n\t\tmin-width: 50px;\n\n\t\t& img {\n\t\t\t/* Prevent unnecessary margins caused by line-height (see #44). */\n\t\t\tdisplay: block;\n\n\t\t\t/* Center the image if its width is smaller than the content\'s width. */\n\t\t\tmargin: 0 auto;\n\n\t\t\t/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\n\t\t\tmax-width: 100%;\n\n\t\t\t/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */\n\t\t\tmin-width: 100%\n\t\t}\n\t}\n\n\t& .image-inline {\n\t\t/*\n\t\t * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).\n\t\t * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.\n\t\t * This strange behavior does not happen with inline-flex.\n\t\t */\n\t\tdisplay: inline-flex;\n\n\t\t/* While being resized, don\'t allow the image to exceed the width of the editing root. */\n\t\tmax-width: 100%;\n\n\t\t/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */\n\t\talign-items: flex-start;\n\n\t\t/* When the picture is present it must act as a flex container to let the img resize properly */\n\t\t& picture {\n\t\t\tdisplay: flex;\n\t\t}\n\n\t\t/* When the picture is present, it must act like a resizable img. */\n\t\t& picture,\n\t\t& img {\n\t\t\t/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */\n\t\t\tflex-grow: 1;\n\t\t\tflex-shrink: 1;\n\n\t\t\t/* Prevents overflowing the editing root boundaries when an inline image is very wide. */\n\t\t\tmax-width: 100%;\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Inhertit the content styles padding of the <figcaption> in case the integration overrides `text-align: center`\n\t * of `.image` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native\n\t * caret does, and not at the edge of <figcaption>.\n\t */\n\t& .image > figcaption.ck-placeholder::before {\n\t\tpadding-left: inherit;\n\t\tpadding-right: inherit;\n\n\t\t/*\n\t\t * Make sure the image caption placeholder doesn\'t overflow the placeholder area.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9162.\n\t\t */\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t}\n\n\n\t/*\n\t * Make sure the selected inline image always stays on top of its siblings.\n\t * See https://github.com/ckeditor/ckeditor5/issues/9108.\n\t */\n\t& .image.ck-widget_selected {\n\t\tz-index: 1;\n\t}\n\n\t& .image-inline.ck-widget_selected {\n\t\tz-index: 1;\n\n\t\t/*\n\t\t * Make sure the native browser selection style is not displayed.\n\t\t * Inline image widgets have their own styles for the selected state and\n\t\t * leaving this up to the browser is asking for a visual collision.\n\t\t */\n\t\t& ::selection {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t/* The inline image nested in the table should have its original size if not resized.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\n\t& td,\n\t& th {\n\t\t& .image-inline img {\n\t\t\tmax-width: none;\n\t\t}\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 8662: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highligted-background:#fd0}.ck-content .image>figcaption{background-color:var(--ck-color-image-caption-background);caption-side:bottom;color:var(--ck-color-image-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;word-break:break-word}.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highligted-background)}to{background-color:var(--ck-color-image-caption-background)}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imagecaption.css"], names: [], mappings: "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,mDACD,CAGA,8BAKC,yDAA0D,CAH1D,mBAAoB,CAEpB,wCAAyC,CAHzC,qBAAsB,CAMtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,qBAMD,CAGA,qEACC,iDACD,CAEA,sCACC,GACC,oEACD,CAEA,GACC,yDACD,CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-caption-background: hsl(0, 0%, 97%);\n\t--ck-color-image-caption-text: hsl(0, 0%, 20%);\n\t--ck-color-image-caption-highligted-background: hsl(52deg 100% 50%);\n}\n\n/* Content styles */\n.ck-content .image > figcaption {\n\tdisplay: table-caption;\n\tcaption-side: bottom;\n\tword-break: break-word;\n\tcolor: var(--ck-color-image-caption-text);\n\tbackground-color: var(--ck-color-image-caption-background);\n\tpadding: .6em;\n\tfont-size: .75em;\n\toutline-offset: -1px;\n}\n\n/* Editing styles */\n.ck.ck-editor__editable .image > figcaption.image__caption_highlighted {\n\tanimation: ck-image-caption-highlight .6s ease-out;\n}\n\n@keyframes ck-image-caption-highlight {\n\t0% {\n\t\tbackground-color: var(--ck-color-image-caption-highligted-background);\n\t}\n\n\t100% {\n\t\tbackground-color: var(--ck-color-image-caption-background);\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 1043: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-content .image.image_resized{box-sizing:border-box;display:block;max-width:100%}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}.ck.ck-editor__editable td .image-inline.image_resized img,.ck.ck-editor__editable th .image-inline.image_resized img{max-width:100%}[dir=ltr] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-left:var(--ck-spacing-standard)}.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label{width:4em}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageresize.css"], names: [], mappings: "AAKA,iCAQC,qBAAsB,CADtB,aAAc,CANd,cAkBD,CATC,qCAEC,UACD,CAEA,4CAEC,aACD,CAQC,sHACC,cACD,CAIF,oFACC,uCACD,CAEA,oFACC,sCACD,CAEA,oEACC,SACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .image.image_resized {\n\tmax-width: 100%;\n\t/*\n\tThe `<figure>` element for resized images must not use `display:table` as browsers do not support `max-width` for it well.\n\tSee https://stackoverflow.com/questions/4019604/chrome-safari-ignoring-max-width-in-table/14420691#14420691 for more.\n\tFortunately, since we control the width, there is no risk that the image will look bad.\n\t*/\n\tdisplay: block;\n\tbox-sizing: border-box;\n\n\t& img {\n\t\t/* For resized images it is the `<figure>` element that determines the image width. */\n\t\twidth: 100%;\n\t}\n\n\t& > figcaption {\n\t\t/* The `<figure>` element uses `display:block`, so `<figcaption>` also has to. */\n\t\tdisplay: block;\n\t}\n}\n\n.ck.ck-editor__editable {\n\t/* The resized inline image nested in the table should respect its parent size.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\n\t& td,\n\t& th {\n\t\t& .image-inline.image_resized img {\n\t\t\tmax-width: 100%;\n\t\t}\n\t}\n}\n\n[dir="ltr"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n\tmargin-right: var(--ck-spacing-standard);\n}\n\n[dir="rtl"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n\tmargin-left: var(--ck-spacing-standard);\n}\n\n.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label {\n\twidth: 4em;\n}\n'], sourceRoot: "" }]); const c = a }, 4622: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imagestyle.css"], names: [], mappings: "AAKA,MACC,8BAA+B,CAC/B,qEACD,CAMC,qFAEC,oDACD,CAIA,yEAEC,UACD,CAEA,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAEA,2CAEC,gBAAiB,CADjB,cAED,CAEA,0CACC,aAAc,CACd,iBACD,CAGA,6GAGC,YACD,CAGC,mGAGC,kDAAmD,CADnD,+CAED,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,8nBACC,YACD,CAKD,oVAGC,2DACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-image-style-spacing: 1.5em;\n\t--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);\n}\n\n.ck-content {\n\t/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback\n\tconfirming successful application of the style if image width exceeds the editor's size.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9342 */\n\t& .image-style-block-align-left,\n\t& .image-style-block-align-right {\n\t\tmax-width: calc(100% - var(--ck-image-style-spacing));\n\t}\n\n\t/* Allows displaying multiple floating images in the same line.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */\n\t& .image-style-align-left,\n\t& .image-style-align-right {\n\t\tclear: none;\n\t}\n\n\t& .image-style-side {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t\tmax-width: 50%;\n\t}\n\n\t& .image-style-align-left {\n\t\tfloat: left;\n\t\tmargin-right: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-align-center {\n\t\tmargin-left: auto;\n\t\tmargin-right: auto;\n\t}\n\n\t& .image-style-align-right {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-block-align-right {\n\t\tmargin-right: 0;\n\t\tmargin-left: auto;\n\t}\n\n\t& .image-style-block-align-left {\n\t\tmargin-left: 0;\n\t\tmargin-right: auto;\n\t}\n\n\t/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */\n\t& p + .image-style-align-left,\n\t& p + .image-style-align-right,\n\t& p + .image-style-side {\n\t\tmargin-top: 0;\n\t}\n\n\t& .image-inline {\n\t\t&.image-style-align-left,\n\t\t&.image-style-align-right {\n\t\t\tmargin-top: var(--ck-inline-image-style-spacing);\n\t\t\tmargin-bottom: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-left {\n\t\t\tmargin-right: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-right {\n\t\t\tmargin-left: var(--ck-inline-image-style-spacing);\n\t\t}\n\t}\n}\n\n.ck.ck-splitbutton {\n\t/* The button should display as a regular drop-down if the action button\n\tis forced to fire the same action as the arrow button. */\n\t&.ck-splitbutton_flatten {\n\t\t&:hover,\n\t\t&.ck-splitbutton_open {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-background);\n\n\t\t\t\t&::after {\n\t\t\t\t\tdisplay: none;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t&.ck-splitbutton_open:hover {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-hover-background);\n\t\t\t}\n\t\t}\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 9899: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, '.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadicon.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css"], names: [], mappings: "AAKA,+BAUC,iBAAkB,CATlB,aAAc,CACd,iBAAkB,CAOlB,sCAAwC,CADxC,oCAAsC,CAGtC,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BAWC,sBAA4B,CAN5B,0BAAgC,CADhC,qCAAuC,CADvC,wEAA0E,CAD1E,uDAAwD,CAMxD,oDAAuD,CAWvD,oFAAuF,CAlBvF,SAAU,CAgBV,eAAgB,CAChB,mFA0BD,CAtBC,qCAgBC,mBAAsB,CADtB,sBAAyB,CAEzB,4BAA6B,CAH7B,4CAA6C,CAF7C,sFAAuF,CADvF,oFAAqF,CASrF,qBAAsB,CAdtB,QAAS,CAJT,QAAS,CAGT,SAAU,CADV,OAAQ,CAKR,mCAAoC,CACpC,yBAA0B,CAH1B,OAcD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GAGC,QAAS,CAFT,SAAU,CACV,OAED,CACA,IAEC,QAAS,CADT,UAED,CACA,GAGC,YAAc,CAFd,SAAU,CACV,UAED,CACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-image-upload-complete-icon {\n\tdisplay: block;\n\tposition: absolute;\n\n\t/*\n\t * Smaller images should have the icon closer to the border.\n\t * Match the icon position with the linked image indicator brought by the link image feature.\n\t */\n\ttop: min(var(--ck-spacing-medium), 6%);\n\tright: min(var(--ck-spacing-medium), 6%);\n\tborder-radius: 50%;\n\tz-index: 1;\n\n\t&::after {\n\t\tcontent: "";\n\t\tposition: absolute;\n\t}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-upload-icon: hsl(0, 0%, 100%);\n\t--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);\n\n\t/* Match the icon size with the linked image indicator brought by the link image feature. */\n\t--ck-image-upload-icon-size: 20;\n\t--ck-image-upload-icon-width: 2px;\n\t--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck-image-upload-complete-icon {\n\topacity: 0;\n\tbackground: var(--ck-color-image-upload-icon-background);\n\tanimation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;\n\tanimation-fill-mode: forwards, forwards;\n\tanimation-duration: 500ms, 500ms;\n\n\t/* To make animation scalable. */\n\tfont-size: calc(1px * var(--ck-image-upload-icon-size));\n\n\t/* Hide completed upload icon after 3 seconds. */\n\tanimation-delay: 0ms, 3000ms;\n\n\t/*\n\t * Use CSS math to simulate container queries.\n\t * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n\t */\n\toverflow: hidden;\n\twidth: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\theight: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\n\t/* This is check icon element made from border-width mixed with animations. */\n\t&::after {\n\t\t/* Because of border transformation we need to "hard code" left position. */\n\t\tleft: 25%;\n\n\t\ttop: 50%;\n\t\topacity: 0;\n\t\theight: 0;\n\t\twidth: 0;\n\n\t\ttransform: scaleX(-1) rotate(135deg);\n\t\ttransform-origin: left top;\n\t\tborder-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\t\tborder-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\n\t\tanimation-name: ck-upload-complete-icon-check;\n\t\tanimation-duration: 500ms;\n\t\tanimation-delay: 500ms;\n\t\tanimation-fill-mode: forwards;\n\n\t\t/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */\n\t\tbox-sizing: border-box;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-show {\n\tfrom {\n\t\topacity: 0;\n\t}\n\n\tto {\n\t\topacity: 1;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-hide {\n\tfrom {\n\t\topacity: 1;\n\t}\n\n\tto {\n\t\topacity: 0;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-check {\n\t0% {\n\t\topacity: 1;\n\t\twidth: 0;\n\t\theight: 0;\n\t}\n\t33% {\n\t\twidth: 0.3em;\n\t\theight: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t\twidth: 0.3em;\n\t\theight: 0.45em;\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 9825: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, '.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadloader.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css"], names: [], mappings: "AAKA,kCAGC,kBAAmB,CADnB,YAAa,CAEb,sBAAuB,CAEvB,MAAO,CALP,iBAAkB,CAIlB,KAOD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAGC,QAAS,CADT,UAgBD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCAEC,WAAY,CADZ,UAWD,CARC,yCAMC,yDAA0D,CAH1D,iBAAkB,CAElB,kCAAmC,CADnC,8DAA+D,CAF/D,+CAAgD,CADhD,8CAMD,CAGD,wCACC,GACC,uBACD,CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-upload-placeholder-loader {\n\tposition: absolute;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\ttop: 0;\n\tleft: 0;\n\n\t&::before {\n\t\tcontent: '';\n\t\tposition: relative;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);\n\t--ck-upload-placeholder-loader-size: 32px;\n\t--ck-upload-placeholder-image-aspect-ratio: 2.8;\n}\n\n.ck .ck-image-upload-placeholder {\n\t/* We need to control the full width of the SVG gray background. */\n\twidth: 100%;\n\tmargin: 0;\n\n\t&.image-inline {\n\t\twidth: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );\n\t}\n\n\t& img {\n\t\t/*\n\t\t * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.\n\t\t * There's nothing special about this number except that it should make the image placeholder look like\n\t\t * a real image during this short period after the upload started and before the image was read from the\n\t\t * file system (and a rich preview was loaded).\n\t\t */\n\t\taspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);\n\t}\n}\n\n.ck .ck-upload-placeholder-loader {\n\twidth: 100%;\n\theight: 100%;\n\n\t&::before {\n\t\twidth: var(--ck-upload-placeholder-loader-size);\n\t\theight: var(--ck-upload-placeholder-loader-size);\n\t\tborder-radius: 50%;\n\t\tborder-top: 3px solid var(--ck-color-upload-placeholder-loader);\n\t\tborder-right: 2px solid transparent;\n\t\tanimation: ck-upload-placeholder-loader 1s linear infinite;\n\t}\n}\n\n@keyframes ck-upload-placeholder-loader {\n\tto {\n\t\ttransform: rotate( 360deg );\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 5870: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadprogress.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css"], names: [], mappings: "AAMC,qEAEC,iBACD,CAGA,uGAIC,MAAO,CAFP,iBAAkB,CAClB,KAED,CCRC,yFACC,oBACD,CAID,uGAIC,gDAAiD,CAFjD,UAAW,CAGX,oBAAuB,CAFvB,OAGD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\tposition: relative;\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\t/* Showing animation. */\n\t\t&.ck-appear {\n\t\t\tanimation: fadeIn 700ms;\n\t\t}\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\theight: 2px;\n\t\twidth: 0;\n\t\tbackground: var(--ck-color-upload-bar-background);\n\t\ttransition: width 100ms;\n\t}\n}\n\n@keyframes fadeIn {\n\tfrom { opacity: 0; }\n\tto   { opacity: 1; }\n}\n"], sourceRoot: "" }]); const c = a }, 6831: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/textalternativeform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-text-alternative-form {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 399: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/link.css"], names: [], mappings: "AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Class added to span element surrounding currently selected link. */\n.ck .ck-link_selected {\n\tbackground: var(--ck-color-link-selected-background);\n\n\t/* Give linked inline images some outline to let the user know they are also part of the link. */\n\t& span.image-inline {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);\n\t}\n}\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when an input\n * in the link UI has focus (the browser does not render the native selection in this state).\n */\n.ck .ck-fake-link-selection {\n\tbackground: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-link-selection_collapsed {\n\theight: 100%;\n\tborder-right: 1px solid var(--ck-color-base-text);\n\tmargin-right: -1px;\n\toutline: solid 1px hsla(0, 0%, 100%, .5);\n}\n'], sourceRoot: "" }]); const c = a }, 9465: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{color:var(--ck-color-link-default);cursor:pointer;max-width:var(--ck-input-width);min-width:3em;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{max-width:100%;min-width:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkactions.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css"], names: [], mappings: "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCIA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EAEC,kCAAmC,CAEnC,cAAe,CAIf,+BAAgC,CAChC,aAAc,CARd,kCAAmC,CASnC,iBAAkB,CAPlB,sBAYD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDtDD,oCC0DC,wDACC,8DAMD,CAJC,0EAEC,cAAe,CADf,WAED,CAGD,gJAME,aAEF,CDzED", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-link-actions__preview {\n\t\tdisplay: inline-block;\n\n\t\t& .ck-button__label {\n\t\t\toverflow: hidden;\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-link-actions__preview {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\t& .ck-button.ck-link-actions__preview {\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\n\t\t& .ck-button__label {\n\t\t\tpadding: 0 var(--ck-spacing-medium);\n\t\t\tcolor: var(--ck-color-link-default);\n\t\t\ttext-overflow: ellipsis;\n\t\t\tcursor: pointer;\n\n\t\t\t/* Match the box model of the link editor form\'s input so the balloon\n\t\t\tdoes not change width when moving between actions and the form. */\n\t\t\tmax-width: var(--ck-input-width);\n\t\t\tmin-width: 3em;\n\t\t\ttext-align: center;\n\n\t\t\t&:hover {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\n\t\t&,\n\t\t&:hover,\n\t\t&:focus,\n\t\t&:active {\n\t\t\tbackground: none;\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&:focus {\n\t\t\t& .ck-button__label {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-button:not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-button:not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\t& .ck-button.ck-link-actions__preview {\n\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\n\t\t\t& .ck-button__label {\n\t\t\t\tmin-width: 0;\n\t\t\t\tmax-width: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 4827: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{min-width:var(--ck-input-width);padding:0}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical>.ck-button{border-radius:0;margin:0;padding:var(--ck-spacing-standard);width:50%}.ck.ck-link-form_layout-vertical>.ck-button:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form_layout-vertical>.ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css"], names: [], mappings: "AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCAEC,+BAAgC,CADhC,SAgDD,CA7CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CAIC,eAAgB,CAFhB,QAAS,CADT,kCAAmC,CAEnC,SAkBD,CAfC,wDACC,gDACD,CARD,4GAeE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAUD,CARC,wEACC,SAAU,CACV,UAKD,CAHC,8EACC,eACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-form {\n\tdisplay: flex;\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tdisplay: block;\n\n\t/*\n\t * Whether the form is in the responsive mode or not, if there are decorator buttons\n\t * keep the top margin of action buttons medium.\n\t */\n\t& .ck-button {\n\t\t&.ck-button-save,\n\t\t&.ck-button-cancel {\n\t\t\tmargin-top: var(--ck-spacing-medium);\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tpadding: 0;\n\tmin-width: var(--ck-input-width);\n\n\t& .ck-labeled-field-view {\n\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);\n\n\t\t& .ck-input-text {\n\t\t\tmin-width: 0;\n\t\t\twidth: 100%;\n\t\t}\n\t}\n\n\t& > .ck-button {\n\t\tpadding: var(--ck-spacing-standard);\n\t\tmargin: 0;\n\t\twidth: 50%;\n\t\tborder-radius: 0;\n\n\t\t&:not(:focus) {\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t}\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: 0;\n\n\t\t\t&:last-of-type {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Using additional `.ck` class for stronger CSS specificity than `.ck.ck-link-form > :not(:first-child)`. */\n\t& .ck.ck-list {\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\n\t\t& .ck-button.ck-switchbutton {\n\t\t\tpadding: 0;\n\t\t\twidth: 100%;\n\n\t\t\t&:hover {\n\t\t\t\tbackground: none;\n\t\t\t}\n\t\t}\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 3858: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, '.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{display:block;position:absolute}:root{--ck-link-image-indicator-icon-size:20;--ck-link-image-indicator-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{background-color:rgba(0,0,0,.4);background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");background-position:50%;background-repeat:no-repeat;background-size:14px;border-radius:100%;content:"";height:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size));overflow:hidden;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);width:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size))}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkimage.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkimage.css"], names: [], mappings: "AASE,+FACC,aAAc,CACd,iBACD,CCPF,MAEC,sCAAuC,CACvC,oEACD,CAME,+FAUC,+BAAqC,CACrC,83BAA+3B,CAG/3B,uBAA2B,CAD3B,2BAA4B,CAD5B,oBAAqB,CAGrB,kBAAmB,CAdnB,UAAW,CAsBX,oGAAuG,CAFvG,eAAgB,CAbhB,sCAAwC,CADxC,oCAAsC,CAetC,mGAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/* Linked image indicator */\n\t& figure.image > a,\n\t& a span.image-inline {\n\t\t&::after {\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t}\n\t}\n}\n\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Match the icon size with the upload indicator brought by the image upload feature. */\n\t--ck-link-image-indicator-icon-size: 20;\n\t--ck-link-image-indicator-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck.ck-editor__editable {\n\t/* Linked image indicator */\n\t& figure.image > a,\n\t& a span.image-inline {\n\t\t&::after {\n\t\t\tcontent: "";\n\n\t\t\t/*\n\t\t\t * Smaller images should have the icon closer to the border.\n\t\t\t * Match the icon position with the upload indicator brought by the image upload feature.\n\t\t\t */\n\t\t\ttop: min(var(--ck-spacing-medium), 6%);\n\t\t\tright: min(var(--ck-spacing-medium), 6%);\n\n\t\t\tbackground-color: hsla(0, 0%, 0%, .4);\n\t\t\tbackground-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");\n\t\t\tbackground-size: 14px;\n\t\t\tbackground-repeat: no-repeat;\n\t\t\tbackground-position: center;\n\t\t\tborder-radius: 100%;\n\n\t\t\t/*\n\t\t\t* Use CSS math to simulate container queries.\n\t\t\t* https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n\t\t\t*/\n\t\t\toverflow: hidden;\n\t\t\twidth: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));\n\t\t\theight: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));\n\t\t}\n\t}\n}\n\n'], sourceRoot: "" }]); const c = a }, 3195: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-collapsible.ck-collapsible_collapsed>.ck-collapsible__children{display:none}:root{--ck-collapsible-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-collapsible>.ck.ck-button{border-radius:0;color:inherit;font-weight:700;padding:var(--ck-spacing-medium) var(--ck-spacing-large);width:100%}.ck.ck-collapsible>.ck.ck-button:focus{background:transparent}.ck.ck-collapsible>.ck.ck-button:active,.ck.ck-collapsible>.ck.ck-button:hover:not(:focus),.ck.ck-collapsible>.ck.ck-button:not(:focus){background:transparent;border-color:transparent;box-shadow:none}.ck.ck-collapsible>.ck.ck-button>.ck-icon{margin-right:var(--ck-spacing-medium);width:var(--ck-collapsible-arrow-size)}.ck.ck-collapsible>.ck-collapsible__children{padding:0 var(--ck-spacing-large) var(--ck-spacing-large)}.ck.ck-collapsible.ck-collapsible_collapsed>.ck.ck-button .ck-icon{transform:rotate(-90deg)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-list/theme/collapsible.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/collapsible.css"], names: [], mappings: "AAMC,sEACC,YACD,CCHD,MACC,yDACD,CAGC,iCAIC,eAAgB,CAChB,aAAc,CAHd,eAAiB,CACjB,wDAAyD,CAFzD,UAoBD,CAdC,uCACC,sBACD,CAEA,wIACC,sBAAuB,CACvB,wBAAyB,CACzB,eACD,CAEA,0CACC,qCAAsC,CACtC,sCACD,CAGD,6CACC,yDACD,CAGC,mEACC,wBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-collapsible.ck-collapsible_collapsed {\n\t& > .ck-collapsible__children {\n\t\tdisplay: none;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-collapsible-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-collapsible {\n\t& > .ck.ck-button {\n\t\twidth: 100%;\n\t\tfont-weight: bold;\n\t\tpadding: var(--ck-spacing-medium) var(--ck-spacing-large);\n\t\tborder-radius: 0;\n\t\tcolor: inherit;\n\n\t\t&:focus {\n\t\t\tbackground: transparent;\n\t\t}\n\n\t\t&:active, &:not(:focus), &:hover:not(:focus) {\n\t\t\tbackground: transparent;\n\t\t\tborder-color: transparent;\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t& > .ck-icon {\n\t\t\tmargin-right: var(--ck-spacing-medium);\n\t\t\twidth: var(--ck-collapsible-arrow-size);\n\t\t}\n\t}\n\n\t& > .ck-collapsible__children {\n\t\tpadding: 0 var(--ck-spacing-large) var(--ck-spacing-large);\n\t}\n\n\t&.ck-collapsible_collapsed {\n\t\t& > .ck.ck-button .ck-icon {\n\t\t\ttransform: rotate(-90deg);\n\t\t}\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 9989: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-content ol{list-style-type:decimal}.ck-content ol ol{list-style-type:lower-latin}.ck-content ol ol ol{list-style-type:lower-roman}.ck-content ol ol ol ol{list-style-type:upper-latin}.ck-content ol ol ol ol ol{list-style-type:upper-roman}.ck-content ul{list-style-type:disc}.ck-content ul ul{list-style-type:circle}.ck-content ul ul ul,.ck-content ul ul ul ul{list-style-type:square}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-list/theme/list.css"], names: [], mappings: "AAKA,eACC,uBAiBD,CAfC,kBACC,2BAaD,CAXC,qBACC,2BASD,CAPC,wBACC,2BAKD,CAHC,2BACC,2BACD,CAMJ,eACC,oBAaD,CAXC,kBACC,sBASD,CAJE,6CACC,sBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content ol {\n\tlist-style-type: decimal;\n\n\t& ol {\n\t\tlist-style-type: lower-latin;\n\n\t\t& ol {\n\t\t\tlist-style-type: lower-roman;\n\n\t\t\t& ol {\n\t\t\t\tlist-style-type: upper-latin;\n\n\t\t\t\t& ol {\n\t\t\t\t\tlist-style-type: upper-roman;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck-content ul {\n\tlist-style-type: disc;\n\n\t& ul {\n\t\tlist-style-type: circle;\n\n\t\t& ul {\n\t\t\tlist-style-type: square;\n\n\t\t\t& ul {\n\t\t\t\tlist-style-type: square;\n\t\t\t}\n\t\t}\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 7133: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-list-properties.ck-list-properties_without-styles{padding:var(--ck-spacing-large)}.ck.ck-list-properties.ck-list-properties_without-styles>*{min-width:14em}.ck.ck-list-properties.ck-list-properties_without-styles>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-list-styles-list{grid-template-columns:repeat(4,auto)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible{border-top:1px solid var(--ck-color-base-border)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*{width:100%}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties .ck.ck-numbered-list-properties__start-index .ck-input{min-width:auto;width:100%}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order{background:transparent;margin-bottom:calc(var(--ck-spacing-tiny)*-1);padding-left:0;padding-right:0}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:active,.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:hover{background:none;border-color:transparent;box-shadow:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/listproperties.css"], names: [], mappings: "AAOC,yDACC,+BASD,CAPC,2DACC,cAKD,CAHC,6DACC,qCACD,CASD,wFACC,oCACD,CAGA,mFACC,gDAWD,CARE,+GACC,UAKD,CAHC,iHACC,qCACD,CAMJ,8EACC,cAAe,CACf,UACD,CAEA,uEACC,sBAAuB,CAGvB,6CAAgD,CAFhD,cAAe,CACf,eAQD,CALC,2JAGC,eAAgB,CADhB,wBAAyB,CADzB,eAGD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-properties {\n\t/* When there are no list styles and there is no collapsible. */\n\t&.ck-list-properties_without-styles {\n\t\tpadding: var(--ck-spacing-large);\n\n\t\t& > * {\n\t\t\tmin-width: 14em;\n\n\t\t\t& + * {\n\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * When the numbered list property fields (start at, reversed) should be displayed,\n\t * more horizontal space is needed. Reconfigure the style grid to create that space.\n\t */\n\t&.ck-list-properties_with-numbered-properties {\n\t\t& > .ck-list-styles-list {\n\t\t\tgrid-template-columns: repeat( 4, auto );\n\t\t}\n\n\t\t/* When list styles are rendered and property fields are in a collapsible. */\n\t\t& > .ck-collapsible {\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\n\t\t\t& > .ck-collapsible__children {\n\t\t\t\t& > * {\n\t\t\t\t\twidth: 100%;\n\n\t\t\t\t\t& + * {\n\t\t\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-numbered-list-properties__start-index .ck-input {\n\t\tmin-width: auto;\n\t\twidth: 100%;\n\t}\n\n\t& .ck.ck-numbered-list-properties__reversed-order {\n\t\tbackground: transparent;\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\t\tmargin-bottom: calc(-1 * var(--ck-spacing-tiny));\n\n\t\t&:active, &:hover {\n\t\t\tbox-shadow: none;\n\t\t\tborder-color: transparent;\n\t\t\tbackground: none;\n\t\t}\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 4553: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-list-styles-list{display:grid}:root{--ck-list-style-button-size:44px}.ck.ck-list-styles-list{column-gap:var(--ck-spacing-medium);grid-template-columns:repeat(3,auto);padding:var(--ck-spacing-large);row-gap:var(--ck-spacing-medium)}.ck.ck-list-styles-list .ck-button{box-sizing:content-box;margin:0;padding:0}.ck.ck-list-styles-list .ck-button,.ck.ck-list-styles-list .ck-button .ck-icon{height:var(--ck-list-style-button-size);width:var(--ck-list-style-button-size)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-list/theme/liststyles.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/liststyles.css"], names: [], mappings: "AAKA,wBACC,YACD,CCFA,MACC,gCACD,CAEA,wBAGC,mCAAoC,CAFpC,oCAAwC,CAGxC,+BAAgC,CAFhC,gCA4BD,CAxBC,mCAiBC,sBAAuB,CAPvB,QAAS,CANT,SAmBD,CAJC,+EAhBA,uCAAwC,CADxC,sCAoBA", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-styles-list {\n\tdisplay: grid;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-list-style-button-size: 44px;\n}\n\n.ck.ck-list-styles-list {\n\tgrid-template-columns: repeat( 3, auto );\n\trow-gap: var(--ck-spacing-medium);\n\tcolumn-gap: var(--ck-spacing-medium);\n\tpadding: var(--ck-spacing-large);\n\n\t& .ck-button {\n\t\t/* Make the button look like a thumbnail (the icon "takes it all"). */\n\t\twidth: var(--ck-list-style-button-size);\n\t\theight: var(--ck-list-style-button-size);\n\t\tpadding: 0;\n\n\t\t/*\n\t\t * Buttons are aligned by the grid so disable default button margins to not collide with the\n\t\t * gaps in the grid.\n\t\t */\n\t\tmargin: 0;\n\n\t\t/*\n\t\t * Make sure the button border (which is displayed on focus, BTW) does not steal pixels\n\t\t * from the button dimensions and, as a result, decrease the size of the icon\n\t\t * (which becomes blurry as it scales down).\n\t\t */\n\t\tbox-sizing: content-box;\n\n\t\t& .ck-icon {\n\t\t\twidth: var(--ck-list-style-button-size);\n\t\t\theight: var(--ck-list-style-button-size);\n\t\t}\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 5777: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-content .media{clear:both;display:block;margin:.9em 0;min-width:15em}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembed.css"], names: [], mappings: "AAKA,mBAGC,UAAW,CASX,aAAc,CAJd,aAAe,CAQf,cACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .media {\n\t/* Don\'t allow floated content overlap the media.\n\thttps://github.com/ckeditor/ckeditor5-media-embed/issues/53 */\n\tclear: both;\n\n\t/* Make sure there is some space between the content and the media. */\n\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\tmargin: 0.9em 0;\n\n\t/* Make sure media is not overriden with Bootstrap default `flex` value.\n\tSee: https://github.com/ckeditor/ckeditor5/issues/1373. */\n\tdisplay: block;\n\n\t/* Give the media some minimal width in the content to prevent them\n\tfrom being "squashed" in tight spaces, e.g. in table cells (#44) */\n\tmin-width: 15em;\n}\n'], sourceRoot: "" }]); const c = a }, 952: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, '.ck-media__wrapper .ck-media__placeholder{align-items:center;display:flex;flex-direction:column}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{display:block;overflow:hidden}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{background:var(--ck-color-base-foreground);padding:calc(var(--ck-spacing-standard)*3)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{background-position:50%;background-size:cover;height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);min-width:var(--ck-media-embed-placeholder-icon-size)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{height:100%;width:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);font-style:italic;text-align:center;text-overflow:ellipsis;white-space:nowrap}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-height:380px;max-width:300px}.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Im0yMDYuNDc3IDI2MC45LTI4Ljk4NyAyOC45ODdhNS4yMTggNS4yMTggMCAwIDAgMy43OCAxLjYxaDQ5LjYyMWMxLjY5NCAwIDMuMTktLjc5OCA0LjE0Ni0yLjAzN3oiIGZpbGw9IiM1Yzg4YzUiLz48cGF0aCBkPSJNMjI2Ljc0MiAyMjIuOTg4Yy05LjI2NiAwLTE2Ljc3NyA3LjE3LTE2Ljc3NyAxNi4wMTQuMDA3IDIuNzYyLjY2MyA1LjQ3NCAyLjA5MyA3Ljg3NS40My43MDMuODMgMS40MDggMS4xOSAyLjEwNy4zMzMuNTAyLjY1IDEuMDA1Ljk1IDEuNTA4LjM0My40NzcuNjczLjk1Ny45ODggMS40NCAxLjMxIDEuNzY5IDIuNSAzLjUwMiAzLjYzNyA1LjE2OC43OTMgMS4yNzUgMS42ODMgMi42NCAyLjQ2NiAzLjk5IDIuMzYzIDQuMDk0IDQuMDA3IDguMDkyIDQuNiAxMy45MTR2LjAxMmMuMTgyLjQxMi41MTYuNjY2Ljg3OS42NjcuNDAzLS4wMDEuNzY4LS4zMTQuOTMtLjc5OS42MDMtNS43NTYgMi4yMzgtOS43MjkgNC41ODUtMTMuNzk0Ljc4Mi0xLjM1IDEuNjczLTIuNzE1IDIuNDY1LTMuOTkgMS4xMzctMS42NjYgMi4zMjgtMy40IDMuNjM4LTUuMTY5LjMxNS0uNDgyLjY0NS0uOTYyLjk4OC0xLjQzOS4zLS41MDMuNjE3LTEuMDA2Ljk1LTEuNTA4LjM1OS0uNy43Ni0xLjQwNCAxLjE5LTIuMTA3IDEuNDI2LTIuNDAyIDItNS4xMTQgMi4wMDQtNy44NzUgMC04Ljg0NC03LjUxMS0xNi4wMTQtMTYuNzc2LTE2LjAxNHoiIGZpbGw9IiNkZDRiM2UiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PGVsbGlwc2Ugcnk9IjUuNTY0IiByeD0iNS44MjgiIGN5PSIyMzkuMDAyIiBjeD0iMjI2Ljc0MiIgZmlsbD0iIzgwMmQyNyIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMTkwLjMwMSAyMzcuMjgzYy00LjY3IDAtOC40NTcgMy44NTMtOC40NTcgOC42MDZzMy43ODYgOC42MDcgOC40NTcgOC42MDdjMy4wNDMgMCA0LjgwNi0uOTU4IDYuMzM3LTIuNTE2IDEuNTMtMS41NTcgMi4wODctMy45MTMgMi4wODctNi4yOSAwLS4zNjItLjAyMy0uNzIyLS4wNjQtMS4wNzloLTguMjU3djMuMDQzaDQuODVjLS4xOTcuNzU5LS41MzEgMS40NS0xLjA1OCAxLjk4Ni0uOTQyLjk1OC0yLjAyOCAxLjU0OC0zLjkwMSAxLjU0OC0yLjg3NiAwLTUuMjA4LTIuMzcyLTUuMjA4LTUuMjk5IDAtMi45MjYgMi4zMzItNS4yOTkgNS4yMDgtNS4yOTkgMS4zOTkgMCAyLjYxOC40MDcgMy41ODQgMS4yOTNsMi4zODEtMi4zOGMwLS4wMDItLjAwMy0uMDA0LS4wMDQtLjAwNS0xLjU4OC0xLjUyNC0zLjYyLTIuMjE1LTUuOTU1LTIuMjE1em00LjQzIDUuNjYuMDAzLjAwNnYtLjAwM3oiIGZpbGw9IiNmZmYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0ibTIxNS4xODQgMjUxLjkyOS03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVhNS4yMzMgNS4yMzMgMCAwIDAgLjQ0OS0yLjEyM3YtMzEuMTY1Yy0uNDY5LjY3NS0uOTM0IDEuMzQ5LTEuMzgyIDIuMDA1LS43OTIgMS4yNzUtMS42ODIgMi42NC0yLjQ2NSAzLjk5LTIuMzQ3IDQuMDY1LTMuOTgyIDguMDM4LTQuNTg1IDEzLjc5NC0uMTYyLjQ4NS0uNTI3Ljc5OC0uOTMuNzk5LS4zNjMtLjAwMS0uNjk3LS4yNTUtLjg3OS0uNjY3di0uMDEyYy0uNTkzLTUuODIyLTIuMjM3LTkuODItNC42LTEzLjkxNC0uNzgzLTEuMzUtMS42NzMtMi43MTUtMi40NjYtMy45OS0xLjEzNy0xLjY2Ni0yLjMyNy0zLjQtMy42MzctNS4xNjlsLS4wMDItLjAwM3oiIGZpbGw9IiNjM2MzYzMiLz48cGF0aCBkPSJtMjEyLjk4MyAyNDguNDk1LTM2Ljk1MiAzNi45NTN2LjgxMmE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOCA1LjIzOGgxLjAxNWwzNS42NjYtMzUuNjY2YTEzNi4yNzUgMTM2LjI3NSAwIDAgMC0yLjc2NC0zLjkgMzcuNTc1IDM3LjU3NSAwIDAgMC0uOTg5LTEuNDQgMzUuMTI3IDM1LjEyNyAwIDAgMC0uOTUtMS41MDhjLS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJtMjExLjk5OCAyNjEuMDgzLTYuMTUyIDYuMTUxIDI0LjI2NCAyNC4yNjRoLjc4MWE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOS01LjIzOHYtMS4wNDV6IiBmaWxsPSIjZmZmIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik05NjcuNDg0IDBINTYuNTE3QzI1LjMwNCAwIDAgMjUuMzA0IDAgNTYuNTE3djkxMC45NjZDMCA5OTguNjk0IDI1LjI5NyAxMDI0IDU2LjUyMiAxMDI0SDU0N1Y2MjhINDE0VjQ3M2gxMzNWMzU5LjAyOWMwLTEzMi4yNjIgODAuNzczLTIwNC4yODIgMTk4Ljc1Ni0yMDQuMjgyIDU2LjUxMyAwIDEwNS4wODYgNC4yMDggMTE5LjI0NCA2LjA4OVYyOTlsLTgxLjYxNi4wMzdjLTYzLjk5MyAwLTc2LjM4NCAzMC40OTItNzYuMzg0IDc1LjIzNlY0NzNoMTUzLjQ4N2wtMTkuOTg2IDE1NUg3MDd2Mzk2aDI2MC40ODRjMzEuMjEzIDAgNTYuNTE2LTI1LjMwMyA1Ni41MTYtNTYuNTE2VjU2LjUxNUMxMDI0IDI1LjMwMyA5OTguNjk3IDAgOTY3LjQ4NCAwIiBmaWxsPSIjRkZGRkZFIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OVptMCA0NS4zOTFjNjcuMjY1IDAgNzUuMjMzLjI1NyAxMDEuNzk3IDEuNDY5IDI0LjU2MiAxLjEyIDM3LjkwMSA1LjIyNCA0Ni43NzggOC42NzQgMTEuNzU5IDQuNTcgMjAuMTUxIDEwLjAyOSAyOC45NjYgMTguODQ1IDguODE2IDguODE1IDE0LjI3NSAxNy4yMDcgMTguODQ1IDI4Ljk2NiAzLjQ1IDguODc3IDcuNTU0IDIyLjIxNiA4LjY3NCA0Ni43NzggMS4yMTIgMjYuNTY0IDEuNDY5IDM0LjUzMiAxLjQ2OSAxMDEuNzk4IDAgNjcuMjY1LS4yNTcgNzUuMjMzLTEuNDY5IDEwMS43OTctMS4xMiAyNC41NjItNS4yMjQgMzcuOTAxLTguNjc0IDQ2Ljc3OC00LjU3IDExLjc1OS0xMC4wMjkgMjAuMTUxLTE4Ljg0NSAyOC45NjYtOC44MTUgOC44MTYtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1LTguODc3IDMuNDUtMjIuMjE2IDcuNTU0LTQ2Ljc3OCA4LjY3NC0yNi41NiAxLjIxMi0zNC41MjcgMS40NjktMTAxLjc5NyAxLjQ2OS02Ny4yNzEgMC03NS4yMzctLjI1Ny0xMDEuNzk4LTEuNDY5LTI0LjU2Mi0xLjEyLTM3LjkwMS01LjIyNC00Ni43NzgtOC42NzQtMTEuNzU5LTQuNTctMjAuMTUxLTEwLjAyOS0yOC45NjYtMTguODQ1LTguODE1LTguODE1LTE0LjI3NS0xNy4yMDctMTguODQ1LTI4Ljk2Ni0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NiA4LjgxNS04LjgxNiAxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDUgOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OVoiIGZpbGw9IiNGRkYiIG1hc2s9InVybCgjYikiLz48cGF0aCBkPSJNMjUxLjkyMSAzMzYuMDUzYy00Ni4zNzggMC04My45NzQtMzcuNTk2LTgzLjk3NC04My45NzMgMC00Ni4zNzggMzcuNTk2LTgzLjk3NCA4My45NzQtODMuOTc0IDQ2LjM3NyAwIDgzLjk3MyAzNy41OTYgODMuOTczIDgzLjk3NCAwIDQ2LjM3Ny0zNy41OTYgODMuOTczLTgzLjk3MyA4My45NzNabTAtMjEzLjMzOGMtNzEuNDQ3IDAtMTI5LjM2NSA1Ny45MTgtMTI5LjM2NSAxMjkuMzY1IDAgNzEuNDQ2IDU3LjkxOCAxMjkuMzY0IDEyOS4zNjUgMTI5LjM2NCA3MS40NDYgMCAxMjkuMzY0LTU3LjkxOCAxMjkuMzY0LTEyOS4zNjQgMC03MS40NDctNTcuOTE4LTEyOS4zNjUtMTI5LjM2NC0xMjkuMzY1Wk00MTYuNjI3IDExNy42MDRjMCAxNi42OTYtMTMuNTM1IDMwLjIzLTMwLjIzMSAzMC4yMy0xNi42OTUgMC0zMC4yMy0xMy41MzQtMzAuMjMtMzAuMjMgMC0xNi42OTYgMTMuNTM1LTMwLjIzMSAzMC4yMy0zMC4yMzEgMTYuNjk2IDAgMzAuMjMxIDEzLjUzNSAzMC4yMzEgMzAuMjMxIiBmaWxsPSIjRkZGIi8+PC9nPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0MDAgNDAwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwMHpNMTYzLjQgMzA1LjVjODguNyAwIDEzNy4yLTczLjUgMTM3LjItMTM3LjIgMC0yLjEgMC00LjItLjEtNi4yIDkuNC02LjggMTcuNi0xNS4zIDI0LjEtMjUtOC42IDMuOC0xNy45IDYuNC0yNy43IDcuNiAxMC02IDE3LjYtMTUuNCAyMS4yLTI2LjctOS4zIDUuNS0xOS42IDkuNS0zMC42IDExLjctOC44LTkuNC0yMS4zLTE1LjItMzUuMi0xNS4yLTI2LjYgMC00OC4yIDIxLjYtNDguMiA0OC4yIDAgMy44LjQgNy41IDEuMyAxMS00MC4xLTItNzUuNi0yMS4yLTk5LjQtNTAuNC00LjEgNy4xLTYuNSAxNS40LTYuNSAyNC4yIDAgMTYuNyA4LjUgMzEuNSAyMS41IDQwLjEtNy45LS4yLTE1LjMtMi40LTIxLjgtNnYuNmMwIDIzLjQgMTYuNiA0Mi44IDM4LjcgNDcuMy00IDEuMS04LjMgMS43LTEyLjcgMS43LTMuMSAwLTYuMS0uMy05LjEtLjkgNi4xIDE5LjIgMjMuOSAzMy4xIDQ1IDMzLjUtMTYuNSAxMi45LTM3LjMgMjAuNi01OS45IDIwLjYtMy45IDAtNy43LS4yLTExLjUtLjcgMjEuMSAxMy44IDQ2LjUgMjEuOCA3My43IDIxLjgiIHN0eWxlPSJmaWxsOiNmZmYiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembedediting.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-media-embed/mediaembedediting.css"], names: [], mappings: "AAMC,0CAGC,kBAAmB,CAFnB,YAAa,CACb,qBAcD,CAXC,sEAEC,cAAe,CAEf,iBAMD,CAJC,wGAEC,aAAc,CADd,eAED,CAWD,6kBACC,YACD,CAYF,2LACC,mBACD,CC1CA,MACC,0CAA2C,CAE3C,mDAA4D,CAC5D,2EACD,CAEA,mBACC,aA+FD,CA7FC,0CAEC,0CAA2C,CAD3C,0CA6BD,CA1BC,uEAIC,uBAA2B,CAC3B,qBAAsB,CAHtB,kDAAmD,CACnD,qCAAsC,CAFtC,qDAUD,CAJC,gFAEC,WAAY,CADZ,UAED,CAGD,4EACC,sDAAuD,CAGvD,iBAAkB,CADlB,iBAAkB,CAElB,sBAAuB,CAHvB,kBAUD,CALC,kFACC,4DAA6D,CAC7D,cAAe,CACf,yBACD,CAIF,wDAEC,gBAAiB,CADjB,eAED,CAEA,4UAIC,wvGACD,CAEA,2EACC,kBAaD,CAXC,wGACC,orBACD,CAEA,6GACC,UAKD,CAHC,mHACC,UACD,CAIF,4EACC,2DAcD,CAZC,yGACC,4jHACD,CAGA,8GACC,aAKD,CAHC,oHACC,UACD,CAIF,6EAEC,iDAaD,CAXC,0GACC,wiCACD,CAEA,+GACC,aAKD,CAHC,qHACC,UACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-media__wrapper {\n\t& .ck-media__placeholder {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\talign-items: center;\n\n\t\t& .ck-media__placeholder__url {\n\t\t\t/* Otherwise the URL will overflow when the content is very narrow. */\n\t\t\tmax-width: 100%;\n\n\t\t\tposition: relative;\n\n\t\t\t& .ck-media__placeholder__url__text {\n\t\t\t\toverflow: hidden;\n\t\t\t\tdisplay: block;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="twitter.com"],\n\t&[data-oembed-url*="google.com/maps"],\n\t&[data-oembed-url*="goo.gl/maps"],\n\t&[data-oembed-url*="maps.google.com"],\n\t&[data-oembed-url*="maps.app.goo.gl"],\n\t&[data-oembed-url*="facebook.com"],\n\t&[data-oembed-url*="instagram.com"] {\n\t\t& .ck-media__placeholder__icon * {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/* Disable all mouse interaction as long as the editor is not read–only.\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/58 */\n.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper > *:not(.ck-media__placeholder) {\n\tpointer-events: none;\n}\n\n/* Disable all mouse interaction when the widget is not selected (e.g. to avoid opening links by accident).\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/18 */\n.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder {\n\tpointer-events: none;\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-media-embed-placeholder-icon-size: 3em;\n\n\t--ck-color-media-embed-placeholder-url-text: hsl(0, 0%, 46%);\n\t--ck-color-media-embed-placeholder-url-text-hover: var(--ck-color-base-text);\n}\n\n.ck-media__wrapper {\n\tmargin: 0 auto;\n\n\t& .ck-media__placeholder {\n\t\tpadding: calc( 3 * var(--ck-spacing-standard) );\n\t\tbackground: var(--ck-color-base-foreground);\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tmin-width: var(--ck-media-embed-placeholder-icon-size);\n\t\t\theight: var(--ck-media-embed-placeholder-icon-size);\n\t\t\tmargin-bottom: var(--ck-spacing-large);\n\t\t\tbackground-position: center;\n\t\t\tbackground-size: cover;\n\n\t\t\t& .ck-icon {\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: var(--ck-color-media-embed-placeholder-url-text);\n\t\t\twhite-space: nowrap;\n\t\t\ttext-align: center;\n\t\t\tfont-style: italic;\n\t\t\ttext-overflow: ellipsis;\n\n\t\t\t&:hover {\n\t\t\t\tcolor: var(--ck-color-media-embed-placeholder-url-text-hover);\n\t\t\t\tcursor: pointer;\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="open.spotify.com"] {\n\t\tmax-width: 300px;\n\t\tmax-height: 380px;\n\t}\n\n\t&[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon {\n\t\tbackground-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMCAwIDMuNzggMS42MWg0OS42MjFjMS42OTQgMCAzLjE5LS43OTggNC4xNDYtMi4wMzd6IiBmaWxsPSIjNWM4OGM1Ii8+PHBhdGggZD0iTTIyNi43NDIgMjIyLjk4OGMtOS4yNjYgMC0xNi43NzcgNy4xNy0xNi43NzcgMTYuMDE0LjAwNyAyLjc2Mi42NjMgNS40NzQgMi4wOTMgNy44NzUuNDMuNzAzLjgzIDEuNDA4IDEuMTkgMi4xMDcuMzMzLjUwMi42NSAxLjAwNS45NSAxLjUwOC4zNDMuNDc3LjY3My45NTcuOTg4IDEuNDQgMS4zMSAxLjc2OSAyLjUgMy41MDIgMy42MzcgNS4xNjguNzkzIDEuMjc1IDEuNjgzIDIuNjQgMi40NjYgMy45OSAyLjM2MyA0LjA5NCA0LjAwNyA4LjA5MiA0LjYgMTMuOTE0di4wMTJjLjE4Mi40MTIuNTE2LjY2Ni44NzkuNjY3LjQwMy0uMDAxLjc2OC0uMzE0LjkzLS43OTkuNjAzLTUuNzU2IDIuMjM4LTkuNzI5IDQuNTg1LTEzLjc5NC43ODItMS4zNSAxLjY3My0yLjcxNSAyLjQ2NS0zLjk5IDEuMTM3LTEuNjY2IDIuMzI4LTMuNCAzLjYzOC01LjE2OS4zMTUtLjQ4Mi42NDUtLjk2Mi45ODgtMS40MzkuMy0uNTAzLjYxNy0xLjAwNi45NS0xLjUwOC4zNTktLjcuNzYtMS40MDQgMS4xOS0yLjEwNyAxLjQyNi0yLjQwMiAyLTUuMTE0IDIuMDA0LTcuODc1IDAtOC44NDQtNy41MTEtMTYuMDE0LTE2Ljc3Ni0xNi4wMTR6IiBmaWxsPSIjZGQ0YjNlIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxlbGxpcHNlIHJ5PSI1LjU2NCIgcng9IjUuODI4IiBjeT0iMjM5LjAwMiIgY3g9IjIyNi43NDIiIGZpbGw9IiM4MDJkMjciIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTE5MC4zMDEgMjM3LjI4M2MtNC42NyAwLTguNDU3IDMuODUzLTguNDU3IDguNjA2czMuNzg2IDguNjA3IDguNDU3IDguNjA3YzMuMDQzIDAgNC44MDYtLjk1OCA2LjMzNy0yLjUxNiAxLjUzLTEuNTU3IDIuMDg3LTMuOTEzIDIuMDg3LTYuMjkgMC0uMzYyLS4wMjMtLjcyMi0uMDY0LTEuMDc5aC04LjI1N3YzLjA0M2g0Ljg1Yy0uMTk3Ljc1OS0uNTMxIDEuNDUtMS4wNTggMS45ODYtLjk0Mi45NTgtMi4wMjggMS41NDgtMy45MDEgMS41NDgtMi44NzYgMC01LjIwOC0yLjM3Mi01LjIwOC01LjI5OSAwLTIuOTI2IDIuMzMyLTUuMjk5IDUuMjA4LTUuMjk5IDEuMzk5IDAgMi42MTguNDA3IDMuNTg0IDEuMjkzbDIuMzgxLTIuMzhjMC0uMDAyLS4wMDMtLjAwNC0uMDA0LS4wMDUtMS41ODgtMS41MjQtMy42Mi0yLjIxNS01Ljk1NS0yLjIxNXptNC40MyA1LjY2bC4wMDMuMDA2di0uMDAzeiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjE1LjE4NCAyNTEuOTI5bC03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVjLjI4Ny0uNjQ5LjQ0OS0xLjM2Ni40NDktMi4xMjN2LTMxLjE2NWMtLjQ2OS42NzUtLjkzNCAxLjM0OS0xLjM4MiAyLjAwNS0uNzkyIDEuMjc1LTEuNjgyIDIuNjQtMi40NjUgMy45OS0yLjM0NyA0LjA2NS0zLjk4MiA4LjAzOC00LjU4NSAxMy43OTQtLjE2Mi40ODUtLjUyNy43OTgtLjkzLjc5OS0uMzYzLS4wMDEtLjY5Ny0uMjU1LS44NzktLjY2N3YtLjAxMmMtLjU5My01LjgyMi0yLjIzNy05LjgyLTQuNi0xMy45MTQtLjc4My0xLjM1LTEuNjczLTIuNzE1LTIuNDY2LTMuOTktMS4xMzctMS42NjYtMi4zMjctMy40LTMuNjM3LTUuMTY5bC0uMDAyLS4wMDN6IiBmaWxsPSIjYzNjM2MzIi8+PHBhdGggZD0iTTIxMi45ODMgMjQ4LjQ5NWwtMzYuOTUyIDM2Ljk1M3YuODEyYTUuMjI3IDUuMjI3IDAgMCAwIDUuMjM4IDUuMjM4aDEuMDE1bDM1LjY2Ni0zNS42NjZhMTM2LjI3NSAxMzYuMjc1IDAgMCAwLTIuNzY0LTMuOSAzNy41NzUgMzcuNTc1IDAgMCAwLS45ODktMS40NGMtLjI5OS0uNTAzLS42MTYtMS4wMDYtLjk1LTEuNTA4LS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjExLjk5OCAyNjEuMDgzbC02LjE1MiA2LjE1MSAyNC4yNjQgMjQuMjY0aC43ODFhNS4yMjcgNS4yMjcgMCAwIDAgNS4yMzktNS4yMzh2LTEuMDQ1eiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48L2c+PC9zdmc+);\n\t}\n\n\t&[data-oembed-url*="facebook.com"] .ck-media__placeholder {\n\t\tbackground: hsl(220, 46%, 48%);\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSIxMDI0cHgiIGhlaWdodD0iMTAyNHB4IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPiAgICAgICAgPHRpdGxlPkZpbGwgMTwvdGl0bGU+ICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPiAgICA8ZGVmcz48L2RlZnM+ICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgICAgICAgPGcgaWQ9ImZMb2dvX1doaXRlIiBmaWxsPSIjRkZGRkZFIj4gICAgICAgICAgICA8cGF0aCBkPSJNOTY3LjQ4NCwwIEw1Ni41MTcsMCBDMjUuMzA0LDAgMCwyNS4zMDQgMCw1Ni41MTcgTDAsOTY3LjQ4MyBDMCw5OTguNjk0IDI1LjI5NywxMDI0IDU2LjUyMiwxMDI0IEw1NDcsMTAyNCBMNTQ3LDYyOCBMNDE0LDYyOCBMNDE0LDQ3MyBMNTQ3LDQ3MyBMNTQ3LDM1OS4wMjkgQzU0NywyMjYuNzY3IDYyNy43NzMsMTU0Ljc0NyA3NDUuNzU2LDE1NC43NDcgQzgwMi4yNjksMTU0Ljc0NyA4NTAuODQyLDE1OC45NTUgODY1LDE2MC44MzYgTDg2NSwyOTkgTDc4My4zODQsMjk5LjAzNyBDNzE5LjM5MSwyOTkuMDM3IDcwNywzMjkuNTI5IDcwNywzNzQuMjczIEw3MDcsNDczIEw4NjAuNDg3LDQ3MyBMODQwLjUwMSw2MjggTDcwNyw2MjggTDcwNywxMDI0IEw5NjcuNDg0LDEwMjQgQzk5OC42OTcsMTAyNCAxMDI0LDk5OC42OTcgMTAyNCw5NjcuNDg0IEwxMDI0LDU2LjUxNSBDMTAyNCwyNS4zMDMgOTk4LjY5NywwIDk2Ny40ODQsMCIgaWQ9IkZpbGwtMSI+PC9wYXRoPiAgICAgICAgPC9nPiAgICA8L2c+PC9zdmc+);\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(220, 100%, 90%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="instagram.com"] .ck-media__placeholder {\n\t\tbackground: linear-gradient(-135deg,hsl(246, 100%, 39%),hsl(302, 100%, 36%),hsl(0, 100%, 48%));\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSI1MDRweCIgaGVpZ2h0PSI1MDRweCIgdmlld0JveD0iMCAwIDUwNCA1MDQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+ICAgICAgICA8dGl0bGU+Z2x5cGgtbG9nb19NYXkyMDE2PC90aXRsZT4gICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+ICAgIDxkZWZzPiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMSIgcG9pbnRzPSIwIDAuMTU5IDUwMy44NDEgMC4xNTkgNTAzLjg0MSA1MDMuOTQgMCA1MDMuOTQiPjwvcG9seWdvbj4gICAgPC9kZWZzPiAgICA8ZyBpZD0iZ2x5cGgtbG9nb19NYXkyMDE2IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4gICAgICAgIDxnIGlkPSJHcm91cC0zIj4gICAgICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBmaWxsPSJ3aGl0ZSI+ICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+ICAgICAgICAgICAgPC9tYXNrPiAgICAgICAgICAgIDxnIGlkPSJDbGlwLTIiPjwvZz4gICAgICAgICAgICA8cGF0aCBkPSJNMjUxLjkyMSwwLjE1OSBDMTgzLjUwMywwLjE1OSAxNzQuOTI0LDAuNDQ5IDE0OC4wNTQsMS42NzUgQzEyMS4yNCwyLjg5OCAxMDIuOTI3LDcuMTU3IDg2LjkwMywxMy4zODUgQzcwLjMzNywxOS44MjIgNTYuMjg4LDI4LjQzNiA0Mi4yODIsNDIuNDQxIEMyOC4yNzcsNTYuNDQ3IDE5LjY2Myw3MC40OTYgMTMuMjI2LDg3LjA2MiBDNi45OTgsMTAzLjA4NiAyLjczOSwxMjEuMzk5IDEuNTE2LDE0OC4yMTMgQzAuMjksMTc1LjA4MyAwLDE4My42NjIgMCwyNTIuMDggQzAsMzIwLjQ5NyAwLjI5LDMyOS4wNzYgMS41MTYsMzU1Ljk0NiBDMi43MzksMzgyLjc2IDYuOTk4LDQwMS4wNzMgMTMuMjI2LDQxNy4wOTcgQzE5LjY2Myw0MzMuNjYzIDI4LjI3Nyw0NDcuNzEyIDQyLjI4Miw0NjEuNzE4IEM1Ni4yODgsNDc1LjcyMyA3MC4zMzcsNDg0LjMzNyA4Ni45MDMsNDkwLjc3NSBDMTAyLjkyNyw0OTcuMDAyIDEyMS4yNCw1MDEuMjYxIDE0OC4wNTQsNTAyLjQ4NCBDMTc0LjkyNCw1MDMuNzEgMTgzLjUwMyw1MDQgMjUxLjkyMSw1MDQgQzMyMC4zMzgsNTA0IDMyOC45MTcsNTAzLjcxIDM1NS43ODcsNTAyLjQ4NCBDMzgyLjYwMSw1MDEuMjYxIDQwMC45MTQsNDk3LjAwMiA0MTYuOTM4LDQ5MC43NzUgQzQzMy41MDQsNDg0LjMzNyA0NDcuNTUzLDQ3NS43MjMgNDYxLjU1OSw0NjEuNzE4IEM0NzUuNTY0LDQ0Ny43MTIgNDg0LjE3OCw0MzMuNjYzIDQ5MC42MTYsNDE3LjA5NyBDNDk2Ljg0Myw0MDEuMDczIDUwMS4xMDIsMzgyLjc2IDUwMi4zMjUsMzU1Ljk0NiBDNTAzLjU1MSwzMjkuMDc2IDUwMy44NDEsMzIwLjQ5NyA1MDMuODQxLDI1Mi4wOCBDNTAzLjg0MSwxODMuNjYyIDUwMy41NTEsMTc1LjA4MyA1MDIuMzI1LDE0OC4yMTMgQzUwMS4xMDIsMTIxLjM5OSA0OTYuODQzLDEwMy4wODYgNDkwLjYxNiw4Ny4wNjIgQzQ4NC4xNzgsNzAuNDk2IDQ3NS41NjQsNTYuNDQ3IDQ2MS41NTksNDIuNDQxIEM0NDcuNTUzLDI4LjQzNiA0MzMuNTA0LDE5LjgyMiA0MTYuOTM4LDEzLjM4NSBDNDAwLjkxNCw3LjE1NyAzODIuNjAxLDIuODk4IDM1NS43ODcsMS42NzUgQzMyOC45MTcsMC40NDkgMzIwLjMzOCwwLjE1OSAyNTEuOTIxLDAuMTU5IFogTTI1MS45MjEsNDUuNTUgQzMxOS4xODYsNDUuNTUgMzI3LjE1NCw0NS44MDcgMzUzLjcxOCw0Ny4wMTkgQzM3OC4yOCw0OC4xMzkgMzkxLjYxOSw1Mi4yNDMgNDAwLjQ5Niw1NS42OTMgQzQxMi4yNTUsNjAuMjYzIDQyMC42NDcsNjUuNzIyIDQyOS40NjIsNzQuNTM4IEM0MzguMjc4LDgzLjM1MyA0NDMuNzM3LDkxLjc0NSA0NDguMzA3LDEwMy41MDQgQzQ1MS43NTcsMTEyLjM4MSA0NTUuODYxLDEyNS43MiA0NTYuOTgxLDE1MC4yODIgQzQ1OC4xOTMsMTc2Ljg0NiA0NTguNDUsMTg0LjgxNCA0NTguNDUsMjUyLjA4IEM0NTguNDUsMzE5LjM0NSA0NTguMTkzLDMyNy4zMTMgNDU2Ljk4MSwzNTMuODc3IEM0NTUuODYxLDM3OC40MzkgNDUxLjc1NywzOTEuNzc4IDQ0OC4zMDcsNDAwLjY1NSBDNDQzLjczNyw0MTIuNDE0IDQzOC4yNzgsNDIwLjgwNiA0MjkuNDYyLDQyOS42MjEgQzQyMC42NDcsNDM4LjQzNyA0MTIuMjU1LDQ0My44OTYgNDAwLjQ5Niw0NDguNDY2IEMzOTEuNjE5LDQ1MS45MTYgMzc4LjI4LDQ1Ni4wMiAzNTMuNzE4LDQ1Ny4xNCBDMzI3LjE1OCw0NTguMzUyIDMxOS4xOTEsNDU4LjYwOSAyNTEuOTIxLDQ1OC42MDkgQzE4NC42NSw0NTguNjA5IDE3Ni42ODQsNDU4LjM1MiAxNTAuMTIzLDQ1Ny4xNCBDMTI1LjU2MSw0NTYuMDIgMTEyLjIyMiw0NTEuOTE2IDEwMy4zNDUsNDQ4LjQ2NiBDOTEuNTg2LDQ0My44OTYgODMuMTk0LDQzOC40MzcgNzQuMzc5LDQyOS42MjEgQzY1LjU2NCw0MjAuODA2IDYwLjEwNCw0MTIuNDE0IDU1LjUzNCw0MDAuNjU1IEM1Mi4wODQsMzkxLjc3OCA0Ny45OCwzNzguNDM5IDQ2Ljg2LDM1My44NzcgQzQ1LjY0OCwzMjcuMzEzIDQ1LjM5MSwzMTkuMzQ1IDQ1LjM5MSwyNTIuMDggQzQ1LjM5MSwxODQuODE0IDQ1LjY0OCwxNzYuODQ2IDQ2Ljg2LDE1MC4yODIgQzQ3Ljk4LDEyNS43MiA1Mi4wODQsMTEyLjM4MSA1NS41MzQsMTAzLjUwNCBDNjAuMTA0LDkxLjc0NSA2NS41NjMsODMuMzUzIDc0LjM3OSw3NC41MzggQzgzLjE5NCw2NS43MjIgOTEuNTg2LDYwLjI2MyAxMDMuMzQ1LDU1LjY5MyBDMTEyLjIyMiw1Mi4yNDMgMTI1LjU2MSw0OC4xMzkgMTUwLjEyMyw0Ny4wMTkgQzE3Ni42ODcsNDUuODA3IDE4NC42NTUsNDUuNTUgMjUxLjkyMSw0NS41NSBaIiBpZD0iRmlsbC0xIiBmaWxsPSIjRkZGRkZGIiBtYXNrPSJ1cmwoI21hc2stMikiPjwvcGF0aD4gICAgICAgIDwvZz4gICAgICAgIDxwYXRoIGQ9Ik0yNTEuOTIxLDMzNi4wNTMgQzIwNS41NDMsMzM2LjA1MyAxNjcuOTQ3LDI5OC40NTcgMTY3Ljk0NywyNTIuMDggQzE2Ny45NDcsMjA1LjcwMiAyMDUuNTQzLDE2OC4xMDYgMjUxLjkyMSwxNjguMTA2IEMyOTguMjk4LDE2OC4xMDYgMzM1Ljg5NCwyMDUuNzAyIDMzNS44OTQsMjUyLjA4IEMzMzUuODk0LDI5OC40NTcgMjk4LjI5OCwzMzYuMDUzIDI1MS45MjEsMzM2LjA1MyBaIE0yNTEuOTIxLDEyMi43MTUgQzE4MC40NzQsMTIyLjcxNSAxMjIuNTU2LDE4MC42MzMgMTIyLjU1NiwyNTIuMDggQzEyMi41NTYsMzIzLjUyNiAxODAuNDc0LDM4MS40NDQgMjUxLjkyMSwzODEuNDQ0IEMzMjMuMzY3LDM4MS40NDQgMzgxLjI4NSwzMjMuNTI2IDM4MS4yODUsMjUyLjA4IEMzODEuMjg1LDE4MC42MzMgMzIzLjM2NywxMjIuNzE1IDI1MS45MjEsMTIyLjcxNSBaIiBpZD0iRmlsbC00IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgICAgICA8cGF0aCBkPSJNNDE2LjYyNywxMTcuNjA0IEM0MTYuNjI3LDEzNC4zIDQwMy4wOTIsMTQ3LjgzNCAzODYuMzk2LDE0Ny44MzQgQzM2OS43MDEsMTQ3LjgzNCAzNTYuMTY2LDEzNC4zIDM1Ni4xNjYsMTE3LjYwNCBDMzU2LjE2NiwxMDAuOTA4IDM2OS43MDEsODcuMzczIDM4Ni4zOTYsODcuMzczIEM0MDMuMDkyLDg3LjM3MyA0MTYuNjI3LDEwMC45MDggNDE2LjYyNywxMTcuNjA0IiBpZD0iRmlsbC01IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgIDwvZz48L3N2Zz4=);\n\t\t}\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(302, 100%, 94%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder {\n\t\t/* Use gradient to contrast with focused widget (ckeditor/ckeditor5-media-embed#22). */\n\t\tbackground: linear-gradient( to right, hsl(201, 85%, 70%), hsl(201, 85%, 35%) );\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IldoaXRlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQwMCA0MDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj48c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7ZmlsbDojRkZGRkZGO308L3N0eWxlPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MDAsMjAwYzAsMTEwLjUtODkuNSwyMDAtMjAwLDIwMFMwLDMxMC41LDAsMjAwUzg5LjUsMCwyMDAsMFM0MDAsODkuNSw0MDAsMjAweiBNMTYzLjQsMzA1LjVjODguNywwLDEzNy4yLTczLjUsMTM3LjItMTM3LjJjMC0yLjEsMC00LjItMC4xLTYuMmM5LjQtNi44LDE3LjYtMTUuMywyNC4xLTI1Yy04LjYsMy44LTE3LjksNi40LTI3LjcsNy42YzEwLTYsMTcuNi0xNS40LDIxLjItMjYuN2MtOS4zLDUuNS0xOS42LDkuNS0zMC42LDExLjdjLTguOC05LjQtMjEuMy0xNS4yLTM1LjItMTUuMmMtMjYuNiwwLTQ4LjIsMjEuNi00OC4yLDQ4LjJjMCwzLjgsMC40LDcuNSwxLjMsMTFjLTQwLjEtMi03NS42LTIxLjItOTkuNC01MC40Yy00LjEsNy4xLTYuNSwxNS40LTYuNSwyNC4yYzAsMTYuNyw4LjUsMzEuNSwyMS41LDQwLjFjLTcuOS0wLjItMTUuMy0yLjQtMjEuOC02YzAsMC4yLDAsMC40LDAsMC42YzAsMjMuNCwxNi42LDQyLjgsMzguNyw0Ny4zYy00LDEuMS04LjMsMS43LTEyLjcsMS43Yy0zLjEsMC02LjEtMC4zLTkuMS0wLjljNi4xLDE5LjIsMjMuOSwzMy4xLDQ1LDMzLjVjLTE2LjUsMTIuOS0zNy4zLDIwLjYtNTkuOSwyMC42Yy0zLjksMC03LjctMC4yLTExLjUtMC43QzExMC44LDI5Ny41LDEzNi4yLDMwNS41LDE2My40LDMwNS41Ii8+PC9zdmc+);\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(201, 100%, 86%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 3525: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-media-form{align-items:flex-start;display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-media-form .ck-labeled-field-view{display:inline-block}.ck.ck-media-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAOA,kBAEC,sBAAuB,CADvB,YAAa,CAEb,kBAAmB,CACnB,gBAqBD,CAnBC,yCACC,oBACD,CAEA,4BACC,YACD,CCbA,oCDCD,kBAeE,cAUF,CARE,yCACC,eACD,CAEA,6BACC,cACD,CCtBD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-media-form {\n\tdisplay: flex;\n\talign-items: flex-start;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 7583: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-color-mention-background:rgba(153,0,48,.1);--ck-color-mention-text:#990030}.ck-content .mention{background:var(--ck-color-mention-background);color:var(--ck-color-mention-text)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-mention/mention.css"], names: [], mappings: "AAKA,MACC,+CAAwD,CACxD,+BACD,CAEA,qBACC,6CAA8C,CAC9C,kCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-mention-background: hsla(341, 100%, 30%, 0.1);\n\t--ck-color-mention-text: hsl(341, 100%, 30%);\n}\n\n.ck-content .mention {\n\tbackground: var(--ck-color-mention-background);\n\tcolor: var(--ck-color-mention-text);\n}\n"], sourceRoot: "" }]); const c = a }, 6391: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-mention-list-max-height:300px}.ck.ck-mentions{max-height:var(--ck-mention-list-max-height);overflow-x:hidden;overflow-y:auto;overscroll-behavior:contain}.ck.ck-mentions>.ck-list__item{flex-shrink:0;overflow:hidden}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-mention/theme/mentionui.css"], names: [], mappings: "AAKA,MACC,kCACD,CAEA,gBACC,4CAA6C,CAM7C,iBAAkB,CAJlB,eAAgB,CAMhB,2BAQD,CAJC,+BAEC,aAAc,CADd,eAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-mention-list-max-height: 300px;\n}\n\n.ck.ck-mentions {\n\tmax-height: var(--ck-mention-list-max-height);\n\n\toverflow-y: auto;\n\n\t/* Prevent unnecessary horizontal scrollbar in Safari\n\thttps://github.com/ckeditor/ckeditor5-mention/issues/41 */\n\toverflow-x: hidden;\n\n\toverscroll-behavior: contain;\n\n\t/* Prevent unnecessary vertical scrollbar in Safari\n\thttps://github.com/ckeditor/ckeditor5-mention/issues/41 */\n\t& > .ck-list__item {\n\t\toverflow: hidden;\n\t\tflex-shrink: 0;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 4046: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-character-grid{max-width:100%}.ck.ck-character-grid .ck-character-grid__tiles{display:grid}:root{--ck-character-grid-tile-size:24px}.ck.ck-character-grid{max-height:200px;overflow-x:hidden;overflow-y:auto;width:350px}@media screen and (max-width:600px){.ck.ck-character-grid{width:190px}}.ck.ck-character-grid .ck-character-grid__tiles{grid-gap:var(--ck-spacing-standard);grid-template-columns:repeat(10,1fr);margin:var(--ck-spacing-standard) var(--ck-spacing-large)}@media screen and (max-width:600px){.ck.ck-character-grid .ck-character-grid__tiles{grid-template-columns:repeat(5,1fr)}}.ck.ck-character-grid .ck-character-grid__tile{border:0;font-size:1.2em;height:var(--ck-character-grid-tile-size);min-height:var(--ck-character-grid-tile-size);min-width:var(--ck-character-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-character-grid-tile-size)}.ck.ck-character-grid .ck-character-grid__tile:focus:not(.ck-disabled),.ck.ck-character-grid .ck-character-grid__tile:hover:not(.ck-disabled){border:0;box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-character-grid .ck-character-grid__tile .ck-button__label{line-height:var(--ck-character-grid-tile-size);text-align:center;width:100%}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-special-characters/theme/charactergrid.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/charactergrid.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAKA,sBACC,cAKD,CAHC,gDACC,YACD,CCFD,MACC,kCACD,CAEA,sBAIC,gBAAiB,CAFjB,iBAAkB,CADlB,eAAgB,CAEhB,WAyCD,CClDC,oCDMD,sBAOE,WAqCF,CChDC,CDcA,gDAGC,mCAAoC,CAFpC,oCAAsC,CACtC,yDAMD,CCxBA,oCDgBA,gDAME,mCAEF,CCtBA,CDwBA,+CAQC,QAAS,CAHT,eAAgB,CAHhB,yCAA0C,CAE1C,6CAA8C,CAD9C,4CAA6C,CAG7C,SAAU,CACV,8BAA+B,CAN/B,wCAsBD,CAbC,8IAGC,QAAS,CACT,iGACD,CAGA,iEACC,8CAA+C,CAE/C,iBAAkB,CADlB,UAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-character-grid {\n\tmax-width: 100%;\n\t\n\t& .ck-character-grid__tiles {\n\t\tdisplay: grid;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "../mixins/_rounded.css";\n\n:root {\n\t--ck-character-grid-tile-size: 24px;\n}\n\n.ck.ck-character-grid {\n\toverflow-y: auto;\n\toverflow-x: hidden;\n\twidth: 350px;\n\tmax-height: 200px;\n\n\t@mixin ck-media-phone {\n\t\twidth: 190px;\n\t}\n\n\t& .ck-character-grid__tiles {\n\t\tgrid-template-columns: repeat(10, 1fr);\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\t\tgrid-gap: var(--ck-spacing-standard);\n\n\t\t@mixin ck-media-phone {\n\t\t\tgrid-template-columns: repeat(5, 1fr);\n\t\t}\n\t}\n\n\t& .ck-character-grid__tile {\n\t\twidth: var(--ck-character-grid-tile-size);\n\t\theight: var(--ck-character-grid-tile-size);\n\t\tmin-width: var(--ck-character-grid-tile-size);\n\t\tmin-height: var(--ck-character-grid-tile-size);\n\t\tfont-size: 1.2em;\n\t\tpadding: 0;\n\t\ttransition: .2s ease box-shadow;\n\t\tborder: 0;\n\n\t\t&:focus:not( .ck-disabled ),\n\t\t&:hover:not( .ck-disabled ) {\n\t\t\t/* Disable the default .ck-button\'s border ring. */\n\t\t\tborder: 0;\n\t\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t\t}\n\n\t\t/* Make sure the glyph is rendered in the center of the button */\n\t\t& .ck-button__label {\n\t\t\tline-height: var(--ck-character-grid-tile-size);\n\t\t\twidth: 100%;\n\t\t\ttext-align: center;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 4779: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-character-info{border-top:1px solid var(--ck-color-base-border);display:flex;justify-content:space-between;padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-character-info>*{font-size:var(--ck-font-size-small);text-transform:uppercase}.ck.ck-character-info .ck-character-info__name{max-width:280px;overflow:hidden;text-overflow:ellipsis}.ck.ck-character-info .ck-character-info__code{opacity:.6}@media screen and (max-width:600px){.ck.ck-character-info{max-width:190px}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-special-characters/theme/characterinfo.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/characterinfo.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAKA,sBCIC,gDAAiD,CDHjD,YAAa,CACb,6BAA8B,CCC9B,uDDAD,CCGC,wBAEC,mCAAoC,CADpC,wBAED,CAEA,+CACC,eAAgB,CAEhB,eAAgB,CADhB,sBAED,CAEA,+CACC,UACD,CClBA,oCDCD,sBAoBE,eAEF,CCrBC", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-character-info {\n\tdisplay: flex;\n\tjustify-content: space-between;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-character-info {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\tborder-top: 1px solid var(--ck-color-base-border);\n\n\t& > * {\n\t\ttext-transform: uppercase;\n\t\tfont-size: var(--ck-font-size-small);\n\t}\n\n\t& .ck-character-info__name {\n\t\tmax-width: 280px;\n\t\ttext-overflow: ellipsis;\n\t\toverflow: hidden;\n\t}\n\n\t& .ck-character-info__code {\n\t\topacity: .6;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tmax-width: 190px;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 8170: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-special-characters-navigation>.ck-label{max-width:160px;overflow:hidden;text-overflow:ellipsis}.ck.ck-special-characters-navigation>.ck-dropdown .ck-dropdown__panel{max-height:250px;overflow-x:hidden;overflow-y:auto}@media screen and (max-width:600px){.ck.ck-special-characters-navigation{max-width:190px}.ck.ck-special-characters-navigation>.ck-form__header__label{overflow:hidden;text-overflow:ellipsis}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/specialcharacters.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAUC,+CACC,eAAgB,CAEhB,eAAgB,CADhB,sBAED,CAEA,sEAEC,gBAAiB,CAEjB,iBAAkB,CADlB,eAED,CCfA,oCDED,qCAgBE,eAOF,CALE,6DAEC,eAAgB,CADhB,sBAED,CCrBD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-special-characters-navigation {\n\n\t& > .ck-label {\n\t\tmax-width: 160px;\n\t\ttext-overflow: ellipsis;\n\t\toverflow: hidden;\n\t}\n\n\t& > .ck-dropdown .ck-dropdown__panel {\n\t\t/* There could be dozens of categories available. Use scroll to prevent a 10e6px dropdown. */\n\t\tmax-height: 250px;\n\t\toverflow-y: auto;\n\t\toverflow-x: hidden;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tmax-width: 190px;\n\n\t\t& > .ck-form__header__label {\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 4082: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-input-color{display:flex;flex-direction:row-reverse;width:100%}.ck.ck-input-color>input.ck.ck-input-text{flex-grow:1;min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown{min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown>.ck-input-color__button .ck-dropdown__arrow{display:none}.ck.ck-input-color .ck.ck-input-color__button{display:flex}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview{overflow:hidden;position:relative}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{display:block;position:absolute}[dir=ltr] .ck.ck-input-color>.ck.ck-input-text{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-input-text{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-input-color>.ck.ck-input-text:focus{z-index:0}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{padding:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-left-radius:0;border-top-left-radius:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-left:1px solid transparent}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-right:1px solid transparent}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button.ck-disabled{background:var(--ck-color-input-disabled-background)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border-radius:0}.ck-rounded-corners .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview,.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border:1px solid var(--ck-color-input-border);height:20px;width:20px}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{background:red;border-radius:2px;height:150%;left:50%;top:-30%;transform:rotate(45deg);transform-origin:50%;width:8%}.ck.ck-input-color .ck.ck-input-color__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);width:100%}.ck.ck-input-color .ck.ck-input-color__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-input-border)}[dir=ltr] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-right-radius:0}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-left-radius:0}.ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard);margin-right:0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/colorinput.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/colorinput.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,mBAEC,YAAa,CACb,0BAA2B,CAF3B,UAgCD,CA5BC,0CAEC,WAAY,CADZ,cAED,CAEA,sCACC,cAMD,CAHC,kFACC,YACD,CAGD,8CAEC,YAWD,CATC,kFAEC,eAAgB,CADhB,iBAOD,CAJC,0IAEC,aAAc,CADd,iBAED,CC1BF,+CAGE,4BAA6B,CAD7B,yBAcF,CAhBA,+CAQE,2BAA4B,CAD5B,wBASF,CAHC,2CACC,SACD,CAIA,wEACC,SA0CD,CA3CA,kFAKE,2BAA4B,CAD5B,wBAuCF,CApCE,8FACC,iCACD,CATF,kFAcE,4BAA6B,CAD7B,yBA8BF,CA3BE,8FACC,kCACD,CAGD,oFACC,oDACD,CAEA,4GC1CF,eD2DE,CAjBA,+PCtCD,qCDuDC,CAjBA,4GAKC,6CAA8C,CAD9C,WAAY,CADZ,UAcD,CAVC,oKAKC,cAA6B,CAC7B,iBAAkB,CAHlB,WAAY,CADZ,QAAS,CADT,QAAS,CAMT,uBAAwB,CACxB,oBAAqB,CAJrB,QAKD,CAKH,oDAIC,2BAA4B,CAC5B,4BAA6B,CAH7B,qEAAwE,CADxE,UA0BD,CApBC,gEACC,oDACD,CATD,8DAYE,yBAeF,CA3BA,8DAgBE,wBAWF,CARC,gEACC,uCAMD,CAPA,0EAKE,sCAAuC,CADvC,cAGF", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-input-color {\n\twidth: 100%;\n\tdisplay: flex;\n\tflex-direction: row-reverse;\n\n\t& > input.ck.ck-input-text {\n\t\tmin-width: auto;\n\t\tflex-grow: 1;\n\t}\n\n\t& > div.ck.ck-dropdown {\n\t\tmin-width: auto;\n\n\t\t/* This dropdown has no arrow but a color preview instead. */\n\t\t& > .ck-input-color__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck.ck-input-color__button {\n\t\t/* Resolving issue with misaligned buttons on Safari (see #10589) */\n\t\tdisplay: flex;\n\n\t\t& .ck.ck-input-color__button__preview {\n\t\t\tposition: relative;\n\t\t\toverflow: hidden;\n\n\t\t\t& > .ck.ck-input-color__button__preview__no-color-indicator {\n\t\t\t\tposition: absolute;\n\t\t\t\tdisplay: block;\n\t\t\t}\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_rounded.css";\n\n.ck.ck-input-color {\n\t& > .ck.ck-input-text {\n\t\t@mixin ck-dir ltr {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* Make sure the focused input is always on top of the dropdown button so its\n\t\t   outline and border are never cropped (also when the input is read-only). */\n\t\t&:focus {\n\t\t\tz-index: 0;\n\t\t}\n\t}\n\n\t& > .ck.ck-dropdown {\n\t\t& > .ck.ck-button.ck-input-color__button {\n\t\t\tpadding: 0;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\n\t\t\t\t&:not(:focus) {\n\t\t\t\t\tborder-left: 1px solid transparent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\n\t\t\t\t&:not(:focus) {\n\t\t\t\t\tborder-right: 1px solid transparent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t&.ck-disabled {\n\t\t\t\tbackground: var(--ck-color-input-disabled-background);\n\t\t\t}\n\n\t\t\t& > .ck.ck-input-color__button__preview {\n\t\t\t\t@mixin ck-rounded-corners;\n\n\t\t\t\twidth: 20px;\n\t\t\t\theight: 20px;\n\t\t\t\tborder: 1px solid var(--ck-color-input-border);\n\n\t\t\t\t& > .ck.ck-input-color__button__preview__no-color-indicator {\n\t\t\t\t\ttop: -30%;\n\t\t\t\t\tleft: 50%;\n\t\t\t\t\theight: 150%;\n\t\t\t\t\twidth: 8%;\n\t\t\t\t\tbackground: hsl(0, 100%, 50%);\n\t\t\t\t\tborder-radius: 2px;\n\t\t\t\t\ttransform: rotate(45deg);\n\t\t\t\t\ttransform-origin: 50%;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-input-color__remove-color {\n\t\twidth: 100%;\n\t\tpadding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);\n\n\t\tborder-bottom-left-radius: 0;\n\t\tborder-bottom-right-radius: 0;\n\n\t\t&:not(:focus) {\n\t\t\tborder-bottom: 1px solid var(--ck-color-input-border);\n\t\t}\n\n\t\t@mixin ck-dir ltr {\n\t\t\tborder-top-right-radius: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tborder-top-left-radius: 0;\n\t\t}\n\n\t\t& .ck.ck-icon {\n\t\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: 0;\n\t\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 4880: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-form{padding:0 0 var(--ck-spacing-large)}.ck.ck-form:focus{outline:none}.ck.ck-form .ck.ck-input-text{min-width:100%;width:0}.ck.ck-form .ck.ck-dropdown{min-width:100%}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button .ck-button__label{width:100%}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/form.css"], names: [], mappings: "AAKA,YACC,mCAyBD,CAvBC,kBAEC,YACD,CAEA,8BACC,cAAe,CACf,OACD,CAEA,4BACC,cAWD,CARE,6DACC,4CACD,CAEA,mEACC,UACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form {\n\tpadding: 0 0 var(--ck-spacing-large);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t& .ck.ck-input-text {\n\t\tmin-width: 100%;\n\t\twidth: 0;\n\t}\n\n\t& .ck.ck-dropdown {\n\t\tmin-width: 100%;\n\n\t\t& .ck-dropdown__button {\n\t\t\t&:not(:focus) {\n\t\t\t\tborder: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\n\t\t\t& .ck-button__label {\n\t\t\t\twidth: 100%;\n\t\t\t}\n\t\t}\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 9865: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-table-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-table-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row{padding:var(--ck-spacing-standard) var(--ck-spacing-large) 0}[dir=ltr] .ck.ck-form__row>:not(.ck-label)+*{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-form__row>:not(.ck-label)+*{margin-right:var(--ck-spacing-large)}.ck.ck-form__row>.ck-label{min-width:100%;width:100%}.ck.ck-form__row.ck-table-form__action-row{margin-top:var(--ck-spacing-large)}.ck.ck-form__row.ck-table-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/formrow.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/formrow.css"], names: [], mappings: "AAKA,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAaD,CAVC,iCACC,WACD,CAGC,wHAEC,sBACD,CCbF,iBACC,4DA2BD,CAvBE,6CAEE,mCAMF,CARA,6CAME,oCAEF,CAGD,2BAEC,cAAe,CADf,UAED,CAEA,2CACC,kCAKD,CAHC,wEACC,0BACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__row {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\tjustify-content: space-between;\n\n\t/* Ignore labels that work as fieldset legends */\n\t& > *:not(.ck-label) {\n\t\tflex-grow: 1;\n\t}\n\n\t&.ck-table-form__action-row {\n\t\t& .ck-button-save,\n\t\t& .ck-button-cancel {\n\t\t\tjustify-content: center;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-form__row {\n\tpadding: var(--ck-spacing-standard) var(--ck-spacing-large) 0;\n\n\t/* Ignore labels that work as fieldset legends */\n\t& > *:not(.ck-label) {\n\t\t& + * {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck-label {\n\t\twidth: 100%;\n\t\tmin-width: 100%;\n\t}\n\n\t&.ck-table-form__action-row {\n\t\tmargin-top: var(--ck-spacing-large);\n\n\t\t& .ck-button .ck-button__label {\n\t\t\tcolor: var(--ck-color-text);\n\t\t}\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 8085: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2)}.ck .ck-insert-table-dropdown__label,.ck[dir=rtl] .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{border:1px solid var(--ck-color-base-border);border-radius:1px;margin:var(--ck-insert-table-dropdown-box-margin);min-height:var(--ck-insert-table-dropdown-box-height);min-width:var(--ck-insert-table-dropdown-box-width);outline:none;transition:none}.ck .ck-insert-table-dropdown-grid-box:focus{box-shadow:none}.ck .ck-insert-table-dropdown-grid-box.ck-on{background:var(--ck-color-focus-outer-shadow);border-color:var(--ck-color-focus-border)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/inserttable.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css"], names: [], mappings: "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAGC,yFAA0F,CAD1F,oJAED,CAEA,mFAEC,iBACD,CAEA,uCAIC,4CAA6C,CAC7C,iBAAkB,CAFlB,iDAAkD,CADlD,qDAAsD,CADtD,mDAAoD,CAKpD,YAAa,CACb,eAUD,CARC,6CACC,eACD,CAEA,6CAEC,6CAA8C,CAD9C,yCAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-insert-table-dropdown__grid {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: wrap;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-insert-table-dropdown-padding: 10px;\n\t--ck-insert-table-dropdown-box-height: 11px;\n\t--ck-insert-table-dropdown-box-width: 12px;\n\t--ck-insert-table-dropdown-box-margin: 1px;\n}\n\n.ck .ck-insert-table-dropdown__grid {\n\t/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */\n\twidth: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);\n\tpadding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;\n}\n\n.ck .ck-insert-table-dropdown__label,\n.ck[dir=rtl] .ck-insert-table-dropdown__label {\n\ttext-align: center;\n}\n\n.ck .ck-insert-table-dropdown-grid-box {\n\tmin-width: var(--ck-insert-table-dropdown-box-width);\n\tmin-height: var(--ck-insert-table-dropdown-box-height);\n\tmargin: var(--ck-insert-table-dropdown-box-margin);\n\tborder: 1px solid var(--ck-color-base-border);\n\tborder-radius: 1px;\n\toutline: none;\n\ttransition: none;\n\n\t&:focus {\n\t\tbox-shadow: none;\n\t}\n\n\t&.ck-on {\n\t\tborder-color: var(--ck-color-focus-border);\n\t\tbackground: var(--ck-color-focus-outer-shadow);\n\t}\n}\n\n"], sourceRoot: "" }]); const c = a }, 4104: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-content .table{display:table;margin:.9em auto}.ck-content .table table{border:1px double #b3b3b3;border-collapse:collapse;border-spacing:0;height:100%;width:100%}.ck-content .table table td,.ck-content .table table th{border:1px solid #bfbfbf;min-width:2em;padding:.4em}.ck-content .table table th{background:rgba(0,0,0,.05);font-weight:700}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/table.css"], names: [], mappings: "AAKA,mBAKC,aAAc,CADd,gBAiCD,CA9BC,yBAYC,yBAAkC,CAVlC,wBAAyB,CACzB,gBAAiB,CAKjB,WAAY,CADZ,UAsBD,CAfC,wDAQC,wBAAiC,CANjC,aAAc,CACd,YAMD,CAEA,4BAEC,0BAA+B,CAD/B,eAED,CAMF,+BACC,gBACD,CAEA,+BACC,eACD,CAEA,+CAKC,oBAAqB,CAMrB,UACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .table {\n\t/* Give the table widget some air and center it horizontally */\n\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\tmargin: 0.9em auto;\n\tdisplay: table;\n\n\t& table {\n\t\t/* The table cells should have slight borders */\n\t\tborder-collapse: collapse;\n\t\tborder-spacing: 0;\n\n\t\t/* Table width and height are set on the parent <figure>. Make sure the table inside stretches\n\t\tto the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */\n\t\twidth: 100%;\n\t\theight: 100%;\n\n\t\t/* The outer border of the table should be slightly darker than the inner lines.\n\t\tAlso see https://github.com/ckeditor/ckeditor5-table/issues/50. */\n\t\tborder: 1px double hsl(0, 0%, 70%);\n\n\t\t& td,\n\t\t& th {\n\t\t\tmin-width: 2em;\n\t\t\tpadding: .4em;\n\n\t\t\t/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it\'s not necessary here.\n\t\t\tHowever, the border is a content style, so it should use .ck-content (so it works outside the editor).\n\t\t\tHence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */\n\t\t\tborder: 1px solid hsl(0, 0%, 75%);\n\t\t}\n\n\t\t& th {\n\t\t\tfont-weight: bold;\n\t\t\tbackground: hsla(0, 0%, 0%, 5%);\n\t\t}\n\t}\n}\n\n/* Text alignment of the table header should match the editor settings and override the native browser styling,\nwhen content is available outside the editor. See https://github.com/ckeditor/ckeditor5/issues/6638 */\n.ck-content[dir="rtl"] .table th {\n\ttext-align: right;\n}\n\n.ck-content[dir="ltr"] .table th {\n\ttext-align: left;\n}\n\n.ck-editor__editable .ck-table-bogus-paragraph {\n\t/*\n\t * Use display:inline-block to force Chrome/Safari to limit text mutations to this element.\n\t * See https://github.com/ckeditor/ckeditor5/issues/6062.\n\t */\n\tdisplay: inline-block;\n\n\t/*\n\t * Inline HTML elements nested in the span should always be dimensioned in relation to the whole cell width.\n\t * See https://github.com/ckeditor/ckeditor5/issues/9117.\n\t */\n\twidth: 100%;\n}\n'], sourceRoot: "" }]); const c = a }, 9888: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-color-table-caption-background:#f7f7f7;--ck-color-table-caption-text:#333;--ck-color-table-caption-highlighted-background:#fd0}.ck-content .table>figcaption{background-color:var(--ck-color-table-caption-background);caption-side:top;color:var(--ck-color-table-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;text-align:center;word-break:break-word}.ck.ck-editor__editable .table>figcaption.table__caption_highlighted{animation:ck-table-caption-highlight .6s ease-out}.ck.ck-editor__editable .table>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}@keyframes ck-table-caption-highlight{0%{background-color:var(--ck-color-table-caption-highlighted-background)}to{background-color:var(--ck-color-table-caption-background)}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tablecaption.css"], names: [], mappings: "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,oDACD,CAGA,8BAMC,yDAA0D,CAJ1D,gBAAiB,CAGjB,wCAAyC,CAJzC,qBAAsB,CAOtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,iBAAkB,CADlB,qBAOD,CAIC,qEACC,iDACD,CAEA,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAGD,sCACC,GACC,qEACD,CAEA,GACC,yDACD,CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-table-caption-background: hsl(0, 0%, 97%);\n\t--ck-color-table-caption-text: hsl(0, 0%, 20%);\n\t--ck-color-table-caption-highlighted-background: hsl(52deg 100% 50%);\n}\n\n/* Content styles */\n.ck-content .table > figcaption {\n\tdisplay: table-caption;\n\tcaption-side: top;\n\tword-break: break-word;\n\ttext-align: center;\n\tcolor: var(--ck-color-table-caption-text);\n\tbackground-color: var(--ck-color-table-caption-background);\n\tpadding: .6em;\n\tfont-size: .75em;\n\toutline-offset: -1px;\n}\n\n/* Editing styles */\n.ck.ck-editor__editable .table > figcaption {\n\t&.table__caption_highlighted {\n\t\tanimation: ck-table-caption-highlight .6s ease-out;\n\t}\n\n\t&.ck-placeholder::before {\n\t\tpadding-left: inherit;\n\t\tpadding-right: inherit;\n\n\t\t/*\n\t\t * Make sure the table caption placeholder doesn't overflow the placeholder area.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9162.\n\t\t */\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t}\n}\n\n@keyframes ck-table-caption-highlight {\n\t0% {\n\t\tbackground-color: var(--ck-color-table-caption-highlighted-background);\n\t}\n\n\t100% {\n\t\tbackground-color: var(--ck-color-table-caption-background);\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 5737: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row{flex-wrap:wrap}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:first-of-type{flex-grow:0.57}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:last-of-type{flex-grow:0.43}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar .ck-button{flex-grow:1}.ck.ck-table-cell-properties-form{width:320px}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__padding-row{align-self:flex-end;padding:0;width:25%}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tablecellproperties.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tablecellproperties.css"], names: [], mappings: "AAOE,6FACC,cAiBD,CAdE,0HAEC,cACD,CAEA,yHAEC,cACD,CAEA,uHACC,WACD,CClBJ,kCACC,WAkBD,CAfE,2FACC,mBAAoB,CACpB,SAAU,CACV,SACD,CAGC,4GACC,eAAgB,CAGhB,qCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-cell-properties-form {\n\t& .ck-form__row {\n\t\t&.ck-table-cell-properties-form__alignment-row {\n\t\t\tflex-wrap: wrap;\n\n\t\t\t& .ck.ck-toolbar {\n\t\t\t\t&:first-of-type {\n\t\t\t\t\t/* 4 buttons out of 7 (h-alignment + v-alignment) = 0.57 */\n\t\t\t\t\tflex-grow: 0.57;\n\t\t\t\t}\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\t/* 3 buttons out of 7 (h-alignment + v-alignment) = 0.43 */\n\t\t\t\t\tflex-grow: 0.43;\n\t\t\t\t}\n\n\t\t\t\t& .ck-button {\n\t\t\t\t\tflex-grow: 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-cell-properties-form {\n\twidth: 320px;\n\n\t& .ck-form__row {\n\t\t&.ck-table-cell-properties-form__padding-row {\n\t\t\talign-self: flex-end;\n\t\t\tpadding: 0;\n\t\t\twidth: 25%;\n\t\t}\n\n\t\t&.ck-table-cell-properties-form__alignment-row {\n\t\t\t& .ck.ck-toolbar {\n\t\t\t\tbackground: none;\n\n\t\t\t\t/* Compensate for missing input label that would push the margin (toolbar has no inputs). */\n\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 728: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-color-table-column-resizer-hover:var(--ck-color-base-active);--ck-table-column-resizer-width:7px;--ck-table-column-resizer-position-offset:calc(var(--ck-table-column-resizer-width)*-0.5 - 0.5px)}.ck-content .table .ck-table-resized{table-layout:fixed}.ck-content .table table{overflow:hidden}.ck-content .table td,.ck-content .table th{position:relative}.ck.ck-editor__editable .table .ck-table-column-resizer{bottom:-999999px;cursor:col-resize;position:absolute;right:var(--ck-table-column-resizer-position-offset);top:-999999px;user-select:none;width:var(--ck-table-column-resizer-width);z-index:var(--ck-z-default)}.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer,.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer{display:none}.ck.ck-editor__editable .table .ck-table-column-resizer:hover,.ck.ck-editor__editable .table .ck-table-column-resizer__active{background-color:var(--ck-color-table-column-resizer-hover);opacity:.25}.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer{left:var(--ck-table-column-resizer-position-offset);right:unset}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tablecolumnresize.css"], names: [], mappings: "AAKA,MACC,iEAAkE,CAClE,mCAAoC,CAIpC,iGACD,CAEA,qCACC,kBACD,CAEA,yBACC,eACD,CAEA,4CAEC,iBACD,CAEA,wDAOC,gBAAiB,CAGjB,iBAAkB,CATlB,iBAAkB,CAOlB,oDAAqD,CAFrD,aAAc,CAKd,gBAAiB,CAFjB,0CAA2C,CAG3C,2BACD,CAQA,qJACC,YACD,CAEA,8HAEC,2DAA4D,CAC5D,WACD,CAEA,iEACC,mDAAoD,CACpD,WACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-table-column-resizer-hover: var(--ck-color-base-active);\n\t--ck-table-column-resizer-width: 7px;\n\n\t/* The offset used for absolute positioning of the resizer element, so that it is placed exactly above the cell border.\n\t   The value is: minus half the width of the resizer decreased additionaly by the half the width of the border (0.5px). */\n\t--ck-table-column-resizer-position-offset: calc(var(--ck-table-column-resizer-width) * -0.5 - 0.5px);\n}\n\n.ck-content .table .ck-table-resized {\n\ttable-layout: fixed;\n}\n\n.ck-content .table table {\n\toverflow: hidden;\n}\n\n.ck-content .table td,\n.ck-content .table th {\n\tposition: relative;\n}\n\n.ck.ck-editor__editable .table .ck-table-column-resizer {\n\tposition: absolute;\n\t/* The resizer element resides in each cell so to occupy the entire height of the table, which is unknown from a CSS point of view,\n\t   it is extended to an extremely high height. Even for screens with a very high pixel density, the resizer will fulfill its role as\n\t   it should, i.e. for a screen of 476 ppi the total height of the resizer will take over 350 sheets of A4 format, which is totally\n\t   unrealistic height for a single table. */\n\ttop: -999999px;\n\tbottom: -999999px;\n\tright: var(--ck-table-column-resizer-position-offset);\n\twidth: var(--ck-table-column-resizer-width);\n\tcursor: col-resize;\n\tuser-select: none;\n\tz-index: var(--ck-z-default);\n}\n\n.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer {\n\tdisplay: none;\n}\n\n/* The resizer elements, which are extended to an extremely high height, break the drag & drop feature in Chrome. To make it work again,\n   all resizers must be hidden while the table is dragged. */\n.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer {\n\tdisplay: none;\n}\n\n.ck.ck-editor__editable .table .ck-table-column-resizer:hover,\n.ck.ck-editor__editable .table .ck-table-column-resizer__active {\n\tbackground-color: var(--ck-color-table-column-resizer-hover);\n\topacity: 0.25;\n}\n\n.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer {\n\tleft: var(--ck-table-column-resizer-position-offset);\n\tright: unset;\n}\n"], sourceRoot: "" }]); const c = a }, 4777: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-color-table-focused-cell-background:rgba(158,201,250,.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css"], names: [], mappings: "AAKA,MACC,6DACD,CAKE,8QAGC,wDAAyD,CAKzD,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-table-focused-cell-background: hsla(212, 90%, 80%, .3);\n}\n\n.ck-widget.table {\n\t& td,\n\t& th {\n\t\t&.ck-editor__nested-editable.ck-editor__nested-editable_focused,\n\t\t&.ck-editor__nested-editable:focus {\n\t\t\t/* A very slight background to highlight the focused cell */\n\t\t\tbackground: var(--ck-color-table-focused-cell-background);\n\n\t\t\t/* Fixes the problem where surrounding cells cover the focused cell's border.\n\t\t\tIt does not fix the problem in all places but the UX is improved.\n\t\t\tSee https://github.com/ckeditor/ckeditor5-table/issues/29. */\n\t\t\tborder-style: none;\n\t\t\toutline: 1px solid var(--ck-color-focus-border);\n\t\t\toutline-offset: -1px; /* progressive enhancement - no IE support */\n\t\t}\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 198: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, '.ck.ck-table-form .ck-form__row.ck-table-form__background-row,.ck.ck-table-form .ck-form__row.ck-table-form__border-row{flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{align-items:center;flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view{align-items:center;display:flex;flex-direction:column-reverse}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{flex-grow:0}.ck.ck-table-form .ck.ck-labeled-field-view{position:relative}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{bottom:calc(var(--ck-table-properties-error-arrow-size)*-1);left:50%;position:absolute;transform:translate(-50%,100%);z-index:1}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{content:"";left:50%;position:absolute;top:calc(var(--ck-table-properties-error-arrow-size)*-1);transform:translateX(-50%)}:root{--ck-table-properties-error-arrow-size:6px;--ck-table-properties-min-error-width:150px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view>.ck-label{font-size:var(--ck-font-size-tiny);text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{max-width:80px;min-width:80px;width:80px}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{padding:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__height,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__width{margin:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{align-self:flex-end;display:inline-block;height:var(--ck-ui-component-min-height);line-height:var(--ck-ui-component-min-height);margin:0 var(--ck-spacing-small)}.ck.ck-table-form .ck.ck-labeled-field-view{padding-top:var(--ck-spacing-standard)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{border-radius:0}.ck-rounded-corners .ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status,.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{background:var(--ck-color-base-error);color:var(--ck-color-base-background);min-width:var(--ck-table-properties-min-error-width);padding:var(--ck-spacing-small) var(--ck-spacing-medium);text-align:center}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{border-color:transparent transparent var(--ck-color-base-error) transparent;border-style:solid;border-width:0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:ck-table-form-labeled-view-status-appear .15s ease both}.ck.ck-table-form .ck.ck-labeled-field-view .ck-input.ck-error:not(:focus)+.ck.ck-labeled-field-view__status{display:none}@keyframes ck-table-form-labeled-view-status-appear{0%{opacity:0}to{opacity:1}}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tableform.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableform.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAWE,wHACC,cACD,CAEA,8DAEC,kBAAmB,CADnB,cAgBD,CAbC,qFAGC,kBAAmB,CAFnB,YAAa,CACb,6BAMD,CAEA,sMACC,WACD,CAIF,4CAEC,iBAoBD,CAlBC,8EAGC,2DAAgE,CADhE,QAAS,CADT,iBAAkB,CAGlB,8BAA+B,CAG/B,SAUD,CAPC,oFACC,UAAW,CAGX,QAAS,CAFT,iBAAkB,CAClB,wDAA6D,CAE7D,0BACD,CChDH,MACC,0CAA2C,CAC3C,2CACD,CAMI,2FACC,kCAAmC,CACnC,iBACD,CAGD,8KAIC,cAAe,CADf,cAAe,CADf,UAGD,CAGD,8DACC,SAcD,CAZC,yMAEC,QACD,CAEA,iGACC,mBAAoB,CACpB,oBAAqB,CACrB,wCAAyC,CACzC,6CAA8C,CAC9C,gCACD,CAIF,4CACC,sCAyBD,CAvBC,8ECxCD,eDyDC,CAjBA,mMCpCA,qCDqDA,CAjBA,8EAGC,qCAAsC,CACtC,qCAAsC,CAEtC,oDAAqD,CADrD,wDAAyD,CAEzD,iBAUD,CAPC,oFACC,2EAA4E,CAE5E,kBAAmB,CADnB,kJAED,CAdD,8EAgBC,iEACD,CAGA,6GACC,YACD,CAIF,oDACC,GACC,SACD,CAEA,GACC,SACD,CACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-form {\n\t& .ck-form__row {\n\t\t&.ck-table-form__border-row {\n\t\t\tflex-wrap: wrap;\n\t\t}\n\n\t\t&.ck-table-form__background-row {\n\t\t\tflex-wrap: wrap;\n\t\t}\n\n\t\t&.ck-table-form__dimensions-row {\n\t\t\tflex-wrap: wrap;\n\t\t\talign-items: center;\n\n\t\t\t& .ck-labeled-field-view {\n\t\t\t\tdisplay: flex;\n\t\t\t\tflex-direction: column-reverse;\n\t\t\t\talign-items: center;\n\n\t\t\t\t& .ck.ck-dropdown {\n\t\t\t\t\tflex-grow: 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& .ck-table-form__dimension-operator {\n\t\t\t\tflex-grow: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-labeled-field-view {\n\t\t/* Allow absolute positioning of the status (error) balloons. */\n\t\tposition: relative;\n\n\t\t& .ck.ck-labeled-field-view__status {\n\t\t\tposition: absolute;\n\t\t\tleft: 50%;\n\t\t\tbottom: calc( -1 * var(--ck-table-properties-error-arrow-size) );\n\t\t\ttransform: translate(-50%,100%);\n\n\t\t\t/* Make sure the balloon status stays on top of other form elements. */\n\t\t\tz-index: 1;\n\n\t\t\t/* The arrow pointing towards the field. */\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: calc( -1 * var(--ck-table-properties-error-arrow-size) );\n\t\t\t\tleft: 50%;\n\t\t\t\ttransform: translateX( -50% );\n\t\t\t}\n\t\t}\n\t}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n:root {\n\t--ck-table-properties-error-arrow-size: 6px;\n\t--ck-table-properties-min-error-width: 150px;\n}\n\n.ck.ck-table-form {\n\t& .ck-form__row {\n\t\t&.ck-table-form__border-row {\n\t\t\t& .ck-labeled-field-view {\n\t\t\t\t& > .ck-label {\n\t\t\t\t\tfont-size: var(--ck-font-size-tiny);\n\t\t\t\t\ttext-align: center;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& .ck-table-form__border-style,\n\t\t\t& .ck-table-form__border-width {\n\t\t\t\twidth: 80px;\n\t\t\t\tmin-width: 80px;\n\t\t\t\tmax-width: 80px;\n\t\t\t}\n\t\t}\n\n\t\t&.ck-table-form__dimensions-row {\n\t\t\tpadding: 0;\n\n\t\t\t& .ck-table-form__dimensions-row__width,\n\t\t\t& .ck-table-form__dimensions-row__height {\n\t\t\t\tmargin: 0\n\t\t\t}\n\n\t\t\t& .ck-table-form__dimension-operator {\n\t\t\t\talign-self: flex-end;\n\t\t\t\tdisplay: inline-block;\n\t\t\t\theight: var(--ck-ui-component-min-height);\n\t\t\t\tline-height: var(--ck-ui-component-min-height);\n\t\t\t\tmargin: 0 var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-labeled-field-view {\n\t\tpadding-top: var(--ck-spacing-standard);\n\n\t\t& .ck.ck-labeled-field-view__status {\n\t\t\t@mixin ck-rounded-corners;\n\n\t\t\tbackground: var(--ck-color-base-error);\n\t\t\tcolor: var(--ck-color-base-background);\n\t\t\tpadding: var(--ck-spacing-small) var(--ck-spacing-medium);\n\t\t\tmin-width: var(--ck-table-properties-min-error-width);\n\t\t\ttext-align: center;\n\n\t\t\t/* The arrow pointing towards the field. */\n\t\t\t&::after {\n\t\t\t\tborder-color: transparent transparent var(--ck-color-base-error) transparent;\n\t\t\t\tborder-width: 0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size);\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\n\t\t\tanimation: ck-table-form-labeled-view-status-appear .15s ease both;\n\t\t}\n\n\t\t/* Hide the error balloon when the field is blurred. Makes the experience much more clear. */\n\t\t& .ck-input.ck-error:not(:focus) + .ck.ck-labeled-field-view__status {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n@keyframes ck-table-form-labeled-view-status-appear {\n\t0% {\n\t\topacity: 0;\n\t}\n\n\t100% {\n\t\topacity: 1;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 9221: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-content:baseline;flex-basis:0;flex-wrap:wrap}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items{flex-wrap:nowrap}.ck.ck-table-properties-form{width:320px}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-self:flex-end;padding:0}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items>*{width:40px}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tableproperties.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableproperties.css"], names: [], mappings: "AAOE,mFAGC,sBAAuB,CADvB,YAAa,CADb,cAOD,CAHC,qHACC,gBACD,CCTH,6BACC,WAmBD,CAhBE,mFACC,mBAAoB,CACpB,SAYD,CAVC,kGACC,eAAgB,CAGhB,qCAKD,CAHC,uHACC,UACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-properties-form {\n\t& .ck-form__row {\n\t\t&.ck-table-properties-form__alignment-row {\n\t\t\tflex-wrap: wrap;\n\t\t\tflex-basis: 0;\n\t\t\talign-content: baseline;\n\n\t\t\t& .ck.ck-toolbar .ck-toolbar__items {\n\t\t\t\tflex-wrap: nowrap;\n\t\t\t}\n\t\t}\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-properties-form {\n\twidth: 320px;\n\n\t& .ck-form__row {\n\t\t&.ck-table-properties-form__alignment-row {\n\t\t\talign-self: flex-end;\n\t\t\tpadding: 0;\n\n\t\t\t& .ck.ck-toolbar {\n\t\t\t\tbackground: none;\n\n\t\t\t\t/* Compensate for missing input label that would push the margin (toolbar has no inputs). */\n\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\n\t\t\t\t& .ck-toolbar__items > * {\n\t\t\t\t\twidth: 40px;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 5593: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ':root{--ck-table-selected-cell-background:rgba(158,207,250,.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{box-shadow:unset;caret-color:transparent;outline:unset;position:relative}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{background-color:var(--ck-table-selected-cell-background);bottom:0;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget{outline:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle{display:none}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css"], names: [], mappings: "AAKA,MACC,wDACD,CAGC,0IAKC,gBAAiB,CAFjB,uBAAwB,CACxB,aAAc,CAFd,iBAiCD,CA3BC,sJAGC,yDAA0D,CAK1D,QAAS,CAPT,UAAW,CAKX,MAAO,CAJP,mBAAoB,CAEpB,iBAAkB,CAGlB,OAAQ,CAFR,KAID,CAEA,wTAEC,4BACD,CAMA,gKACC,aAKD,CAHC,0NACC,YACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);\n}\n\n.ck.ck-editor__editable .table table {\n\t& td.ck-editor__editable_selected,\n\t& th.ck-editor__editable_selected {\n\t\tposition: relative;\n\t\tcaret-color: transparent;\n\t\toutline: unset;\n\t\tbox-shadow: unset;\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/6446 */\n\t\t&:after {\n\t\t\tcontent: '';\n\t\t\tpointer-events: none;\n\t\t\tbackground-color: var(--ck-table-selected-cell-background);\n\t\t\tposition: absolute;\n\t\t\ttop: 0;\n\t\t\tleft: 0;\n\t\t\tright: 0;\n\t\t\tbottom: 0;\n\t\t}\n\n\t\t& ::selection,\n\t\t&:focus {\n\t\t\tbackground-color: transparent;\n\t\t}\n\n\t\t/*\n\t\t * To reduce the amount of noise, all widgets in the table selection have no outline and no selection handle.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9491.\n\t\t */\n\t\t& .ck-widget {\n\t\t\toutline: unset;\n\n\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 4499: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;justify-content:left;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css"], names: [], mappings: "AAOA,6BAMC,kBAAmB,CADnB,mBAAoB,CAEpB,oBAAqB,CAHrB,iBAAkB,CCFlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDkBD,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEjBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-unselectable;\n\n\tposition: relative;\n\tdisplay: inline-flex;\n\talign-items: center;\n\tjustify-content: left;\n\n\t& .ck-button__label {\n\t\tdisplay: none;\n\t}\n\n\t&.ck-button_with-text {\n\t\t& .ck-button__label {\n\t\t\tdisplay: inline-block;\n\t\t}\n\t}\n\n\t/* Center the icon horizontally in a button without text. */\n\t&:not(.ck-button_with-text)  {\n\t\tjustify-content: center;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../mixins/_button.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-button-colors --ck-color-button-default;\n\t@mixin ck-rounded-corners;\n\n\twhite-space: nowrap;\n\tcursor: default;\n\tvertical-align: middle;\n\tpadding: var(--ck-spacing-tiny);\n\ttext-align: center;\n\n\t/* A very important piece of styling. Go to variable declaration to learn more. */\n\tmin-width: var(--ck-ui-component-min-height);\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Normalize the height of the line. Removing this will break consistent height\n\tamong text and text-less buttons (with icons). */\n\tline-height: 1;\n\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t/* Avoid flickering when the foucs border shows up. */\n\tborder: 1px solid transparent;\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\n\t-webkit-appearance: none;\n\n\t&:active,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t/* Allow icon coloring using the text "color" property. */\n\t& .ck-button__icon {\n\t\t& use,\n\t\t& use * {\n\t\t\tcolor: inherit;\n\t\t}\n\t}\n\n\t& .ck-button__label {\n\t\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\t\tfont-size: inherit;\n\t\tfont-weight: inherit;\n\t\tcolor: inherit;\n\t\tcursor: inherit;\n\n\t\t/* Must be consistent with .ck-icon\'s vertical align. Otherwise, buttons with and\n\t\twithout labels (but with icons) have different sizes in Chrome */\n\t\tvertical-align: middle;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\t}\n\n\t& .ck-button__keystroke {\n\t\tcolor: inherit;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t}\n\n\t\tfont-weight: bold;\n\t\topacity: .7;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t&.ck-disabled {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t/* The disabled button should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t\t& .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t& .ck-button__keystroke {\n\t\t\topacity: .3;\n\t\t}\n\t}\n\n\t&.ck-button_with-text {\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-button_with-keystroke {\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__label {\n\t\t\tflex-grow: 1;\n\t\t}\n\t}\n\n\t/* A style of the button which is currently on, e.g. its feature is active. */\n\t&.ck-on {\n\t\t@mixin ck-button-colors --ck-color-button-on;\n\n\t\tcolor: var(--ck-color-button-on-color);\n\t}\n\n\t&.ck-button-save {\n\t\tcolor: var(--ck-color-button-save);\n\t}\n\n\t&.ck-button-cancel {\n\t\tcolor: var(--ck-color-button-cancel);\n\t}\n}\n\n/* A style of the button which handles the primary action. */\n.ck.ck-button-action,\na.ck.ck-button-action {\n\t@mixin ck-button-colors --ck-color-button-action;\n\n\tcolor: var(--ck-color-button-action-text);\n}\n\n.ck.ck-button-bold,\na.ck.ck-button-bold {\n\tfont-weight: bold;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n\tbackground: var($(prefix)-background);\n\n\t&:not(.ck-disabled) {\n\t\t&:hover {\n\t\t\tbackground: var($(prefix)-hover-background);\n\t\t}\n\n\t\t&:active {\n\t\t\tbackground: var($(prefix)-active-background);\n\t\t}\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t&.ck-disabled {\n\t\tbackground: var($(prefix)-disabled-background);\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n"], sourceRoot: "" }]); const c = a }, 9681: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css"], names: [], mappings: "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__toggle {\n\t\tdisplay: block;\n\n\t\t& .ck-button__toggle__inner {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floating–point numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n\t/* 34px at 13px font-size */\n\t--ck-switch-button-toggle-width: 2.6153846154em;\n\t/* 14px at 13px font-size */\n\t--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);\n\t--ck-switch-button-translation: calc(\n\t\tvar(--ck-switch-button-toggle-width) -\n\t\tvar(--ck-switch-button-toggle-inner-size) -\n\t\t2px /* Border */\n\t);\n\t--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n}\n\n.ck.ck-button.ck-switchbutton {\n\t/* Unlike a regular button, the switch button text color and background should never change.\n\t * Changing toggle switch (background, outline) is enough to carry the information about the\n\t * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)\n\t */\n\t&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {\n\t\tcolor: inherit;\n\t\tbackground: transparent;\n\t}\n\n\t& .ck-button__label {\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-right: calc(2 * var(--ck-spacing-large));\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-left: calc(2 * var(--ck-spacing-large));\n\t\t}\n\t}\n\n\t& .ck-button__toggle {\n\t\t@mixin ck-rounded-corners;\n\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Make sure the toggle is always to the right as far as possible. */\n\t\t\tmargin-left: auto;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Make sure the toggle is always to the left as far as possible. */\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Apply some smooth transition to the box-shadow and border. */\n\t\t/* Gently animate the background color of the toggle switch */\n\t\ttransition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;\n\t\tborder: 1px solid transparent;\n\t\twidth: var(--ck-switch-button-toggle-width);\n\t\tbackground: var(--ck-color-switch-button-off-background);\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: calc(.5 * var(--ck-border-radius));\n\t\t\t}\n\n\t\t\twidth: var(--ck-switch-button-toggle-inner-size);\n\t\t\theight: var(--ck-switch-button-toggle-inner-size);\n\t\t\tbackground: var(--ck-color-switch-button-inner-background);\n\n\t\t\t/* Gently animate the inner part of the toggle switch */\n\t\t\ttransition: all 300ms ease;\n\t\t}\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-off-hover-background);\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\tbox-shadow: var(--ck-switch-button-inner-hover-shadow);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-button__toggle {\n\t\t@mixin ck-disabled;\n\t}\n\n\t/* Overriding default .ck-button:focus styles + an outline around the toogle */\n\t&:focus {\n\t\tborder-color: transparent;\n\t\toutline: none;\n\t\tbox-shadow: none;\n\n\t\t& .ck-button__toggle {\n\t\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);\n\t\t\toutline-offset: 1px;\n\t\t\toutline: var(--ck-focus-ring);\n\t\t}\n\t}\n\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-on {\n\t\t& .ck-button__toggle {\n\t\t\tbackground: var(--ck-color-switch-button-on-background);\n\n\t\t\t&:hover {\n\t\t\t\tbackground: var(--ck-color-switch-button-on-hover-background);\n\t\t\t}\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\t/*\n\t\t\t\t* Move the toggle switch to the right. It will be animated.\n\t\t\t\t*/\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\ttransform: translateX( var( --ck-switch-button-translation ) );\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n"], sourceRoot: "" }]); const c = a }, 4923: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css"], names: [], mappings: "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n\tdisplay: grid;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-grid-tile-size: 24px;\n\n\t/* Not using global colors here because these may change but some colors in a pallette\n\t * require special treatment. For instance, this ensures no matter what the UI text color is,\n\t * the check icon will look good on the black color tile. */\n\t--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);\n}\n\n.ck.ck-color-grid {\n\tgrid-gap: 5px;\n\tpadding: 8px;\n}\n\n.ck.ck-color-grid__tile {\n\twidth: var(--ck-color-grid-tile-size);\n\theight: var(--ck-color-grid-tile-size);\n\tmin-width: var(--ck-color-grid-tile-size);\n\tmin-height: var(--ck-color-grid-tile-size);\n\tpadding: 0;\n\ttransition: .2s ease box-shadow;\n\tborder: 0;\n\n\t&.ck-disabled {\n\t\tcursor: unset;\n\t\ttransition: unset;\n\t}\n\n\t&.ck-color-table__color-tile_bordered {\n\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\tdisplay: none;\n\t\tcolor: var(--ck-color-color-grid-check-icon);\n\t}\n\n\t&.ck-on {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);\n\n\t\t& .ck.ck-icon {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t&.ck-on,\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\t/* Disable the default .ck-button\'s border ring. */\n\t\tborder: 0;\n\t}\n\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t}\n}\n\n.ck.ck-color-grid__label {\n\tpadding: 0 var(--ck-spacing-standard);\n}\n'], sourceRoot: "" }]); const c = a }, 3488: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eH8GD,CA5BA,qFG9EE,qCH0GF,CA5BA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-dropdown-max-width: 75vw;\n}\n\n.ck.ck-dropdown {\n\tdisplay: inline-block;\n\tposition: relative;\n\n\t& .ck-dropdown__arrow {\n\t\tpointer-events: none;\n\t\tz-index: var(--ck-z-default);\n\t}\n\n\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n\t& .ck-button.ck-dropdown__button {\n\t\twidth: 100%;\n\t}\n\n\t& .ck-dropdown__panel {\n\t\tdisplay: none;\n\t\tz-index: var(--ck-z-modal);\n\t\tmax-width: var(--ck-dropdown-max-width);\n\n\t\tposition: absolute;\n\n\t\t&.ck-dropdown__panel-visible {\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_n,\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_nme {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-dropdown__panel_se,\n\t\t&.ck-dropdown__panel_sw,\n\t\t&.ck-dropdown__panel_smw,\n\t\t&.ck-dropdown__panel_sme,\n\t\t&.ck-dropdown__panel_s {\n\t\t\t/*\n\t\t\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n\t\t\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\n\t\t\t */\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_se {\n\t\t\tleft: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\tright: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_s,\n\t\t&.ck-dropdown__panel_n {\n\t\t\t/* Positioning panels relative to the center of the button */\n\t\t\tleft: 50%;\n\t\t\ttransform: translateX(-50%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_smw {\n\t\t\t/* Positioning panels relative to the middle-west of the button */\n\t\t\tleft: 75%;\n\t\t\ttransform: translateX(-75%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nme,\n\t\t&.ck-dropdown__panel_sme {\n\t\t\t/* Positioning panels relative to the middle-east of the button */\n\t\t\tleft: 25%;\n\t\t\ttransform: translateX(-25%);\n\t\t}\n\t}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n\tz-index: calc( var(--ck-z-modal) + 1 );\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-dropdown {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-dropdown__arrow {\n\t\twidth: var(--ck-dropdown-arrow-size);\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-dropdown__arrow {\n\t\t\tright: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-dropdown__arrow {\n\t\t\tleft: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-dropdown__arrow {\n\t\t@mixin ck-disabled;\n\t}\n\n\t& .ck-button.ck-dropdown__button {\n\t\t@mixin ck-dir ltr {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-right: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t/* #23 */\n\t\t& .ck-button__label {\n\t\t\twidth: 7em;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t\t&.ck-disabled .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\n\t\t&.ck-on {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t&.ck-dropdown__button_label-width_auto .ck-button__label {\n\t\t\twidth: auto;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/8699 */\n\t\t&.ck-off:active,\n\t\t&.ck-on:active {\n\t\t\tbox-shadow: none;\n\t\t\t\n\t\t\t&:focus {\n\t\t\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-dropdown__panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tbackground: var(--ck-color-dropdown-panel-background);\n\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\tbottom: 0;\n\n\t/* Make sure the panel is at least as wide as the drop-down\'s button. */\n\tmin-width: 100%;\n\n\t/* Disabled corner border radius to be consistent with the .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-dropdown__panel_se {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_sw {\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_ne {\n\t\tborder-bottom-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_nw {\n\t\tborder-bottom-right-radius: 0;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 6875: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n\t/* Disabled radius of top-left border to be consistent with .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t/* Make sure the button belonging to the first/last child of the list goes well with the\n\tborder radius of the entire panel. */\n\t& .ck-list__item {\n\t\t&:first-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\n\t\t&:last-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 66: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-splitbutton {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-splitbutton__action:focus {\n\t\tz-index: calc(var(--ck-z-default) + 1);\n\t}\n}\n\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-split-button-hover-background: hsl(0, 0%, 92%);\n\t--ck-color-split-button-hover-border: hsl(0, 0%, 70%);\n}\n\n.ck.ck-splitbutton {\n\t/*\n\t * Note: ck-rounded and ck-dir mixins don\'t go together (because they both use @nest).\n\t */\n\t&:hover > .ck-splitbutton__action,\n\t&.ck-splitbutton_open > .ck-splitbutton__action {\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the action button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the action button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\t}\n\n\t& > .ck-splitbutton__arrow {\n\t\t/* It\'s a text-less button and since the icon is positioned absolutely in such situation,\n\t\tit must get some arbitrary min-width. */\n\t\tmin-width: unset;\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the arrow button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the arrow button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t& svg {\n\t\t\twidth: var(--ck-dropdown-arrow-size);\n\t\t}\n\t}\n\n\t/* Make sure the divider stretches 100% height of the button\n\thttps://github.com/ckeditor/ckeditor5/issues/10936 */\n\t& > .ck-splitbutton__arrow:not(:focus) {\n\t\tborder-top-width: 0px;\n\t\tborder-bottom-width: 0px;\n\t}\n\n\t/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling\n\tas a whole. The background of both buttons should stand out and there should be a visual\n\tseparation between both buttons. */\n\t&.ck-splitbutton_open,\n\t&:hover {\n\t\t/* When the split button hovered as a whole, not as individual buttons. */\n\t\t& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {\n\t\t\tbackground: var(--ck-color-split-button-hover-background);\n\t\t}\n\n\t\t/* Splitbutton separator needs to be set with the ::after pseudoselector\n\t\tto display properly the borders on focus */\n\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\tcontent: \'\';\n\t\t\tposition: absolute;\n\t\t\twidth: 1px;\n\t\t\theight: 100%;\n\t\t\tbackground-color: var(--ck-color-split-button-hover-border);\n\t\t}\n\n\t\t/* Make sure the divider between the buttons looks fine when the button is focused */\n\t\t& > .ck-splitbutton__arrow:focus::after {\n\t\t\t--ck-color-split-button-hover-border: var(--ck-color-focus-border);\n\t\t}\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tleft: -1px;\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tright: -1px;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Don\'t round the bottom left and right corners of the buttons when "open"\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-splitbutton_open {\n\t\t@mixin ck-rounded-corners {\n\t\t\t& > .ck-splitbutton__action {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t}\n\n\t\t\t& > .ck-splitbutton__arrow {\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 5075: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css"], names: [], mappings: "AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\n\t/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n\twidth: max-content;\n\tmax-width: var(--ck-toolbar-dropdown-max-width);\n\n\t& .ck-button {\n\t\t&:focus {\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n\tborder: 0;\n}\n"], sourceRoot: "" }]); const c = a }, 4547: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n\t@mixin ck-rounded-corners;\n\n\t&.ck-focused {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n\n.ck.ck-editor__editable_inline {\n\toverflow: auto;\n\tpadding: 0 var(--ck-spacing-standard);\n\tborder: 1px solid transparent;\n\n\t&[dir="ltr"] {\n\t\ttext-align: left;\n\t}\n\n\t&[dir="rtl"] {\n\t\ttext-align: right;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n\t& > *:first-child {\n\t\tmargin-top: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\n\t& > *:last-child {\n\t\t/*\n\t\t * This value should match with the default margins of the block elements (like .media or .image)\n\t\t * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).\n\t\t */\n\t\tmargin-bottom: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n\t&.ck-blurred ::selection {\n\t\tbackground: var(--ck-color-editable-blur-selection);\n\t}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n\t&::after {\n\t\tborder-bottom-color: var(--ck-color-base-foreground);\n\t}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n\t&::after {\n\t\tborder-top-color: var(--ck-color-base-foreground);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]); const c = a }, 5523: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-form__header .ck-form__header__label{font-weight:700}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/formheader/formheader.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css"], names: [], mappings: "AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BACD,CCNA,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAQD,CAHC,4CACC,eACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\talign-items: center;\n\tjustify-content: space-between;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\theight: var(--ck-form-header-height);\n\tline-height: var(--ck-form-header-height);\n\tborder-bottom: 1px solid var(--ck-color-base-border);\n\n\t& .ck-form__header__label {\n\t\tfont-weight: bold;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 1174: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css"], names: [], mappings: "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n\tvertical-align: middle;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n\twidth: var(--ck-icon-size);\n\theight: var(--ck-icon-size);\n\n\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n\tfont-size: .8333350694em;\n\n\t/* Inherit cursor style (#5). */\n\tcursor: inherit;\n\n\t/* This will prevent blurry icons on Firefox. See #340. */\n\twill-change: transform;\n\n\t& * {\n\t\t/* Inherit cursor style (#5). */\n\t\tcursor: inherit;\n\t}\n\n\t/* Allows dynamic coloring of an icon by inheriting its color from the parent. */\n\t&.ck-icon_inherit-color {\n\t\tcolor: inherit;\n\n\t\t& * {\n\t\t\tcolor: inherit;\n\n\t\t\t&:not([fill]) {\n\t\t\t\t/* Needed by FF. */\n\t\t\t\tfill: currentColor;\n\t\t\t}\n\t\t}\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 6985: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-input-width: 18em;\n\n\t/* Backward compatibility. */\n\t--ck-input-text-width: var(--ck-input-width);\n}\n\n.ck.ck-input {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-input-background);\n\tborder: 1px solid var(--ck-color-input-border);\n\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n\tmin-width: var(--ck-input-width);\n\n\t/* This is important to stay of the same height as surrounding buttons */\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t&[readonly] {\n\t\tborder: 1px solid var(--ck-color-input-disabled-border);\n\t\tbackground: var(--ck-color-input-disabled-background);\n\t\tcolor: var(--ck-color-input-disabled-text);\n\n\t\t&:focus {\n\t\t\t/* The read-only input should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\tborder-color: var(--ck-color-input-error-border);\n\t\tanimation: ck-input-shake .3s ease both;\n\n\t\t&:focus {\n\t\t\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n\t\t}\n\t}\n}\n\n@keyframes ck-input-shake {\n\t20% {\n\t\ttransform: translateX(-2px);\n\t}\n\n\t40% {\n\t\ttransform: translateX(2px);\n\t}\n\n\t60% {\n\t\ttransform: translateX(-1px);\n\t}\n\n\t80% {\n\t\ttransform: translateX(1px);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]); const c = a }, 2751: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css"], names: [], mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tdisplay: block;\n}\n\n.ck.ck-voice-label {\n\tdisplay: none;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tfont-weight: bold;\n}\n"], sourceRoot: "" }]); const c = a }, 8111: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD8GD,CAzGA,2FCDE,qCD0GF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAiBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAP9C,mBAAoB,CAYpB,sBAAuB,CARvB,6DAA+D,CAH/D,oBAAqB,CAgBrB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,+HAYF,CAfA,oUAOE,wIAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\tdisplay: flex;\n\t\tposition: relative;\n\t}\n\n\t& .ck.ck-label {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);\n\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));\n\t--ck-color-labeled-field-label-background: var(--ck-color-base-background);\n}\n\n.ck.ck-labeled-field-view {\n\t@mixin ck-rounded-corners;\n\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\twidth: 100%;\n\n\t\t& > .ck.ck-label {\n\t\t\ttop: 0px;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tleft: 0px;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tright: 0px;\n\t\t\t}\n\n\t\t\tpointer-events: none;\n\t\t\ttransform-origin: 0 0;\n\n\t\t\t/* By default, display the label scaled down above the field. */\n\t\t\ttransform: translate(var(--ck-spacing-medium), -6px) scale(.75);\n\n\t\t\tbackground: var(--ck-color-labeled-field-label-background);\n\t\t\tpadding: 0 calc(.5 * var(--ck-font-size-tiny));\n\t\t\tline-height: initial;\n\t\t\tfont-weight: normal;\n\n\t\t\t/* Prevent overflow when the label is longer than the input */\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\n\t\t\tmax-width: 100%;\n\n\t\t\ttransition:\n\t\t\t\ttransform var(--ck-labeled-field-view-transition),\n\t\t\t\tpadding var(--ck-labeled-field-view-transition),\n\t\t\t\tbackground var(--ck-labeled-field-view-transition);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\t& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\n\t\t& .ck-input:not([readonly]) + .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t& .ck-labeled-field-view__status {\n\t\tfont-size: var(--ck-font-size-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\n\t\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\n\t\tThe status could be very long. */\n\t\twhite-space: normal;\n\n\t\t&.ck-labeled-field-view__status_error {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t/* Disabled fields and fields that have no focus should fade out. */\n\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\tcolor: var(--ck-color-input-disabled-text);\n\t}\n\n\t/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t@mixin ck-dir ltr {\n\t\t\ttransform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttransform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t/* Compensate for the default translate position. */\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));\n\n\t\tbackground: transparent;\n\t\tpadding: 0;\n\t}\n\n\t/*------ DropdownView integration ----------------------------------------------------------------------------------- */\n\n\t/* Make sure dropdown\' background color in any of dropdown\'s state does not collide with labeled field. */\n\t& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {\n\t\tbackground: transparent;\n\t}\n\n\t/* When the dropdown is "empty", the labeled field label replaces its label. */\n\t&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {\n\t\topacity: 0;\n\t}\n\n\t/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 1162: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base));text-align:left;width:100%}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BAIC,eAAgB,CAHhB,gBAAiB,CAQjB,iIAEiE,CARjE,eAAgB,CADhB,UAwCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-direction: column;\n\n\t& .ck-list__item,\n\t& .ck-list__separator {\n\t\tdisplay: block;\n\t}\n\n\t/* Make sure that whatever child of the list item gets focus, it remains on the\n\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n\tadjacent list items. */\n\t& .ck-list__item > *:focus {\n\t\tposition: relative;\n\t\tz-index: var(--ck-z-default);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-list {\n\t@mixin ck-rounded-corners;\n\n\tlist-style-type: none;\n\tbackground: var(--ck-color-list-background);\n}\n\n.ck.ck-list__item {\n\tcursor: default;\n\tmin-width: 12em;\n\n\t& .ck-button {\n\t\tmin-height: unset;\n\t\twidth: 100%;\n\t\ttext-align: left;\n\t\tborder-radius: 0;\n\n\t\t/* List items should have the same height. Use absolute units to make sure it is so\n\t\t   because e.g. different heading styles may have different height\n\t\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\tpadding:\n\t\t\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\n\t\t\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\n\t\t& .ck-button__label {\n\t\t\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\t\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-button-on-background);\n\t\t\tcolor: var(--ck-color-list-button-on-text);\n\n\t\t\t&:active {\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-on-background-focus);\n\t\t\t}\n\n\t\t\t&:focus:not(.ck-switchbutton):not(.ck-disabled) {\n\t\t\t\tborder-color: var(--ck-color-base-background);\n\t\t\t}\n\t\t}\n\n\t\t&:hover:not(.ck-disabled) {\n\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t}\n\t}\n\n\t/* It\'s unnecessary to change the background/text of a switch toggle; it has different ways\n\tof conveying its state (like the switcher) */\n\t& .ck-switchbutton {\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-background);\n\t\t\tcolor: inherit;\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t\t\tcolor: inherit;\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-list__separator {\n\theight: 1px;\n\twidth: 100%;\n\tbackground: var(--ck-color-base-border);\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 8245: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Make sure the balloon arrow does not float over its children. */\n\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n\tdisplay: none;\n\tposition: absolute;\n\n\tz-index: var(--ck-z-modal);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tposition: absolute;\n\t\t}\n\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_visible {\n\t\tdisplay: block;\n\t}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-border-width: 1px;\n\t--ck-balloon-arrow-offset: 2px;\n\t--ck-balloon-arrow-height: 10px;\n\t--ck-balloon-arrow-half-width: 8px;\n\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder-style: solid;\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\n\t\t\tmargin-top: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\n\t\t\tmargin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: var(--ck-color-panel-border) transparent transparent;\n\t\t\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n\t\t\tmargin-bottom: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\n\t\t\tmargin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_e"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-border);\n\t\t\tmargin-right: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-background);\n\t\t\tmargin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_w"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent var(--ck-color-panel-border) transparent transparent;\n\t\t\tmargin-left: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent var(--ck-color-panel-background) transparent transparent;\n\t\t\tmargin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_n {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_ne {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_s {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_se {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_smw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nmw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_e {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_w {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]); const c = a }, 1757: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css"], names: [], mappings: "AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n\tjustify-content: center;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tbackground: var(--ck-color-toolbar-background);\n\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\n\tpadding: 0 var(--ck-spacing-small);\n\n\t/* Let's keep similar appearance to `ck-toolbar`. */\n\t& > * {\n\t\tmargin-right: var(--ck-spacing-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t/* Gives counter more breath than buttons. */\n\t& .ck-balloon-rotator__counter {\n\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t/* We need to use smaller margin because of previous button's right margin. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n.ck .ck-balloon-rotator__content {\n\n\t/* Disable default annotation shadow inside rotator with fake panels. */\n\t& .ck.ck-annotation-wrapper {\n\t\tbox-shadow: none;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 3553: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n\tposition: absolute;\n\n\t/* Fake panels should be placed under main balloon content. */\n\tz-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n\tposition: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tz-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tz-index: 1;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-fake-panel-offset-horizontal: 6px;\n\t--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\tborder-radius: var(--ck-border-radius);\n\n\twidth: 100%;\n\theight: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n\t--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]); const c = a }, 3609: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\tz-index: var(--ck-z-modal); /* #315 */\n\t\tposition: fixed;\n\t\ttop: 0;\n\t}\n\n\t& .ck-sticky-panel__content_sticky_bottom-limit {\n\t\ttop: auto;\n\t\tposition: absolute;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\t@mixin ck-drop-shadow;\n\n\t\tborder-width: 0 1px 1px;\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]); const c = a }, 1590: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, '.ck-vertical-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border-radius:0;margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/responsive-form/responsiveform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css"], names: [], mappings: "AAQC,mCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,yCACC,YACD,CCdA,oCDoBE,wCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,8CACC,YACD,CC9BF,CCAD,qDACC,kDACD,CAEA,uBACC,+BAmED,CAjEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,oCA8CF,CA5CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAKA,0DACC,kDACD,CAGD,iGAIC,eAAgB,CADhB,kCAAmC,CADnC,kCAmBD,CAfC,yHACC,gDACD,CARD,0OAeE,aAMF,CAJE,+IACC,kDACD,CDpEH", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck-vertical-form .ck-button {\n\t&::after {\n\t\tcontent: "";\n\t\twidth: 0;\n\t\tposition: absolute;\n\t\tright: -1px;\n\t\ttop: -1px;\n\t\tbottom: -1px;\n\t\tz-index: 1;\n\t}\n\n\t&:focus::after {\n\t\tdisplay: none;\n\t}\n}\n\n.ck.ck-responsive-form {\n\t@mixin ck-media-phone {\n\t\t& .ck-button {\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: -1px;\n\t\t\t\ttop: -1px;\n\t\t\t\tbottom: -1px;\n\t\t\t\tz-index: 1;\n\t\t\t}\n\n\t\t\t&:focus::after {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\n\tborder-right: 1px solid var(--ck-color-base-border);\n}\n\n.ck.ck-responsive-form {\n\tpadding: var(--ck-spacing-large);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& > :not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& > :not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tpadding: 0;\n\t\twidth: calc(.8 * var(--ck-input-width));\n\n\t\t& .ck-labeled-field-view {\n\t\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) 0;\n\n\t\t\t& .ck-input-text {\n\t\t\t\tmin-width: 0;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\n\t\t\t/* Let the long error messages wrap in the narrow form. */\n\t\t\t& .ck-labeled-field-view__error {\n\t\t\t\twhite-space: normal;\n\t\t\t}\n\t\t}\n\n\t\t/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\t&::after {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\n\t\t& > .ck-button:nth-last-child(1),\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\tpadding: var(--ck-spacing-standard);\n\t\t\tmargin-top: var(--ck-spacing-large);\n\t\t\tborder-radius: 0;\n\n\t\t\t&:not(:focus) {\n\t\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 6706: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/blocktoolbar.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css"], names: [], mappings: "AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-block-toolbar-button {\n\tposition: absolute;\n\tz-index: var(--ck-z-default);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-block-toolbar-button: var(--ck-color-text);\n\t--ck-block-toolbar-button-size: var(--ck-font-size-normal);\n}\n\n.ck.ck-block-toolbar-button {\n\tcolor: var(--ck-color-block-toolbar-button);\n\tfont-size: var(--ck-block-toolbar-size);\n}\n"], sourceRoot: "" }]); const c = a }, 5571: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDoGD,CAvGA,qECOE,qCDgGF,CAvGA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAmGD,CAhGC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAjGF,qCAqGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-flow: row nowrap;\n\talign-items: center;\n\n\t& > .ck-toolbar__items {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\talign-items: center;\n\t\tflex-grow: 1;\n\n\t}\n\n\t& .ck.ck-toolbar__separator {\n\t\tdisplay: inline-block;\n\n\t\t/*\n\t\t * A leading or trailing separator makes no sense (separates from nothing on one side).\n\t\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n\t\t * moved to another toolbar in the dropdown.\n\t\t */\n\t\t&:first-child,\n\t\t&:last-child {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\tflex-basis: 100%;\n\t}\n\n\t&.ck-toolbar_grouping > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t&.ck-toolbar_vertical > .ck-toolbar__items {\n\t\tflex-direction: column;\n\t}\n\n\t&.ck-toolbar_floating > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t& > .ck-dropdown__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-toolbar-background);\n\tpadding: 0 var(--ck-spacing-small);\n\tborder: 1px solid var(--ck-color-toolbar-border);\n\n\t& .ck.ck-toolbar__separator {\n\t\talign-self: stretch;\n\t\twidth: 1px;\n\t\tmin-width: 1px;\n\t\tbackground: var(--ck-color-toolbar-border);\n\n\t\t/*\n\t\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\n\t\t */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\theight: 0;\n\t}\n\n\t& > .ck-toolbar__items {\n\t\t& > *:not(.ck-toolbar__line-break) {\n\t\t\t/* (#11) Separate toolbar items. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\n\t\t/* Don\'t display a separator after an empty items container, for instance,\n\t\twhen all items were grouped */\n\t\t&:empty + .ck.ck-toolbar__separator {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t&.ck-toolbar_vertical {\n\t\t/* Items in a vertical toolbar span the entire width. */\n\t\tpadding: 0;\n\n\t\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\n\t\t& > .ck-toolbar__items > .ck {\n\t\t\t/* Items in a vertical toolbar should span the horizontal space. */\n\t\t\twidth: 100%;\n\n\t\t\t/* Items in a vertical toolbar should have no margin. */\n\t\t\tmargin: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\n\t\t\tborder-radius: 0;\n\t\t}\n\t}\n\n\t&.ck-toolbar_compact {\n\t\t/* No spacing around items. */\n\t\tpadding: 0;\n\n\t\t& > .ck-toolbar__items > * {\n\t\t\t/* Compact toolbar items have no spacing between them. */\n\t\t\tmargin: 0;\n\n\t\t\t/* "Middle" children should have no rounded corners. */\n\t\t\t&:not(:first-child):not(:last-child) {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/*\n\t\t * Dropdown button has asymmetric padding to fit the arrow.\n\t\t * This button has no arrow so let\'s revert that padding back to normal.\n\t\t */\n\t\t& > .ck.ck-button.ck-dropdown__button {\n\t\t\tpadding-left: var(--ck-spacing-tiny);\n\t\t}\n\t}\n\n\t/* A drop-down containing the nested toolbar with configured items. */\n\t& .ck-toolbar__nested-toolbar-dropdown {\n\t\t/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */\n\t\t& > .ck-dropdown__panel {\n\t\t\tmin-width: auto;\n\t\t}\n\n\t\t& > .ck-button > .ck-button__label {\n\t\t\tmax-width: 7em;\n\t\t\twidth: auto;\n\t\t}\n\t}\n\n\t@nest .ck-toolbar-container & {\n\t\tborder: 0;\n\t}\n}\n\n/* stylelint-disable */\n\n/*\n * Styles for RTL toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="rtl"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="rtl"] {\n\t& > .ck-toolbar__items > .ck {\n\t\tmargin-right: 0;\n\t}\n\n\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\n\t\t/* (#11) Separate toolbar items. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-left: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n/*\n * Styles for LTR toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="ltr"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="ltr"] {\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-right: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n}\n\n/* stylelint-enable */\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 9948: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css"], names: [], mappings: "AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDPnC,mBAAoB,CAEpB,qCACD,CCMC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAbD,gCAgBC,eAMD,CAHC,uCACC,YACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t/* Keep tooltips transparent for any interactions. */\n\tpointer-events: none;\n\n\tz-index: calc( var(--ck-z-modal) + 100 );\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t--ck-balloon-border-width: 0px;\n\t--ck-balloon-arrow-offset: 0px;\n\t--ck-balloon-arrow-half-width: 4px;\n\t--ck-balloon-arrow-height: 4px;\n\t--ck-color-panel-background: var(--ck-color-tooltip-background);\n\n\tpadding: 0 var(--ck-spacing-medium);\n\n\t& .ck-tooltip__text {\n\t\tfont-size: .9em;\n\t\tline-height: 1.5;\n\t\tcolor: var(--ck-color-tooltip-text);\n\t}\n\n\t/* Reset balloon panel styles */\n\tbox-shadow: none;\n\n\t/* Hide the default shadow of the .ck-balloon-panel tip */\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 6150: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_hidden.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_reset.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_zindex.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_transition.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css"], names: [], mappings: "AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAwD,CCvGxD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJuGD,CIjGA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n\t/* Override selector specificity. Otherwise, all elements with some display\n\tstyle defined will override this one, which is not a desired result. */\n\tdisplay: none !important;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\tbox-sizing: border-box;\n\twidth: auto;\n\theight: auto;\n\tposition: static;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-z-default: 1;\n\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n\ttransition: none !important;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-base-foreground: \t\t\t\t\t\t\t\thsl(0, 0%, 98%);\n\t--ck-color-base-background: \t\t\t\t\t\t\t\thsl(0, 0%, 100%);\n\t--ck-color-base-border: \t\t\t\t\t\t\t\t\thsl(220, 6%, 81%);\n\t--ck-color-base-action: \t\t\t\t\t\t\t\t\thsl(104, 50.2%, 42.5%);\n\t--ck-color-base-focus: \t\t\t\t\t\t\t\t\t\thsl(209, 92%, 70%);\n\t--ck-color-base-text: \t\t\t\t\t\t\t\t\t\thsl(0, 0%, 20%);\n\t--ck-color-base-active: \t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\t--ck-color-base-active-focus:\t\t\t\t\t\t\t\thsl(218.2, 100%, 52.5%);\n\t--ck-color-base-error:\t\t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------ */\n\n\t--ck-color-focus-border-coordinates: \t\t\t\t\t\t218, 81.8%, 56.9%;\n\t--ck-color-focus-border: \t\t\t\t\t\t\t\t\thsl(var(--ck-color-focus-border-coordinates));\n\t--ck-color-focus-outer-shadow:\t\t\t\t\t\t\t\thsl(212.4, 89.3%, 89%);\n\t--ck-color-focus-disabled-shadow:\t\t\t\t\t\t\thsla(209, 90%, 72%,.3);\n\t--ck-color-focus-error-shadow:\t\t\t\t\t\t\t\thsla(9,100%,56%,.3);\n\t--ck-color-text: \t\t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-shadow-drop: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.15);\n\t--ck-color-shadow-drop-active:\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.2);\n\t--ck-color-shadow-inner: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Buttons ------------------------------------------------------------------------------- */\n\n\t--ck-color-button-default-background: \t\t\t\t\t\ttransparent;\n\t--ck-color-button-default-hover-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-active-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-disabled-background: \t\t\t\ttransparent;\n\n\t--ck-color-button-on-background: \t\t\t\t\t\t\thsl(212, 100%, 97.1%);\n\t--ck-color-button-on-hover-background: \t\t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-active-background: \t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-disabled-background: \t\t\t\t\thsl(211, 15%, 95%);\n\t--ck-color-button-on-color:\t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\n\n\t--ck-color-button-action-background: \t\t\t\t\t\tvar(--ck-color-base-action);\n\t--ck-color-button-action-hover-background: \t\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-active-background: \t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-disabled-background: \t\t\t\thsl(104, 44%, 58%);\n\t--ck-color-button-action-text: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t--ck-color-button-save: \t\t\t\t\t\t\t\t\thsl(120, 100%, 27%);\n\t--ck-color-button-cancel: \t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t--ck-color-switch-button-off-background:\t\t\t\t\thsl(0, 0%, 57.6%);\n\t--ck-color-switch-button-off-hover-background:\t\t\t\thsl(0, 0%, 49%);\n\t--ck-color-switch-button-on-background:\t\t\t\t\t\tvar(--ck-color-button-action-background);\n\t--ck-color-switch-button-on-hover-background:\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-switch-button-inner-background:\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-switch-button-inner-shadow:\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Dropdown ------------------------------------------------------------------------------ */\n\n\t--ck-color-dropdown-panel-background: \t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-dropdown-panel-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Input --------------------------------------------------------------------------------- */\n\n\t--ck-color-input-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-input-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-error-border:\t\t\t\t\t\t\t\tvar(--ck-color-base-error);\n\t--ck-color-input-text: \t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-input-disabled-background: \t\t\t\t\t\thsl(0, 0%, 95%);\n\t--ck-color-input-disabled-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-disabled-text: \t\t\t\t\t\t\thsl(0, 0%, 46%);\n\n\t/* -- List ---------------------------------------------------------------------------------- */\n\n\t--ck-color-list-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-list-button-hover-background: \t\t\t\t\tvar(--ck-color-button-default-hover-background);\n\t--ck-color-list-button-on-background: \t\t\t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-background-focus: \t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-text:\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Panel --------------------------------------------------------------------------------- */\n\n\t--ck-color-panel-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-panel-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Toolbar ------------------------------------------------------------------------------- */\n\n\t--ck-color-toolbar-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-toolbar-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Tooltip ------------------------------------------------------------------------------- */\n\n\t--ck-color-tooltip-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-tooltip-text: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Engine -------------------------------------------------------------------------------- */\n\n\t--ck-color-engine-placeholder-text: \t\t\t\t\t\thsl(0, 0%, 44%);\n\n\t/* -- Upload -------------------------------------------------------------------------------- */\n\n\t--ck-color-upload-bar-background:\t\t \t\t\t\t\thsl(209, 92%, 70%);\n\n\t/* -- Link -------------------------------------------------------------------------------- */\n\n\t--ck-color-link-default:\t\t\t\t\t\t\t\t\thsl(240, 100%, 47%);\n\t--ck-color-link-selected-background:\t\t\t\t\t\thsla(201, 100%, 56%, 0.1);\n\t--ck-color-link-fake-selection:\t\t\t\t\t\t\t\thsla(201, 100%, 56%, 0.3);\n\n\t/* -- Search result highlight ---------------------------------------------------------------- */\n\n\t--ck-color-highlight-background:\t\t\t\t\t\t\thsl(60, 100%, 50%)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * An opacity value of disabled UI item.\n\t */\n\t--ck-disabled-opacity: .5;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * The geometry of the of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n\t/**\n\t * A visual style of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when disabled).\n\t */\n\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when has errors).\n\t */\n\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n\t/**\n\t * A visual style of focused element's border or outline.\n\t */\n\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-font-size-base: 13px;\n\t--ck-line-height-base: 1.84615;\n\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n\t--ck-font-size-tiny: 0.7em;\n\t--ck-font-size-small: 0.75em;\n\t--ck-font-size-normal: 1em;\n\t--ck-font-size-big: 1.4em;\n\t--ck-font-size-large: 1.8em;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* This is super-important. This is **manually** adjusted so a button without an icon\n\tis never smaller than a button with icon, additionally making sure that text-less buttons\n\tare perfect squares. The value is also shared by other components which should stay "in-line"\n\twith buttons. */\n\t--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* Do not include inheritable rules here. */\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: transparent;\n\ttext-decoration: none;\n\tvertical-align: middle;\n\ttransition: none;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n\tword-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* These are rule inherited by all children elements. */\n\tborder-collapse: collapse;\n\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n\tcolor: var(--ck-color-text);\n\ttext-align: left;\n\twhite-space: nowrap;\n\tcursor: auto;\n\tfloat: none;\n}\n\n.ck-reset_all {\n\t& .ck-rtl *:not(.ck-reset_all-excluded *) {\n\t\ttext-align: right;\n\t}\n\n\t& iframe:not(.ck-reset_all-excluded *) {\n\t\t/* For IE */\n\t\tvertical-align: inherit;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *) {\n\t\twhite-space: pre-wrap;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *),\n\t& input[type="text"]:not(.ck-reset_all-excluded *),\n\t& input[type="password"]:not(.ck-reset_all-excluded *) {\n\t\tcursor: text;\n\t}\n\n\t& textarea[disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="text"][disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {\n\t\tcursor: default;\n\t}\n\n\t& fieldset:not(.ck-reset_all-excluded *) {\n\t\tpadding: 10px;\n\t\tborder: 2px groove hsl(255, 7%, 88%);\n\t}\n\n\t& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {\n\t\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n\t\tpadding: 0;\n\t\tborder: 0\n\t}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n\ttext-align: right;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n\t--ck-border-radius: 2px;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * A visual style of element's inner shadow (i.e. input).\n\t */\n\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n\t/**\n\t * A visual style of element's drop shadow (i.e. panel).\n\t */\n\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n\t/**\n\t * A visual style of element's active shadow (i.e. comment or suggestion).\n\t */\n\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-spacing-unit: \t\t\t\t\t\t0.6em;\n\t--ck-spacing-large: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 1.5);\n\t--ck-spacing-standard: \t\t\t\t\tvar(--ck-spacing-unit);\n\t--ck-spacing-medium: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.8);\n\t--ck-spacing-small: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.5);\n\t--ck-spacing-tiny: \t\t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.3);\n\t--ck-spacing-extra-tiny: \t\t\t\tcalc(var(--ck-spacing-unit) * 0.16);\n}\n"], sourceRoot: "" }]); const c = a }, 6507: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widget.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-resizer: var(--ck-color-focus-border);\n\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n\n\t--ck-resizer-border-radius: var(--ck-border-radius);\n\t--ck-resizer-tooltip-offset: 10px;\n\t--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);\n}\n\n.ck .ck-widget {\n\t/* This is neccessary for type around UI to be positioned properly. */\n\tposition: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n\n\t& .ck-widget__selection-handle {\n\t\tposition: absolute;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the icon in not a subject to font-size or line-height to avoid\n\t\t\tunnecessary spacing around it. */\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n\n\t/* Show the selection handle when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n}\n\n.ck .ck-size-view {\n\tbackground: var(--ck-color-resizer-tooltip-background);\n\tcolor: var(--ck-color-resizer-tooltip-text);\n\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\n\tborder-radius: var(--ck-resizer-border-radius);\n\tfont-size: var(--ck-font-size-tiny);\n\tdisplay: block;\n\tpadding: 0 var(--ck-spacing-small);\n\theight: var(--ck-resizer-tooltip-height);\n\tline-height: var(--ck-resizer-tooltip-height);\n\n\t&.ck-orientation-top-left,\n\t&.ck-orientation-top-right,\n\t&.ck-orientation-bottom-right,\n\t&.ck-orientation-bottom-left,\n\t&.ck-orientation-above-center {\n\t\tposition: absolute;\n\t}\n\n\t&.ck-orientation-top-left {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-top-right {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-right {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-left {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t/* Class applied if the widget is too small to contain the size label */\n\t&.ck-orientation-above-center {\n\t\ttop: calc(var(--ck-resizer-tooltip-height) * -1);\n\t\tleft: 50%;\n\t\ttransform: translate(-50%);\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n\t--ck-widget-outline-thickness: 3px;\n\t--ck-widget-handler-icon-size: 16px;\n\t--ck-widget-handler-animation-duration: 200ms;\n\t--ck-widget-handler-animation-curve: ease;\n\n\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n\toutline-width: var(--ck-widget-outline-thickness);\n\toutline-style: solid;\n\toutline-color: transparent;\n\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n\t}\n\n\t&:hover {\n\t\toutline-color: var(--ck-color-widget-hover-border);\n\t}\n}\n\n.ck .ck-editor__nested-editable {\n\tborder: 1px solid transparent;\n\n\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n\tThese styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n\t&.ck-editor__nested-editable_focused,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\t\tbackground-color: var(--ck-color-widget-editable-focus-background);\n\t}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t& .ck-widget__selection-handle {\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\n\t\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n\t\tbackground-color: transparent;\n\t\topacity: 0;\n\n\t\t/* Transition:\n\t\t   * background-color for the .ck-widget_selected state change,\n\t\t   * visibility for hiding the handler,\n\t\t   * opacity for the proper look of the icon when the handler disappears. */\n\t\ttransition:\n\t\t\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t/* Make only top corners round. */\n\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n\t\t/* Place the drag handler outside the widget wrapper. */\n\t\ttransform: translateY(-100%);\n\t\tleft: calc(0px - var(--ck-widget-outline-thickness));\n\t\ttop: 0;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n\t\t\twidth: var(--ck-widget-handler-icon-size);\n\t\t\theight: var(--ck-widget-handler-icon-size);\n\t\t\tcolor: var(--ck-color-widget-drag-handler-icon-color);\n\n\t\t\t/* The "selected" part of the icon is invisible by default */\n\t\t\t& .ck-icon__selected-indicator {\n\t\t\t\topacity: 0;\n\n\t\t\t\t/* Note: The animation is longer on purpose. Simply feels better. */\n\t\t\t\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\n\t\t\t}\n\t\t}\n\n\t\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n\t\t&:hover .ck-icon .ck-icon__selected-indicator {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\topacity: 1;\n\t\tbackground-color: var(--ck-color-widget-hover-border);\n\t}\n\n\t/* Show the selection handler when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\t& > .ck-widget__selection-handle {\n\t\t\topacity: 1;\n\t\t\tbackground-color: var(--ck-color-focus-border);\n\n\t\t\t/* When the widget is selected, notify the user using the proper look of the icon. */\n\t\t\t& .ck-icon .ck-icon__selected-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n\tleft: auto;\n\tright: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n\ttransition: none;\n\n\t&:not(.ck-widget_selected) {\n\t\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\n\t\t *\n\t\t * Leave the unit because this custom property is used in calc() by other features.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\n\t\t */\n\t\t--ck-widget-outline-thickness: 0px;\n\t}\n\n\t&.ck-widget_with-selection-handle {\n\t\t& .ck-widget__selection-handle,\n\t\t& .ck-widget__selection-handle:hover {\n\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t}\n\t}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline-color: var(--ck-color-widget-blurred-border);\n\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t& > .ck-widget__selection-handle,\n\t\t\t& > .ck-widget__selection-handle:hover {\n\t\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n\tIn fact, anything with overflow: hidden.\n\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\n\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]); const c = a }, 2263: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgetresize.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css"], names: [], mappings: "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n}\n\n.ck .ck-widget__resizer {\n\tdisplay: none;\n\tposition: absolute;\n\n\t/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n\tpointer-events: none;\n\n\tleft: 0;\n\ttop: 0;\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n\t& > .ck-widget__resizer {\n\t\tdisplay: block;\n\t}\n}\n\n.ck .ck-widget__resizer__handle {\n\tposition: absolute;\n\n\t/* Resizers are the only UI elements that should interfere with a pointer device. */\n\tpointer-events: all;\n\n\t&.ck-widget__resizer__handle-top-left,\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tcursor: nwse-resize;\n\t}\n\n\t&.ck-widget__resizer__handle-top-right,\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tcursor: nesw-resize;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-resizer-size: 10px;\n\n\t/* Set the resizer with a 50% offset. */\n\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n\t--ck-resizer-border-width: 1px;\n}\n\n.ck .ck-widget__resizer {\n\toutline: 1px solid var(--ck-color-resizer);\n}\n\n.ck .ck-widget__resizer__handle {\n\twidth: var(--ck-resizer-size);\n\theight: var(--ck-resizer-size);\n\tbackground: var(--ck-color-focus-border);\n\tborder: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n\tborder-radius: var(--ck-resizer-border-radius);\n\n\t&.ck-widget__resizer__handle-top-left {\n\t\ttop: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-top-right {\n\t\ttop: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 5137: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css"], names: [], mappings: "AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\toverflow: hidden;\n\t\tz-index: var(--ck-z-default);\n\n\t\t& svg {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\tz-index: calc(var(--ck-z-default) + 2);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_before {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tleft: min(10%, 30px);\n\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_after {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tright: min(10%, 30px);\n\n\t\t\ttransform: translateY(50%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t\ttop: 1px;\n\t\t\tleft: 1px;\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tdisplay: none;\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\t/*\n\t * When the widget is hovered the "fake caret" would normally be narrower than the\n\t * extra outline displayed around the widget. Let\'s extend the "fake caret" to match\n\t * the full width of the widget.\n\t */\n\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\n\t\tright: calc( -1 * var(--ck-widget-outline-thickness) );\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n}\n\n/*\n * Integration with the read-only mode of the editor.\n */\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the restricted editing mode (feature) of the editor.\n */\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\n */\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\n\tdisplay: none;\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-widget-type-around-button-size: 20px;\n\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\n\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\n\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\n\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\n\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\n\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\n}\n\n@define-mixin ck-widget-type-around-button-visible {\n\topacity: 1;\n\tpointer-events: auto;\n}\n\n@define-mixin ck-widget-type-around-button-hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\twidth: var(--ck-widget-type-around-button-size);\n\t\theight: var(--ck-widget-type-around-button-size);\n\t\tbackground: var(--ck-color-widget-type-around-button);\n\t\tborder-radius: 100px;\n\t\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t@mixin ck-widget-type-around-button-hidden;\n\n\t\t& svg {\n\t\t\twidth: 10px;\n\t\t\theight: 8px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t\ttransition: transform .5s ease;\n\t\t\tmargin-top: 1px;\n\n\t\t\t& * {\n\t\t\t\tstroke-dasharray: 10;\n\t\t\t\tstroke-dashoffset: 0;\n\n\t\t\t\tfill: none;\n\t\t\t\tstroke: var(--ck-color-widget-type-around-button-icon);\n\t\t\t\tstroke-width: 1.5px;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t}\n\n\t\t\t& line {\n\t\t\t\tstroke-dasharray: 7;\n\t\t\t}\n\t\t}\n\n\t\t&:hover {\n\t\t\t/*\n\t\t\t * Display the "sonar" around the button when hovered.\n\t\t\t */\n\t\t\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\n\n\t\t\t/*\n\t\t\t * Animate active button\'s icon.\n\t\t\t */\n\t\t\t& svg {\n\t\t\t\t& polyline {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-dash 2s linear;\n\t\t\t\t}\n\n\t\t\t\t& line {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Show type around buttons when the widget gets selected or being hovered.\n\t */\n\t&.ck-widget_selected,\n\t&:hover {\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-visible;\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\n\t * and still can be hovered).\n\t */\n\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\tbackground: var(--ck-color-widget-type-around-button-hover);\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\tbackground: var(--ck-color-widget-type-around-button-active);\n\n\t\t&::after {\n\t\t\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\tborder-radius: 100px;\n\t\t\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the "before" button when the widget has a selection handle. Because some space\n\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\n\t */\n\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\n\t\tmargin-left: 20px;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& .ck-widget__type-around__fake-caret {\n\t\tpointer-events: none;\n\t\theight: 1px;\n\t\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\n\n\t\t/*\n\t\t * The semi-transparent-outline+background combo improves the contrast\n\t\t * when the background underneath the fake caret is dark.\n\t\t */\n\t\toutline: solid 1px hsla(0, 0%, 100%, .5);\n\t\tbackground: var(--ck-color-base-text);\n\t}\n\n\t/*\n\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t * Despite the widget being physically selected in the model, its outline should disappear.\n\t */\n\t&.ck-widget_selected {\n\t\t&.ck-widget_type-around_show-fake-caret_before,\n\t\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t\toutline-color: transparent;\n\t\t}\n\t}\n\n\t&.ck-widget_type-around_show-fake-caret_before,\n\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t/*\n\t\t * When the "fake caret" is visible we simulate that the widget is not selected\n\t\t * (despite being physically selected), so the outline color should be for the\n\t\t * unselected widget.\n\t\t */\n\t\t&.ck-widget_selected:hover {\n\t\t\toutline-color: var(--ck-color-widget-hover-border);\n\t\t}\n\n\t\t/*\n\t\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\n\t\t */\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\n\t\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\n\t\t */\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t&.ck-widget_selected,\n\t\t\t&.ck-widget_selected:hover {\n\t\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\t\topacity: 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\n\t\t * hide the resize UI because it creates too much noise. It can be visible when the user\n\t\t * hovers the widget, though.\n\t\t */\n\t\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\n\t\t\topacity: 0\n\t\t}\n\t}\n}\n\n/*\n * Styles for the "before" button when the widget has a selection handle in an RTL environment.\n * The selection handler is aligned to the right side of the widget so there is no need to create\n * additional space for it next to the "before" button.\n */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {\n\tmargin-left: 0;\n\tmargin-right: 20px;\n}\n\n/*\n * Hide type around buttons when the widget is selected as a child of a selected\n * nested editable (e.g. mulit-cell table selection).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\n */\n.ck-editor__nested-editable.ck-editor__editable_selected {\n\t& .ck-widget {\n\t\t&.ck-widget_selected,\n\t\t&:hover {\n\t\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\n */\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\n\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\n\n\t& svg * {\n\t\tstroke: hsl(0,0%,60%);\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-dash {\n\t0% {\n\t\tstroke-dashoffset: 10;\n\t}\n\t20%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-tip-dash {\n\t0%, 20% {\n\t\tstroke-dashoffset: 7;\n\t}\n\t40%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-button-sonar {\n\t0% {\n\t\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n\t50% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\n\t}\n\t100% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n}\n\n@keyframes ck-widget-type-around-fake-caret-pulse {\n\t0% {\n\t\topacity: 1;\n\t}\n\t49% {\n\t\topacity: 1;\n\t}\n\t50% {\n\t\topacity: 0;\n\t}\n\t99% {\n\t\topacity: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 3645: t => { t.exports = function (t) { var e = []; e.toString = function e() { return this.map((function (e) { var n = t(e); if (e[2]) { return "@media ".concat(e[2], " {").concat(n, "}") } return n })).join("") }; e.i = function (t, n, i) { if (typeof t === "string") { t = [[null, t, ""]] } var o = {}; if (i) { for (var r = 0; r < this.length; r++) { var s = this[r][0]; if (s != null) { o[s] = true } } } for (var a = 0; a < t.length; a++) { var c = [].concat(t[a]); if (i && o[c[0]]) { continue } if (n) { if (!c[2]) { c[2] = n } else { c[2] = "".concat(n, " and ").concat(c[2]) } } e.push(c) } }; return e } }, 4015: t => { function e(t, e) { return s(t) || r(t, e) || i(t, e) || n() } function n() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } function i(t, e) { if (!t) return; if (typeof t === "string") return o(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor) n = t.constructor.name; if (n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return o(t, e) } function o(t, e) { if (e == null || e > t.length) e = t.length; for (var n = 0, i = new Array(e); n < e; n++) { i[n] = t[n] } return i } function r(t, e) { var n = t && (typeof Symbol !== "undefined" && t[Symbol.iterator] || t["@@iterator"]); if (n == null) return; var i = []; var o = true; var r = false; var s, a; try { for (n = n.call(t); !(o = (s = n.next()).done); o = true) { i.push(s.value); if (e && i.length === e) break } } catch (t) { r = true; a = t } finally { try { if (!o && n["return"] != null) n["return"]() } finally { if (r) throw a } } return i } function s(t) { if (Array.isArray(t)) return t } t.exports = function t(n) { var i = e(n, 4), o = i[1], r = i[3]; if (!r) { return o } if (typeof btoa === "function") { var s = btoa(unescape(encodeURIComponent(JSON.stringify(r)))); var a = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(s); var c = "/*# ".concat(a, " */"); var l = r.sources.map((function (t) { return "/*# sourceURL=".concat(r.sourceRoot || "").concat(t, " */") })); return [o].concat(l).concat([c]).join("\n") } return [o].join("\n") } }, 3379: (t, e, n) => { var i = function t() { var e; return function t() { if (typeof e === "undefined") { e = Boolean(window && document && document.all && !window.atob) } return e } }(); var o = function t() { var e = {}; return function t(n) { if (typeof e[n] === "undefined") { var i = document.querySelector(n); if (window.HTMLIFrameElement && i instanceof window.HTMLIFrameElement) { try { i = i.contentDocument.head } catch (t) { i = null } } e[n] = i } return e[n] } }(); var r = []; function s(t) { var e = -1; for (var n = 0; n < r.length; n++) { if (r[n].identifier === t) { e = n; break } } return e } function a(t, e) { var n = {}; var i = []; for (var o = 0; o < t.length; o++) { var a = t[o]; var c = e.base ? a[0] + e.base : a[0]; var l = n[c] || 0; var d = "".concat(c, " ").concat(l); n[c] = l + 1; var u = s(d); var h = { css: a[1], media: a[2], sourceMap: a[3] }; if (u !== -1) { r[u].references++; r[u].updater(h) } else { r.push({ identifier: d, updater: f(h, e), references: 1 }) } i.push(d) } return i } function c(t) { var e = document.createElement("style"); var i = t.attributes || {}; if (typeof i.nonce === "undefined") { var r = true ? n.nc : 0; if (r) { i.nonce = r } } Object.keys(i).forEach((function (t) { e.setAttribute(t, i[t]) })); if (typeof t.insert === "function") { t.insert(e) } else { var s = o(t.insert || "head"); if (!s) { throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.") } s.appendChild(e) } return e } function l(t) { if (t.parentNode === null) { return false } t.parentNode.removeChild(t) } var d = function t() { var e = []; return function t(n, i) { e[n] = i; return e.filter(Boolean).join("\n") } }(); function u(t, e, n, i) { var o = n ? "" : i.media ? "@media ".concat(i.media, " {").concat(i.css, "}") : i.css; if (t.styleSheet) { t.styleSheet.cssText = d(e, o) } else { var r = document.createTextNode(o); var s = t.childNodes; if (s[e]) { t.removeChild(s[e]) } if (s.length) { t.insertBefore(r, s[e]) } else { t.appendChild(r) } } } function h(t, e, n) { var i = n.css; var o = n.media; var r = n.sourceMap; if (o) { t.setAttribute("media", o) } else { t.removeAttribute("media") } if (r && typeof btoa !== "undefined") { i += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r)))), " */") } if (t.styleSheet) { t.styleSheet.cssText = i } else { while (t.firstChild) { t.removeChild(t.firstChild) } t.appendChild(document.createTextNode(i)) } } var g = null; var m = 0; function f(t, e) { var n; var i; var o; if (e.singleton) { var r = m++; n = g || (g = c(e)); i = u.bind(null, n, r, false); o = u.bind(null, n, r, true) } else { n = c(e); i = h.bind(null, n, e); o = function t() { l(n) } } i(t); return function e(n) { if (n) { if (n.css === t.css && n.media === t.media && n.sourceMap === t.sourceMap) { return } i(t = n) } else { o() } } } t.exports = function (t, e) { e = e || {}; if (!e.singleton && typeof e.singleton !== "boolean") { e.singleton = i() } t = t || []; var n = a(t, e); return function t(i) { i = i || []; if (Object.prototype.toString.call(i) !== "[object Array]") { return } for (var o = 0; o < n.length; o++) { var c = n[o]; var l = s(c); r[l].references-- } var d = a(i, e); for (var u = 0; u < n.length; u++) { var h = n[u]; var g = s(h); if (r[g].references === 0) { r[g].updater(); r.splice(g, 1) } } n = d } } } }; var e = {}; function n(i) { var o = e[i]; if (o !== undefined) { return o.exports } var r = e[i] = { id: i, exports: {} }; t[i](r, r.exports, n); return r.exports } (() => { n.n = t => { var e = t && t.__esModule ? () => t["default"] : () => t; n.d(e, { a: e }); return e } })(); (() => { n.d = (t, e) => { for (var i in e) { if (n.o(e, i) && !n.o(t, i)) { Object.defineProperty(t, i, { enumerable: true, get: e[i] }) } } } })(); (() => { n.g = function () { if (typeof globalThis === "object") return globalThis; try { return this || new Function("return this")() } catch (t) { if (typeof window === "object") return window } }() })(); (() => { n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e) })(); (() => { n.nc = undefined })(); var i = {}; (() => { n.d(i, { default: () => o$ }); function t() { try { return navigator.userAgent.toLowerCase() } catch (t) { return "" } } const e = t(); const o = { isMac: s(e), isWindows: a(e), isGecko: c(e), isSafari: l(e), isiOS: d(e), isAndroid: u(e), isBlink: h(e), features: { isRegExpUnicodePropertySupported: g() } }; const r = o; function s(t) { return t.indexOf("macintosh") > -1 } function a(t) { return t.indexOf("windows") > -1 } function c(t) { return !!t.match(/gecko\/\d+/) } function l(t) { return t.indexOf(" applewebkit/") > -1 && t.indexOf("chrome") === -1 } function d(t) { return !!t.match(/iphone|ipad/i) || s(t) && navigator.maxTouchPoints > 0 } function u(t) { return t.indexOf("android") > -1 } function h(t) { return t.indexOf("chrome/") > -1 && t.indexOf("edge/") < 0 } function g() { let t = false; try { t = "ć".search(new RegExp("[\\p{L}]", "u")) === 0 } catch (t) { } return t } function m(t, e, n, i) { n = n || function (t, e) { return t === e }; const o = Array.isArray(t) ? t : Array.prototype.slice.call(t); const r = Array.isArray(e) ? e : Array.prototype.slice.call(e); const s = f(o, r, n); const a = i ? w(s, r.length) : k(r, s); return a } function f(t, e, n) { const i = p(t, e, n); if (i === -1) { return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 } } const o = b(t, i); const r = b(e, i); const s = p(o, r, n); const a = t.length - s; const c = e.length - s; return { firstIndex: i, lastIndexOld: a, lastIndexNew: c } } function p(t, e, n) { for (let i = 0; i < Math.max(t.length, e.length); i++) { if (t[i] === undefined || e[i] === undefined || !n(t[i], e[i])) { return i } } return -1 } function b(t, e) { return t.slice(e).reverse() } function k(t, e) { const n = []; const { firstIndex: i, lastIndexOld: o, lastIndexNew: r } = e; if (r - i > 0) { n.push({ index: i, type: "insert", values: t.slice(i, r) }) } if (o - i > 0) { n.push({ index: i + (r - i), type: "delete", howMany: o - i }) } return n } function w(t, e) { const { firstIndex: n, lastIndexOld: i, lastIndexNew: o } = t; if (n === -1) { return Array(e).fill("equal") } let r = []; if (n > 0) { r = r.concat(Array(n).fill("equal")) } if (o - n > 0) { r = r.concat(Array(o - n).fill("insert")) } if (i - n > 0) { r = r.concat(Array(i - n).fill("delete")) } if (o < e) { r = r.concat(Array(e - o).fill("equal")) } return r } function A(t, e, n) { n = n || function (t, e) { return t === e }; const i = t.length; const o = e.length; if (i > 200 || o > 200 || i + o > 300) { return A.fastDiff(t, e, n, true) } let r, s; if (o < i) { const n = t; t = e; e = n; r = "delete"; s = "insert" } else { r = "insert"; s = "delete" } const a = t.length; const c = e.length; const l = c - a; const d = {}; const u = {}; function h(i) { const o = (u[i - 1] !== undefined ? u[i - 1] : -1) + 1; const l = u[i + 1] !== undefined ? u[i + 1] : -1; const h = o > l ? -1 : 1; if (d[i + h]) { d[i] = d[i + h].slice(0) } if (!d[i]) { d[i] = [] } d[i].push(o > l ? r : s); let g = Math.max(o, l); let m = g - i; while (m < a && g < c && n(t[m], e[g])) { m++; g++; d[i].push("equal") } return g } let g = 0; let m; do { for (m = -g; m < l; m++) { u[m] = h(m) } for (m = l + g; m > l; m--) { u[m] = h(m) } u[l] = h(l); g++ } while (u[l] !== c); return d[l].slice(1) } A.fastDiff = m; function _() { return function t() { t.called = true } } const C = _; class v { constructor(t, e) { this.source = t; this.name = e; this.path = []; this.stop = C(); this.off = C() } } const y = new Array(256).fill("").map(((t, e) => ("0" + e.toString(16)).slice(-2))); function x() { const t = Math.random() * 4294967296 >>> 0; const e = Math.random() * 4294967296 >>> 0; const n = Math.random() * 4294967296 >>> 0; const i = Math.random() * 4294967296 >>> 0; return "e" + y[t >> 0 & 255] + y[t >> 8 & 255] + y[t >> 16 & 255] + y[t >> 24 & 255] + y[e >> 0 & 255] + y[e >> 8 & 255] + y[e >> 16 & 255] + y[e >> 24 & 255] + y[n >> 0 & 255] + y[n >> 8 & 255] + y[n >> 16 & 255] + y[n >> 24 & 255] + y[i >> 0 & 255] + y[i >> 8 & 255] + y[i >> 16 & 255] + y[i >> 24 & 255] } const E = { get(t = "normal") { if (typeof t != "number") { return this[t] || this.normal } else { return t } }, highest: 1e5, high: 1e3, normal: 0, low: -1e3, lowest: -1e5 }; const D = E; function S(t, e) { const n = D.get(e.priority); for (let i = 0; i < t.length; i++) { if (D.get(t[i].priority) < n) { t.splice(i, 0, e); return } } t.push(e) } const T = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html"; class I extends Error { constructor(t, e, n) { super(N(t, n)); this.name = "CKEditorError"; this.context = e; this.data = n } is(t) { return t === "CKEditorError" } static rethrowUnexpectedError(t, e) { if (t.is && t.is("CKEditorError")) { throw t } const n = new I(t.message, e); n.stack = t.stack; throw n } } function M(t, e) { console.warn(...z(t, e)) } function B(t, e) { console.error(...z(t, e)) } function L(t) { return `\nRead more: ${T}#error-${t}` } function N(t, e) { const n = new WeakSet; const i = (t, e) => { if (typeof e === "object" && e !== null) { if (n.has(e)) { return `[object ${e.constructor.name}]` } n.add(e) } return e }; const o = e ? ` ${JSON.stringify(e, i)}` : ""; const r = L(t); return t + o + r } function z(t, e) { const n = L(t); return e ? [t, e, n] : [t, n] } const P = "37.1.0"; const O = null && P; const R = typeof window === "object" ? window : n.g; if (R.CKEDITOR_VERSION) { throw new I("ckeditor-duplicated-modules", null) } else { R.CKEDITOR_VERSION = P } const V = Symbol("listeningTo"); const j = Symbol("emitterId"); const F = Symbol("delegations"); const H = U(Object); function U(t) { if (!t) { return H } class e extends t { on(t, e, n) { this.listenTo(this, t, e, n) } once(t, e, n) { let i = false; const o = (t, ...n) => { if (!i) { i = true; t.off(); e.call(this, t, ...n) } }; this.listenTo(this, t, o, n) } off(t, e) { this.stopListening(this, t, e) } listenTo(t, e, n, i = {}) { let o, r; if (!this[V]) { this[V] = {} } const s = this[V]; if (!G(t)) { q(t) } const a = G(t); if (!(o = s[a])) { o = s[a] = { emitter: t, callbacks: {} } } if (!(r = o.callbacks[e])) { r = o.callbacks[e] = [] } r.push(n); X(this, t, e, n, i) } stopListening(t, e, n) { const i = this[V]; let o = t && G(t); const r = i && o ? i[o] : undefined; const s = r && e ? r.callbacks[e] : undefined; if (!i || t && !r || e && !s) { return } if (n) { tt(this, t, e, n); const i = s.indexOf(n); if (i !== -1) { if (s.length === 1) { delete r.callbacks[e] } else { tt(this, t, e, n) } } } else if (s) { while (n = s.pop()) { tt(this, t, e, n) } delete r.callbacks[e] } else if (r) { for (e in r.callbacks) { this.stopListening(t, e) } delete i[o] } else { for (o in i) { this.stopListening(i[o].emitter) } delete this[V] } } fire(t, ...e) { try { const n = t instanceof v ? t : new v(this, t); const i = n.name; let o = Z(this, i); n.path.push(this); if (o) { const t = [n, ...e]; o = Array.from(o); for (let e = 0; e < o.length; e++) { o[e].callback.apply(this, t); if (n.off.called) { delete n.off.called; this._removeEventListener(i, o[e].callback) } if (n.stop.called) { break } } } const r = this[F]; if (r) { const t = r.get(i); const o = r.get("*"); if (t) { J(t, n, e) } if (o) { J(o, n, e) } } return n.return } catch (t) { I.rethrowUnexpectedError(t, this) } } delegate(...t) { return { to: (e, n) => { if (!this[F]) { this[F] = new Map } t.forEach((t => { const i = this[F].get(t); if (!i) { this[F].set(t, new Map([[e, n]])) } else { i.set(e, n) } })) } } } stopDelegating(t, e) { if (!this[F]) { return } if (!t) { this[F].clear() } else if (!e) { this[F].delete(t) } else { const n = this[F].get(t); if (n) { n.delete(e) } } } _addEventListener(t, e, n) { Y(this, t); const i = Q(this, t); const o = D.get(n.priority); const r = { callback: e, priority: o }; for (const t of i) { S(t, r) } } _removeEventListener(t, e) { const n = Q(this, t); for (const t of n) { for (let n = 0; n < t.length; n++) { if (t[n].callback == e) { t.splice(n, 1); n-- } } } } } return e } ["on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t => { U[t] = H.prototype[t] })); function W(t, e) { const n = t[V]; if (n && n[e]) { return n[e].emitter } return null } function q(t, e) { if (!t[j]) { t[j] = e || x() } } function G(t) { return t[j] } function $(t) { if (!t._events) { Object.defineProperty(t, "_events", { value: {} }) } return t._events } function K() { return { callbacks: [], childEvents: [] } } function Y(t, e) { const n = $(t); if (n[e]) { return } let i = e; let o = null; const r = []; while (i !== "") { if (n[i]) { break } n[i] = K(); r.push(n[i]); if (o) { n[i].childEvents.push(o) } o = i; i = i.substr(0, i.lastIndexOf(":")) } if (i !== "") { for (const t of r) { t.callbacks = n[i].callbacks.slice() } n[i].childEvents.push(o) } } function Q(t, e) { const n = $(t)[e]; if (!n) { return [] } let i = [n.callbacks]; for (let e = 0; e < n.childEvents.length; e++) { const o = Q(t, n.childEvents[e]); i = i.concat(o) } return i } function Z(t, e) { let n; if (!t._events || !(n = t._events[e]) || !n.callbacks.length) { if (e.indexOf(":") > -1) { return Z(t, e.substr(0, e.lastIndexOf(":"))) } else { return null } } return n.callbacks } function J(t, e, n) { for (let [i, o] of t) { if (!o) { o = e.name } else if (typeof o == "function") { o = o(e.name) } const t = new v(e.source, o); t.path = [...e.path]; i.fire(t, ...n) } } function X(t, e, n, i, o) { if (e._addEventListener) { e._addEventListener(n, i, o) } else { t._addEventListener.call(e, n, i, o) } } function tt(t, e, n, i) { if (e._removeEventListener) { e._removeEventListener(n, i) } else { t._removeEventListener.call(e, n, i) } } function et(t) { var e = typeof t; return t != null && (e == "object" || e == "function") } const nt = et; const it = Symbol("observableProperties"); const ot = Symbol("boundObservables"); const rt = Symbol("boundProperties"); const st = Symbol("decoratedMethods"); const at = Symbol("decoratedOriginal"); const ct = lt(U()); function lt(t) { if (!t) { return ct } class e extends t { set(t, e) { if (nt(t)) { Object.keys(t).forEach((e => { this.set(e, t[e]) }), this); return } dt(this); const n = this[it]; if (t in this && !n.has(t)) { throw new I("observable-set-cannot-override", this) } Object.defineProperty(this, t, { enumerable: true, configurable: true, get() { return n.get(t) }, set(e) { const i = n.get(t); let o = this.fire(`set:${t}`, t, e, i); if (o === undefined) { o = e } if (i !== o || !n.has(t)) { n.set(t, o); this.fire(`change:${t}`, t, o, i) } } }); this[t] = e } bind(...t) { if (!t.length || !mt(t)) { throw new I("observable-bind-wrong-properties", this) } if (new Set(t).size !== t.length) { throw new I("observable-bind-duplicate-properties", this) } dt(this); const e = this[rt]; t.forEach((t => { if (e.has(t)) { throw new I("observable-bind-rebind", this) } })); const n = new Map; t.forEach((t => { const i = { property: t, to: [] }; e.set(t, i); n.set(t, i) })); return { to: ut, toMany: ht, _observable: this, _bindProperties: t, _to: [], _bindings: n } } unbind(...t) { if (!this[it]) { return } const e = this[rt]; const n = this[ot]; if (t.length) { if (!mt(t)) { throw new I("observable-unbind-wrong-properties", this) } t.forEach((t => { const i = e.get(t); if (!i) { return } i.to.forEach((([t, e]) => { const o = n.get(t); const r = o[e]; r.delete(i); if (!r.size) { delete o[e] } if (!Object.keys(o).length) { n.delete(t); this.stopListening(t, "change") } })); e.delete(t) })) } else { n.forEach(((t, e) => { this.stopListening(e, "change") })); n.clear(); e.clear() } } decorate(t) { dt(this); const e = this[t]; if (!e) { throw new I("observablemixin-cannot-decorate-undefined", this, { object: this, methodName: t }) } this.on(t, ((t, n) => { t.return = e.apply(this, n) })); this[t] = function (...e) { return this.fire(t, e) }; this[t][at] = e; if (!this[st]) { this[st] = [] } this[st].push(t) } stopListening(t, e, n) { if (!t && this[st]) { for (const t of this[st]) { this[t] = this[t][at] } delete this[st] } super.stopListening(t, e, n) } } return e } ["set", "bind", "unbind", "decorate", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t => { lt[t] = ct.prototype[t] })); function dt(t) { if (t[it]) { return } Object.defineProperty(t, it, { value: new Map }); Object.defineProperty(t, ot, { value: new Map }); Object.defineProperty(t, rt, { value: new Map }) } function ut(...t) { const e = ft(...t); const n = Array.from(this._bindings.keys()); const i = n.length; if (!e.callback && e.to.length > 1) { throw new I("observable-bind-to-no-callback", this) } if (i > 1 && e.callback) { throw new I("observable-bind-to-extra-callback", this) } e.to.forEach((t => { if (t.properties.length && t.properties.length !== i) { throw new I("observable-bind-to-properties-length", this) } if (!t.properties.length) { t.properties = this._bindProperties } })); this._to = e.to; if (e.callback) { this._bindings.get(n[0]).callback = e.callback } wt(this._observable, this._to); bt(this); this._bindProperties.forEach((t => { kt(this._observable, t) })) } function ht(t, e, n) { if (this._bindings.size > 1) { throw new I("observable-bind-to-many-not-one-binding", this) } this.to(...gt(t, e), n) } function gt(t, e) { const n = t.map((t => [t, e])); return Array.prototype.concat.apply([], n) } function mt(t) { return t.every((t => typeof t == "string")) } function ft(...t) { if (!t.length) { throw new I("observable-bind-to-parse-error", null) } const e = { to: [] }; let n; if (typeof t[t.length - 1] == "function") { e.callback = t.pop() } t.forEach((t => { if (typeof t == "string") { n.properties.push(t) } else if (typeof t == "object") { n = { observable: t, properties: [] }; e.to.push(n) } else { throw new I("observable-bind-to-parse-error", null) } })); return e } function pt(t, e, n, i) { const o = t[ot]; const r = o.get(n); const s = r || {}; if (!s[i]) { s[i] = new Set } s[i].add(e); if (!r) { o.set(n, s) } } function bt(t) { let e; t._bindings.forEach(((n, i) => { t._to.forEach((o => { e = o.properties[n.callback ? 0 : t._bindProperties.indexOf(i)]; n.to.push([o.observable, e]); pt(t._observable, n, o.observable, e) })) })) } function kt(t, e) { const n = t[rt]; const i = n.get(e); let o; if (i.callback) { o = i.callback.apply(t, i.to.map((t => t[0][t[1]]))) } else { o = i.to[0]; o = o[0][o[1]] } if (Object.prototype.hasOwnProperty.call(t, e)) { t[e] = o } else { t.set(e, o) } } function wt(t, e) { e.forEach((e => { const n = t[ot]; let i; if (!n.get(e.observable)) { t.listenTo(e.observable, "change", ((o, r) => { i = n.get(e.observable)[r]; if (i) { i.forEach((e => { kt(t, e.property) })) } })) } })) } function At(t) { let e = 0; for (const n of t) { e++ } return e } function _t(t, e) { const n = Math.min(t.length, e.length); for (let i = 0; i < n; i++) { if (t[i] != e[i]) { return i } } if (t.length == e.length) { return "same" } else if (t.length < e.length) { return "prefix" } else { return "extension" } } function Ct(t) { return !!(t && t[Symbol.iterator]) } var vt = typeof global == "object" && global && global.Object === Object && global; const yt = vt; var xt = typeof self == "object" && self && self.Object === Object && self; var Et = yt || xt || Function("return this")(); const Dt = Et; var St = Dt.Symbol; const Tt = St; var It = Object.prototype; var Mt = It.hasOwnProperty; var Bt = It.toString; var Lt = Tt ? Tt.toStringTag : undefined; function Nt(t) { var e = Mt.call(t, Lt), n = t[Lt]; try { t[Lt] = undefined; var i = true } catch (t) { } var o = Bt.call(t); if (i) { if (e) { t[Lt] = n } else { delete t[Lt] } } return o } const zt = Nt; var Pt = Object.prototype; var Ot = Pt.toString; function Rt(t) { return Ot.call(t) } const Vt = Rt; var jt = "[object Null]", Ft = "[object Undefined]"; var Ht = Tt ? Tt.toStringTag : undefined; function Ut(t) { if (t == null) { return t === undefined ? Ft : jt } return Ht && Ht in Object(t) ? zt(t) : Vt(t) } const Wt = Ut; var qt = Array.isArray; const Gt = qt; function $t(t) { return t != null && typeof t == "object" } const Kt = $t; var Yt = "[object String]"; function Qt(t) { return typeof t == "string" || !Gt(t) && Kt(t) && Wt(t) == Yt } const Zt = Qt; function Jt(t, e, n = {}, i = []) { const o = n && n.xmlns; const r = o ? t.createElementNS(o, e) : t.createElement(e); for (const t in n) { r.setAttribute(t, n[t]) } if (Zt(i) || !Ct(i)) { i = [i] } for (let e of i) { if (Zt(e)) { e = t.createTextNode(e) } r.appendChild(e) } return r } function Xt(t, e) { return function (n) { return t(e(n)) } } const te = Xt; var ee = te(Object.getPrototypeOf, Object); const ne = ee; var ie = "[object Object]"; var oe = Function.prototype, re = Object.prototype; var se = oe.toString; var ae = re.hasOwnProperty; var ce = se.call(Object); function le(t) { if (!Kt(t) || Wt(t) != ie) { return false } var e = ne(t); if (e === null) { return true } var n = ae.call(e, "constructor") && e.constructor; return typeof n == "function" && n instanceof n && se.call(n) == ce } const de = le; function ue() { this.__data__ = []; this.size = 0 } const he = ue; function ge(t, e) { return t === e || t !== t && e !== e } const me = ge; function fe(t, e) { var n = t.length; while (n--) { if (me(t[n][0], e)) { return n } } return -1 } const pe = fe; var be = Array.prototype; var ke = be.splice; function we(t) { var e = this.__data__, n = pe(e, t); if (n < 0) { return false } var i = e.length - 1; if (n == i) { e.pop() } else { ke.call(e, n, 1) } --this.size; return true } const Ae = we; function _e(t) { var e = this.__data__, n = pe(e, t); return n < 0 ? undefined : e[n][1] } const Ce = _e; function ve(t) { return pe(this.__data__, t) > -1 } const ye = ve; function xe(t, e) { var n = this.__data__, i = pe(n, t); if (i < 0) { ++this.size; n.push([t, e]) } else { n[i][1] = e } return this } const Ee = xe; function De(t) { var e = -1, n = t == null ? 0 : t.length; this.clear(); while (++e < n) { var i = t[e]; this.set(i[0], i[1]) } } De.prototype.clear = he; De.prototype["delete"] = Ae; De.prototype.get = Ce; De.prototype.has = ye; De.prototype.set = Ee; const Se = De; function Te() { this.__data__ = new Se; this.size = 0 } const Ie = Te; function Me(t) { var e = this.__data__, n = e["delete"](t); this.size = e.size; return n } const Be = Me; function Le(t) { return this.__data__.get(t) } const Ne = Le; function ze(t) { return this.__data__.has(t) } const Pe = ze; var Oe = "[object AsyncFunction]", Re = "[object Function]", Ve = "[object GeneratorFunction]", je = "[object Proxy]"; function Fe(t) { if (!nt(t)) { return false } var e = Wt(t); return e == Re || e == Ve || e == Oe || e == je } const He = Fe; var Ue = Dt["__core-js_shared__"]; const We = Ue; var qe = function () { var t = /[^.]+$/.exec(We && We.keys && We.keys.IE_PROTO || ""); return t ? "Symbol(src)_1." + t : "" }(); function Ge(t) { return !!qe && qe in t } const $e = Ge; var Ke = Function.prototype; var Ye = Ke.toString; function Qe(t) { if (t != null) { try { return Ye.call(t) } catch (t) { } try { return t + "" } catch (t) { } } return "" } const Ze = Qe; var Je = /[\\^$.*+?()[\]{}|]/g; var Xe = /^\[object .+?Constructor\]$/; var tn = Function.prototype, en = Object.prototype; var nn = tn.toString; var on = en.hasOwnProperty; var rn = RegExp("^" + nn.call(on).replace(Je, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"); function sn(t) { if (!nt(t) || $e(t)) { return false } var e = He(t) ? rn : Xe; return e.test(Ze(t)) } const an = sn; function cn(t, e) { return t == null ? undefined : t[e] } const ln = cn; function dn(t, e) { var n = ln(t, e); return an(n) ? n : undefined } const un = dn; var hn = un(Dt, "Map"); const gn = hn; var mn = un(Object, "create"); const fn = mn; function pn() { this.__data__ = fn ? fn(null) : {}; this.size = 0 } const bn = pn; function kn(t) { var e = this.has(t) && delete this.__data__[t]; this.size -= e ? 1 : 0; return e } const wn = kn; var An = "__lodash_hash_undefined__"; var _n = Object.prototype; var Cn = _n.hasOwnProperty; function vn(t) { var e = this.__data__; if (fn) { var n = e[t]; return n === An ? undefined : n } return Cn.call(e, t) ? e[t] : undefined } const yn = vn; var xn = Object.prototype; var En = xn.hasOwnProperty; function Dn(t) { var e = this.__data__; return fn ? e[t] !== undefined : En.call(e, t) } const Sn = Dn; var Tn = "__lodash_hash_undefined__"; function In(t, e) { var n = this.__data__; this.size += this.has(t) ? 0 : 1; n[t] = fn && e === undefined ? Tn : e; return this } const Mn = In; function Bn(t) { var e = -1, n = t == null ? 0 : t.length; this.clear(); while (++e < n) { var i = t[e]; this.set(i[0], i[1]) } } Bn.prototype.clear = bn; Bn.prototype["delete"] = wn; Bn.prototype.get = yn; Bn.prototype.has = Sn; Bn.prototype.set = Mn; const Ln = Bn; function Nn() { this.size = 0; this.__data__ = { hash: new Ln, map: new (gn || Se), string: new Ln } } const zn = Nn; function Pn(t) { var e = typeof t; return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null } const On = Pn; function Rn(t, e) { var n = t.__data__; return On(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map } const Vn = Rn; function jn(t) { var e = Vn(this, t)["delete"](t); this.size -= e ? 1 : 0; return e } const Fn = jn; function Hn(t) { return Vn(this, t).get(t) } const Un = Hn; function Wn(t) { return Vn(this, t).has(t) } const qn = Wn; function Gn(t, e) { var n = Vn(this, t), i = n.size; n.set(t, e); this.size += n.size == i ? 0 : 1; return this } const $n = Gn; function Kn(t) { var e = -1, n = t == null ? 0 : t.length; this.clear(); while (++e < n) { var i = t[e]; this.set(i[0], i[1]) } } Kn.prototype.clear = zn; Kn.prototype["delete"] = Fn; Kn.prototype.get = Un; Kn.prototype.has = qn; Kn.prototype.set = $n; const Yn = Kn; var Qn = 200; function Zn(t, e) { var n = this.__data__; if (n instanceof Se) { var i = n.__data__; if (!gn || i.length < Qn - 1) { i.push([t, e]); this.size = ++n.size; return this } n = this.__data__ = new Yn(i) } n.set(t, e); this.size = n.size; return this } const Jn = Zn; function Xn(t) { var e = this.__data__ = new Se(t); this.size = e.size } Xn.prototype.clear = Ie; Xn.prototype["delete"] = Be; Xn.prototype.get = Ne; Xn.prototype.has = Pe; Xn.prototype.set = Jn; const ti = Xn; function ei(t, e) { var n = -1, i = t == null ? 0 : t.length; while (++n < i) { if (e(t[n], n, t) === false) { break } } return t } const ni = ei; var ii = function () { try { var t = un(Object, "defineProperty"); t({}, "", {}); return t } catch (t) { } }(); const oi = ii; function ri(t, e, n) { if (e == "__proto__" && oi) { oi(t, e, { configurable: true, enumerable: true, value: n, writable: true }) } else { t[e] = n } } const si = ri; var ai = Object.prototype; var ci = ai.hasOwnProperty; function li(t, e, n) { var i = t[e]; if (!(ci.call(t, e) && me(i, n)) || n === undefined && !(e in t)) { si(t, e, n) } } const di = li; function ui(t, e, n, i) { var o = !n; n || (n = {}); var r = -1, s = e.length; while (++r < s) { var a = e[r]; var c = i ? i(n[a], t[a], a, n, t) : undefined; if (c === undefined) { c = t[a] } if (o) { si(n, a, c) } else { di(n, a, c) } } return n } const hi = ui; function gi(t, e) { var n = -1, i = Array(t); while (++n < t) { i[n] = e(n) } return i } const mi = gi; var fi = "[object Arguments]"; function pi(t) { return Kt(t) && Wt(t) == fi } const bi = pi; var ki = Object.prototype; var wi = ki.hasOwnProperty; var Ai = ki.propertyIsEnumerable; var _i = bi(function () { return arguments }()) ? bi : function (t) { return Kt(t) && wi.call(t, "callee") && !Ai.call(t, "callee") }; const Ci = _i; function vi() { return false } const yi = vi; var xi = typeof exports == "object" && exports && !exports.nodeType && exports; var Ei = xi && typeof module == "object" && module && !module.nodeType && module; var Di = Ei && Ei.exports === xi; var Si = Di ? Dt.Buffer : undefined; var Ti = Si ? Si.isBuffer : undefined; var Ii = Ti || yi; const Mi = Ii; var Bi = 9007199254740991; var Li = /^(?:0|[1-9]\d*)$/; function Ni(t, e) { var n = typeof t; e = e == null ? Bi : e; return !!e && (n == "number" || n != "symbol" && Li.test(t)) && (t > -1 && t % 1 == 0 && t < e) } const zi = Ni; var Pi = 9007199254740991; function Oi(t) { return typeof t == "number" && t > -1 && t % 1 == 0 && t <= Pi } const Ri = Oi; var Vi = "[object Arguments]", ji = "[object Array]", Fi = "[object Boolean]", Hi = "[object Date]", Ui = "[object Error]", Wi = "[object Function]", qi = "[object Map]", Gi = "[object Number]", $i = "[object Object]", Ki = "[object RegExp]", Yi = "[object Set]", Qi = "[object String]", Zi = "[object WeakMap]"; var Ji = "[object ArrayBuffer]", Xi = "[object DataView]", to = "[object Float32Array]", eo = "[object Float64Array]", no = "[object Int8Array]", io = "[object Int16Array]", oo = "[object Int32Array]", ro = "[object Uint8Array]", so = "[object Uint8ClampedArray]", ao = "[object Uint16Array]", co = "[object Uint32Array]"; var lo = {}; lo[to] = lo[eo] = lo[no] = lo[io] = lo[oo] = lo[ro] = lo[so] = lo[ao] = lo[co] = true; lo[Vi] = lo[ji] = lo[Ji] = lo[Fi] = lo[Xi] = lo[Hi] = lo[Ui] = lo[Wi] = lo[qi] = lo[Gi] = lo[$i] = lo[Ki] = lo[Yi] = lo[Qi] = lo[Zi] = false; function uo(t) { return Kt(t) && Ri(t.length) && !!lo[Wt(t)] } const ho = uo; function go(t) { return function (e) { return t(e) } } const mo = go; var fo = typeof exports == "object" && exports && !exports.nodeType && exports; var po = fo && typeof module == "object" && module && !module.nodeType && module; var bo = po && po.exports === fo; var ko = bo && yt.process; var wo = function () { try { var t = po && po.require && po.require("util").types; if (t) { return t } return ko && ko.binding && ko.binding("util") } catch (t) { } }(); const Ao = wo; var _o = Ao && Ao.isTypedArray; var Co = _o ? mo(_o) : ho; const vo = Co; var yo = Object.prototype; var xo = yo.hasOwnProperty; function Eo(t, e) { var n = Gt(t), i = !n && Ci(t), o = !n && !i && Mi(t), r = !n && !i && !o && vo(t), s = n || i || o || r, a = s ? mi(t.length, String) : [], c = a.length; for (var l in t) { if ((e || xo.call(t, l)) && !(s && (l == "length" || o && (l == "offset" || l == "parent") || r && (l == "buffer" || l == "byteLength" || l == "byteOffset") || zi(l, c)))) { a.push(l) } } return a } const Do = Eo; var So = Object.prototype; function To(t) { var e = t && t.constructor, n = typeof e == "function" && e.prototype || So; return t === n } const Io = To; var Mo = te(Object.keys, Object); const Bo = Mo; var Lo = Object.prototype; var No = Lo.hasOwnProperty; function zo(t) { if (!Io(t)) { return Bo(t) } var e = []; for (var n in Object(t)) { if (No.call(t, n) && n != "constructor") { e.push(n) } } return e } const Po = zo; function Oo(t) { return t != null && Ri(t.length) && !He(t) } const Ro = Oo; function Vo(t) { return Ro(t) ? Do(t) : Po(t) } const jo = Vo; function Fo(t, e) { return t && hi(e, jo(e), t) } const Ho = Fo; function Uo(t) { var e = []; if (t != null) { for (var n in Object(t)) { e.push(n) } } return e } const Wo = Uo; var qo = Object.prototype; var Go = qo.hasOwnProperty; function $o(t) { if (!nt(t)) { return Wo(t) } var e = Io(t), n = []; for (var i in t) { if (!(i == "constructor" && (e || !Go.call(t, i)))) { n.push(i) } } return n } const Ko = $o; function Yo(t) { return Ro(t) ? Do(t, true) : Ko(t) } const Qo = Yo; function Zo(t, e) { return t && hi(e, Qo(e), t) } const Jo = Zo; var Xo = typeof exports == "object" && exports && !exports.nodeType && exports; var tr = Xo && typeof module == "object" && module && !module.nodeType && module; var er = tr && tr.exports === Xo; var nr = er ? Dt.Buffer : undefined, ir = nr ? nr.allocUnsafe : undefined; function or(t, e) { if (e) { return t.slice() } var n = t.length, i = ir ? ir(n) : new t.constructor(n); t.copy(i); return i } const rr = or; function sr(t, e) { var n = -1, i = t.length; e || (e = Array(i)); while (++n < i) { e[n] = t[n] } return e } const ar = sr; function cr(t, e) { var n = -1, i = t == null ? 0 : t.length, o = 0, r = []; while (++n < i) { var s = t[n]; if (e(s, n, t)) { r[o++] = s } } return r } const lr = cr; function dr() { return [] } const ur = dr; var hr = Object.prototype; var gr = hr.propertyIsEnumerable; var mr = Object.getOwnPropertySymbols; var fr = !mr ? ur : function (t) { if (t == null) { return [] } t = Object(t); return lr(mr(t), (function (e) { return gr.call(t, e) })) }; const pr = fr; function br(t, e) { return hi(t, pr(t), e) } const kr = br; function wr(t, e) { var n = -1, i = e.length, o = t.length; while (++n < i) { t[o + n] = e[n] } return t } const Ar = wr; var _r = Object.getOwnPropertySymbols; var Cr = !_r ? ur : function (t) { var e = []; while (t) { Ar(e, pr(t)); t = ne(t) } return e }; const vr = Cr; function yr(t, e) { return hi(t, vr(t), e) } const xr = yr; function Er(t, e, n) { var i = e(t); return Gt(t) ? i : Ar(i, n(t)) } const Dr = Er; function Sr(t) { return Dr(t, jo, pr) } const Tr = Sr; function Ir(t) { return Dr(t, Qo, vr) } const Mr = Ir; var Br = un(Dt, "DataView"); const Lr = Br; var Nr = un(Dt, "Promise"); const zr = Nr; var Pr = un(Dt, "Set"); const Or = Pr; var Rr = un(Dt, "WeakMap"); const Vr = Rr; var jr = "[object Map]", Fr = "[object Object]", Hr = "[object Promise]", Ur = "[object Set]", Wr = "[object WeakMap]"; var qr = "[object DataView]"; var Gr = Ze(Lr), $r = Ze(gn), Kr = Ze(zr), Yr = Ze(Or), Qr = Ze(Vr); var Zr = Wt; if (Lr && Zr(new Lr(new ArrayBuffer(1))) != qr || gn && Zr(new gn) != jr || zr && Zr(zr.resolve()) != Hr || Or && Zr(new Or) != Ur || Vr && Zr(new Vr) != Wr) { Zr = function (t) { var e = Wt(t), n = e == Fr ? t.constructor : undefined, i = n ? Ze(n) : ""; if (i) { switch (i) { case Gr: return qr; case $r: return jr; case Kr: return Hr; case Yr: return Ur; case Qr: return Wr } } return e } } const Jr = Zr; var Xr = Object.prototype; var ts = Xr.hasOwnProperty; function es(t) { var e = t.length, n = new t.constructor(e); if (e && typeof t[0] == "string" && ts.call(t, "index")) { n.index = t.index; n.input = t.input } return n } const ns = es; var is = Dt.Uint8Array; const os = is; function rs(t) { var e = new t.constructor(t.byteLength); new os(e).set(new os(t)); return e } const ss = rs; function as(t, e) { var n = e ? ss(t.buffer) : t.buffer; return new t.constructor(n, t.byteOffset, t.byteLength) } const cs = as; var ls = /\w*$/; function ds(t) { var e = new t.constructor(t.source, ls.exec(t)); e.lastIndex = t.lastIndex; return e } const us = ds; var hs = Tt ? Tt.prototype : undefined, gs = hs ? hs.valueOf : undefined; function ms(t) { return gs ? Object(gs.call(t)) : {} } const fs = ms; function ps(t, e) { var n = e ? ss(t.buffer) : t.buffer; return new t.constructor(n, t.byteOffset, t.length) } const bs = ps; var ks = "[object Boolean]", ws = "[object Date]", As = "[object Map]", _s = "[object Number]", Cs = "[object RegExp]", vs = "[object Set]", ys = "[object String]", xs = "[object Symbol]"; var Es = "[object ArrayBuffer]", Ds = "[object DataView]", Ss = "[object Float32Array]", Ts = "[object Float64Array]", Is = "[object Int8Array]", Ms = "[object Int16Array]", Bs = "[object Int32Array]", Ls = "[object Uint8Array]", Ns = "[object Uint8ClampedArray]", zs = "[object Uint16Array]", Ps = "[object Uint32Array]"; function Os(t, e, n) { var i = t.constructor; switch (e) { case Es: return ss(t); case ks: case ws: return new i(+t); case Ds: return cs(t, n); case Ss: case Ts: case Is: case Ms: case Bs: case Ls: case Ns: case zs: case Ps: return bs(t, n); case As: return new i; case _s: case ys: return new i(t); case Cs: return us(t); case vs: return new i; case xs: return fs(t) } } const Rs = Os; var Vs = Object.create; var js = function () { function t() { } return function (e) { if (!nt(e)) { return {} } if (Vs) { return Vs(e) } t.prototype = e; var n = new t; t.prototype = undefined; return n } }(); const Fs = js; function Hs(t) { return typeof t.constructor == "function" && !Io(t) ? Fs(ne(t)) : {} } const Us = Hs; var Ws = "[object Map]"; function qs(t) { return Kt(t) && Jr(t) == Ws } const Gs = qs; var $s = Ao && Ao.isMap; var Ks = $s ? mo($s) : Gs; const Ys = Ks; var Qs = "[object Set]"; function Zs(t) { return Kt(t) && Jr(t) == Qs } const Js = Zs; var Xs = Ao && Ao.isSet; var ta = Xs ? mo(Xs) : Js; const ea = ta; var na = 1, ia = 2, oa = 4; var ra = "[object Arguments]", sa = "[object Array]", aa = "[object Boolean]", ca = "[object Date]", la = "[object Error]", da = "[object Function]", ua = "[object GeneratorFunction]", ha = "[object Map]", ga = "[object Number]", ma = "[object Object]", fa = "[object RegExp]", pa = "[object Set]", ba = "[object String]", ka = "[object Symbol]", wa = "[object WeakMap]"; var Aa = "[object ArrayBuffer]", _a = "[object DataView]", Ca = "[object Float32Array]", va = "[object Float64Array]", ya = "[object Int8Array]", xa = "[object Int16Array]", Ea = "[object Int32Array]", Da = "[object Uint8Array]", Sa = "[object Uint8ClampedArray]", Ta = "[object Uint16Array]", Ia = "[object Uint32Array]"; var Ma = {}; Ma[ra] = Ma[sa] = Ma[Aa] = Ma[_a] = Ma[aa] = Ma[ca] = Ma[Ca] = Ma[va] = Ma[ya] = Ma[xa] = Ma[Ea] = Ma[ha] = Ma[ga] = Ma[ma] = Ma[fa] = Ma[pa] = Ma[ba] = Ma[ka] = Ma[Da] = Ma[Sa] = Ma[Ta] = Ma[Ia] = true; Ma[la] = Ma[da] = Ma[wa] = false; function Ba(t, e, n, i, o, r) { var s, a = e & na, c = e & ia, l = e & oa; if (n) { s = o ? n(t, i, o, r) : n(t) } if (s !== undefined) { return s } if (!nt(t)) { return t } var d = Gt(t); if (d) { s = ns(t); if (!a) { return ar(t, s) } } else { var u = Jr(t), h = u == da || u == ua; if (Mi(t)) { return rr(t, a) } if (u == ma || u == ra || h && !o) { s = c || h ? {} : Us(t); if (!a) { return c ? xr(t, Jo(s, t)) : kr(t, Ho(s, t)) } } else { if (!Ma[u]) { return o ? t : {} } s = Rs(t, u, a) } } r || (r = new ti); var g = r.get(t); if (g) { return g } r.set(t, s); if (ea(t)) { t.forEach((function (i) { s.add(Ba(i, e, n, i, t, r)) })) } else if (Ys(t)) { t.forEach((function (i, o) { s.set(o, Ba(i, e, n, o, t, r)) })) } var m = l ? c ? Mr : Tr : c ? Qo : jo; var f = d ? undefined : m(t); ni(f || t, (function (i, o) { if (f) { o = i; i = t[o] } di(s, o, Ba(i, e, n, o, t, r)) })); return s } const La = Ba; var Na = 1, za = 4; function Pa(t, e) { e = typeof e == "function" ? e : undefined; return La(t, Na | za, e) } const Oa = Pa; function Ra(t) { return Kt(t) && t.nodeType === 1 && !de(t) } const Va = Ra; class ja { constructor(t, e) { this._config = {}; if (e) { this.define(Fa(e)) } if (t) { this._setObjectToTarget(this._config, t) } } set(t, e) { this._setToTarget(this._config, t, e) } define(t, e) { const n = true; this._setToTarget(this._config, t, e, n) } get(t) { return this._getFromSource(this._config, t) } *names() { for (const t of Object.keys(this._config)) { yield t } } _setToTarget(t, e, n, i = false) { if (de(e)) { this._setObjectToTarget(t, e, i); return } const o = e.split("."); e = o.pop(); for (const e of o) { if (!de(t[e])) { t[e] = {} } t = t[e] } if (de(n)) { if (!de(t[e])) { t[e] = {} } t = t[e]; this._setObjectToTarget(t, n, i); return } if (i && typeof t[e] != "undefined") { return } t[e] = n } _getFromSource(t, e) { const n = e.split("."); e = n.pop(); for (const e of n) { if (!de(t[e])) { t = null; break } t = t[e] } return t ? Fa(t[e]) : undefined } _setObjectToTarget(t, e, n) { Object.keys(e).forEach((i => { this._setToTarget(t, i, e[i], n) })) } } function Fa(t) { return Oa(t, Ha) } function Ha(t) { return Va(t) ? t : undefined } function Ua(t) { if (t) { if (t.defaultView) { return t instanceof t.defaultView.Document } else if (t.ownerDocument && t.ownerDocument.defaultView) { return t instanceof t.ownerDocument.defaultView.Node } } return false } function Wa(t) { const e = Object.prototype.toString.apply(t); if (e == "[object Window]") { return true } if (e == "[object global]") { return true } return false } const qa = Ga(U()); function Ga(t) { if (!t) { return qa } class e extends t { listenTo(t, e, n, i = {}) { if (Ua(t) || Wa(t)) { const o = { capture: !!i.useCapture, passive: !!i.usePassive }; const r = this._getProxyEmitter(t, o) || new $a(t, o); this.listenTo(r, e, n, i) } else { super.listenTo(t, e, n, i) } } stopListening(t, e, n) { if (Ua(t) || Wa(t)) { const i = this._getAllProxyEmitters(t); for (const t of i) { this.stopListening(t, e, n) } } else { super.stopListening(t, e, n) } } _getProxyEmitter(t, e) { return W(this, Ya(t, e)) } _getAllProxyEmitters(t) { return [{ capture: false, passive: false }, { capture: false, passive: true }, { capture: true, passive: false }, { capture: true, passive: true }].map((e => this._getProxyEmitter(t, e))).filter((t => !!t)) } } return e } ["_getProxyEmitter", "_getAllProxyEmitters", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t => { Ga[t] = qa.prototype[t] })); class $a extends (U()) { constructor(t, e) { super(); q(this, Ya(t, e)); this._domNode = t; this._options = e } attach(t) { if (this._domListeners && this._domListeners[t]) { return } const e = this._createDomListener(t); this._domNode.addEventListener(t, e, this._options); if (!this._domListeners) { this._domListeners = {} } this._domListeners[t] = e } detach(t) { let e; if (this._domListeners[t] && (!(e = this._events[t]) || !e.callbacks.length)) { this._domListeners[t].removeListener() } } _addEventListener(t, e, n) { this.attach(t); U().prototype._addEventListener.call(this, t, e, n) } _removeEventListener(t, e) { U().prototype._removeEventListener.call(this, t, e); this.detach(t) } _createDomListener(t) { const e = e => { this.fire(t, e) }; e.removeListener = () => { this._domNode.removeEventListener(t, e, this._options); delete this._domListeners[t] }; return e } } function Ka(t) { return t["data-ck-expando"] || (t["data-ck-expando"] = x()) } function Ya(t, e) { let n = Ka(t); for (const t of Object.keys(e).sort()) { if (e[t]) { n += "-" + t } } return n } let Qa; try { Qa = { window, document } } catch (t) { Qa = { window: {}, document: {} } } const Za = Qa; function Ja(t) { const e = []; let n = t; while (n && n.nodeType != Node.DOCUMENT_NODE) { e.unshift(n); n = n.parentNode } return e } function Xa(t) { if (t instanceof HTMLTextAreaElement) { return t.value } return t.innerHTML } function tc(t) { return Object.prototype.toString.call(t) == "[object Text]" } function ec(t) { return Object.prototype.toString.apply(t) == "[object Range]" } function nc(t) { const e = t.ownerDocument.defaultView.getComputedStyle(t); return { top: parseInt(e.borderTopWidth, 10), right: parseInt(e.borderRightWidth, 10), bottom: parseInt(e.borderBottomWidth, 10), left: parseInt(e.borderLeftWidth, 10) } } const ic = ["top", "right", "bottom", "left", "width", "height"]; class oc { constructor(t) { const e = ec(t); Object.defineProperty(this, "_source", { value: t._source || t, writable: true, enumerable: false }); if (ac(t) || e) { if (e) { const e = oc.getDomRangeRects(t); rc(this, oc.getBoundingRect(e)) } else { rc(this, t.getBoundingClientRect()) } } else if (Wa(t)) { const { innerWidth: e, innerHeight: n } = t; rc(this, { top: 0, right: e, bottom: n, left: 0, width: e, height: n }) } else { rc(this, t) } } clone() { return new oc(this) } moveTo(t, e) { this.top = e; this.right = t + this.width; this.bottom = e + this.height; this.left = t; return this } moveBy(t, e) { this.top += e; this.right += t; this.left += t; this.bottom += e; return this } getIntersection(t) { const e = { top: Math.max(this.top, t.top), right: Math.min(this.right, t.right), bottom: Math.min(this.bottom, t.bottom), left: Math.max(this.left, t.left), width: 0, height: 0 }; e.width = e.right - e.left; e.height = e.bottom - e.top; if (e.width < 0 || e.height < 0) { return null } else { return new oc(e) } } getIntersectionArea(t) { const e = this.getIntersection(t); if (e) { return e.getArea() } else { return 0 } } getArea() { return this.width * this.height } getVisible() { const t = this._source; let e = this.clone(); if (!sc(t)) { let n = t.parentNode || t.commonAncestorContainer; while (n && !sc(n)) { const t = new oc(n); const i = e.getIntersection(t); if (i) { if (i.getArea() < e.getArea()) { e = i } } else { return null } n = n.parentNode } } return e } isEqual(t) { for (const e of ic) { if (this[e] !== t[e]) { return false } } return true } contains(t) { const e = this.getIntersection(t); return !!(e && e.isEqual(t)) } excludeScrollbarsAndBorders() { const t = this._source; let e, n, i; if (Wa(t)) { e = t.innerWidth - t.document.documentElement.clientWidth; n = t.innerHeight - t.document.documentElement.clientHeight; i = t.getComputedStyle(t.document.documentElement).direction } else { const o = nc(t); e = t.offsetWidth - t.clientWidth - o.left - o.right; n = t.offsetHeight - t.clientHeight - o.top - o.bottom; i = t.ownerDocument.defaultView.getComputedStyle(t).direction; this.left += o.left; this.top += o.top; this.right -= o.right; this.bottom -= o.bottom; this.width = this.right - this.left; this.height = this.bottom - this.top } this.width -= e; if (i === "ltr") { this.right -= e } else { this.left += e } this.height -= n; this.bottom -= n; return this } static getDomRangeRects(t) { const e = []; const n = Array.from(t.getClientRects()); if (n.length) { for (const t of n) { e.push(new oc(t)) } } else { let n = t.startContainer; if (tc(n)) { n = n.parentNode } const i = new oc(n.getBoundingClientRect()); i.right = i.left; i.width = 0; e.push(i) } return e } static getBoundingRect(t) { const e = { left: Number.POSITIVE_INFINITY, top: Number.POSITIVE_INFINITY, right: Number.NEGATIVE_INFINITY, bottom: Number.NEGATIVE_INFINITY, width: 0, height: 0 }; let n = 0; for (const i of t) { n++; e.left = Math.min(e.left, i.left); e.top = Math.min(e.top, i.top); e.right = Math.max(e.right, i.right); e.bottom = Math.max(e.bottom, i.bottom) } if (n == 0) { return null } e.width = e.right - e.left; e.height = e.bottom - e.top; return new oc(e) } } function rc(t, e) { for (const n of ic) { t[n] = e[n] } } function sc(t) { if (!ac(t)) { return false } return t === t.ownerDocument.body } function ac(t) { return t !== null && typeof t === "object" && t.nodeType === 1 && typeof t.getBoundingClientRect === "function" } class cc { constructor(t, e) { if (!cc._observerInstance) { cc._createObserver() } this._element = t; this._callback = e; cc._addElementCallback(t, e); cc._observerInstance.observe(t) } destroy() { cc._deleteElementCallback(this._element, this._callback) } static _addElementCallback(t, e) { if (!cc._elementCallbacks) { cc._elementCallbacks = new Map } let n = cc._elementCallbacks.get(t); if (!n) { n = new Set; cc._elementCallbacks.set(t, n) } n.add(e) } static _deleteElementCallback(t, e) { const n = cc._getElementCallbacks(t); if (n) { n.delete(e); if (!n.size) { cc._elementCallbacks.delete(t); cc._observerInstance.unobserve(t) } } if (cc._elementCallbacks && !cc._elementCallbacks.size) { cc._observerInstance = null; cc._elementCallbacks = null } } static _getElementCallbacks(t) { if (!cc._elementCallbacks) { return null } return cc._elementCallbacks.get(t) } static _createObserver() { cc._observerInstance = new Za.window.ResizeObserver((t => { for (const e of t) { const t = cc._getElementCallbacks(e.target); if (t) { for (const n of t) { n(e) } } } })) } } cc._observerInstance = null; cc._elementCallbacks = null; function lc(t, e) { if (t instanceof HTMLTextAreaElement) { t.value = e } t.innerHTML = e } function dc(t) { return e => e + t } function uc(t) { let e = 0; while (t.previousSibling) { t = t.previousSibling; e++ } return e } function hc(t, e, n) { t.insertBefore(n, t.childNodes[e] || null) } function gc(t) { return t && t.nodeType === Node.COMMENT_NODE } function mc(t) { return !!(t && t.getClientRects && t.getClientRects().length) } function fc(t) { if (!t || !t.parentNode) { return null } if (t.offsetParent === Za.document.body) { return null } return t.offsetParent } function pc({ element: t, target: e, positions: n, limiter: i, fitInViewport: o, viewportOffsetConfig: r }) { if (He(e)) { e = e() } if (He(i)) { i = i() } const s = fc(t); const a = new oc(t); const c = new oc(e); let l; const d = o && bc(r) || null; const u = { targetRect: c, elementRect: a, positionedElementAncestor: s, viewportRect: d }; if (!i && !o) { l = new _c(n[0], u) } else { const t = i && new oc(i).getVisible(); Object.assign(u, { limiterRect: t, viewportRect: d }); l = kc(n, u) || new _c(n[0], u) } return l } function bc(t) { t = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, t); const e = new oc(Za.window); e.top += t.top; e.height -= t.top; e.bottom -= t.bottom; e.height -= t.bottom; return e } function kc(t, e) { const { elementRect: n } = e; const i = n.getArea(); const o = t.map((t => new _c(t, e))).filter((t => !!t.name)); let r = 0; let s = null; for (const t of o) { const { limiterIntersectionArea: e, viewportIntersectionArea: n } = t; if (e === i) { return t } const o = n ** 2 + e ** 2; if (o > r) { r = o; s = t } } return s } function wc(t, e) { const n = Ac(new oc(e)); const i = nc(e); let o = 0; let r = 0; o -= n.left; r -= n.top; o += e.scrollLeft; r += e.scrollTop; o -= i.left; r -= i.top; t.moveBy(o, r) } function Ac(t) { const { scrollX: e, scrollY: n } = Za.window; return t.clone().moveBy(e, n) } class _c { constructor(t, e) { const n = t(e.targetRect, e.elementRect, e.viewportRect); if (!n) { return } const { left: i, top: o, name: r, config: s } = n; this.name = r; this.config = s; this._positioningFunctionCorrdinates = { left: i, top: o }; this._options = e } get left() { return this._absoluteRect.left } get top() { return this._absoluteRect.top } get limiterIntersectionArea() { const t = this._options.limiterRect; if (t) { const e = this._options.viewportRect; if (e) { const n = t.getIntersection(e); if (n) { return n.getIntersectionArea(this._rect) } } else { return t.getIntersectionArea(this._rect) } } return 0 } get viewportIntersectionArea() { const t = this._options.viewportRect; if (t) { return t.getIntersectionArea(this._rect) } return 0 } get _rect() { if (this._cachedRect) { return this._cachedRect } this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCorrdinates.left, this._positioningFunctionCorrdinates.top); return this._cachedRect } get _absoluteRect() { if (this._cachedAbsoluteRect) { return this._cachedAbsoluteRect } this._cachedAbsoluteRect = Ac(this._rect); if (this._options.positionedElementAncestor) { wc(this._cachedAbsoluteRect, this._options.positionedElementAncestor) } return this._cachedAbsoluteRect } } function Cc(t) { const e = t.parentNode; if (e) { e.removeChild(t) } } function vc({ target: t, viewportOffset: e = 0, ancestorOffset: n = 0, alignToTop: i, forceScroll: o }) { const r = Mc(t); let s = r; let a = null; while (s) { let c; if (s == r) { c = Bc(t) } else { c = Bc(a) } Ec({ parent: c, getRect: () => Lc(t, s), alignToTop: i, ancestorOffset: n, forceScroll: o }); const l = Lc(t, s); xc({ window: s, rect: l, viewportOffset: e, alignToTop: i, forceScroll: o }); if (s.parent != s) { a = s.frameElement; s = s.parent; if (!a) { return } } else { s = null } } } function yc(t, e) { const n = Bc(t); Ec({ parent: n, getRect: () => new Rect(t), ancestorOffset: e }) } function xc({ window: t, rect: e, alignToTop: n, forceScroll: i, viewportOffset: o }) { const r = e.clone().moveBy(0, o); const s = e.clone().moveBy(0, -o); const a = new oc(t).excludeScrollbarsAndBorders(); const c = [s, r]; const l = n && i; const d = c.every((t => a.contains(t))); let { scrollX: u, scrollY: h } = t; const g = u; const m = h; if (l) { h -= a.top - e.top + o } else if (!d) { if (Sc(s, a)) { h -= a.top - e.top + o } else if (Dc(r, a)) { if (n) { h += e.top - a.top - o } else { h += e.bottom - a.bottom + o } } } if (!d) { if (Tc(e, a)) { u -= a.left - e.left + o } else if (Ic(e, a)) { u += e.right - a.right + o } } if (u != g || h !== m) { t.scrollTo(u, h) } } function Ec({ parent: t, getRect: e, alignToTop: n, forceScroll: i, ancestorOffset: o = 0 }) { const r = Mc(t); const s = n && i; let a, c, l; while (t != r.document.body) { c = e(); a = new oc(t).excludeScrollbarsAndBorders(); l = a.contains(c); if (s) { t.scrollTop -= a.top - c.top + o } else if (!l) { if (Sc(c, a)) { t.scrollTop -= a.top - c.top + o } else if (Dc(c, a)) { if (n) { t.scrollTop += c.top - a.top - o } else { t.scrollTop += c.bottom - a.bottom + o } } } if (!l) { if (Tc(c, a)) { t.scrollLeft -= a.left - c.left + o } else if (Ic(c, a)) { t.scrollLeft += c.right - a.right + o } } t = t.parentNode } } function Dc(t, e) { return t.bottom > e.bottom } function Sc(t, e) { return t.top < e.top } function Tc(t, e) { return t.left < e.left } function Ic(t, e) { return t.right > e.right } function Mc(t) { if (ec(t)) { return t.startContainer.ownerDocument.defaultView } else { return t.ownerDocument.defaultView } } function Bc(t) { if (ec(t)) { let e = t.commonAncestorContainer; if (tc(e)) { e = e.parentNode } return e } else { return t.parentNode } } function Lc(t, e) { const n = Mc(t); const i = new oc(t); if (n === e) { return i } else { let t = n; while (t != e) { const e = t.frameElement; const n = new oc(e).excludeScrollbarsAndBorders(); i.moveBy(n.left, n.top); t = t.parent } } return i } const Nc = { ctrl: "⌃", cmd: "⌘", alt: "⌥", shift: "⇧" }; const zc = { ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+" }; const Pc = qc(); const Oc = Object.fromEntries(Object.entries(Pc).map((([t, e]) => [e, t.charAt(0).toUpperCase() + t.slice(1)]))); function Rc(t) { let e; if (typeof t == "string") { e = Pc[t.toLowerCase()]; if (!e) { throw new I("keyboard-unknown-key", null, { key: t }) } } else { e = t.keyCode + (t.altKey ? Pc.alt : 0) + (t.ctrlKey ? Pc.ctrl : 0) + (t.shiftKey ? Pc.shift : 0) + (t.metaKey ? Pc.cmd : 0) } return e } function Vc(t) { if (typeof t == "string") { t = Gc(t) } return t.map((t => typeof t == "string" ? Uc(t) : t)).reduce(((t, e) => e + t), 0) } function jc(t) { let e = Vc(t); const n = Object.entries(r.isMac ? Nc : zc); const i = n.reduce(((t, [n, i]) => { if ((e & Pc[n]) != 0) { e &= ~Pc[n]; t += i } return t }), ""); return i + (e ? Oc[e] : "") } function Fc(t) { return t == Pc.arrowright || t == Pc.arrowleft || t == Pc.arrowup || t == Pc.arrowdown } function Hc(t, e) { const n = e === "ltr"; switch (t) { case Pc.arrowleft: return n ? "left" : "right"; case Pc.arrowright: return n ? "right" : "left"; case Pc.arrowup: return "up"; case Pc.arrowdown: return "down" } } function Uc(t) { if (t.endsWith("!")) { return Rc(t.slice(0, -1)) } const e = Rc(t); return r.isMac && e == Pc.ctrl ? Pc.cmd : e } function Wc(t, e) { const n = Hc(t, e); return n === "down" || n === "right" } function qc() { const t = { arrowleft: 37, arrowup: 38, arrowright: 39, arrowdown: 40, backspace: 8, delete: 46, enter: 13, space: 32, esc: 27, tab: 9, ctrl: 1114112, shift: 2228224, alt: 4456448, cmd: 8912896 }; for (let e = 65; e <= 90; e++) { const n = String.fromCharCode(e); t[n.toLowerCase()] = e } for (let e = 48; e <= 57; e++) { t[e - 48] = e } for (let e = 112; e <= 123; e++) { t["f" + (e - 111)] = e } for (const e of "`-=[];',./\\") { t[e] = e.charCodeAt(0) } return t } function Gc(t) { return t.split("+").map((t => t.trim())) } function $c(t) { return Array.isArray(t) ? t : [t] } if (!Za.window.CKEDITOR_TRANSLATIONS) { Za.window.CKEDITOR_TRANSLATIONS = {} } function Kc(t, e, n) { if (!global.window.CKEDITOR_TRANSLATIONS[t]) { global.window.CKEDITOR_TRANSLATIONS[t] = {} } const i = global.window.CKEDITOR_TRANSLATIONS[t]; i.dictionary = i.dictionary || {}; i.getPluralForm = n || i.getPluralForm; Object.assign(i.dictionary, e) } function Yc(t, e, n = 1) { if (typeof n !== "number") { throw new I("translation-service-quantity-not-a-number", null, { quantity: n }) } const i = Jc(); if (i === 1) { t = Object.keys(Za.window.CKEDITOR_TRANSLATIONS)[0] } const o = e.id || e.string; if (i === 0 || !Zc(t, o)) { if (n !== 1) { return e.plural } return e.string } const r = Za.window.CKEDITOR_TRANSLATIONS[t].dictionary; const s = Za.window.CKEDITOR_TRANSLATIONS[t].getPluralForm || (t => t === 1 ? 0 : 1); const a = r[o]; if (typeof a === "string") { return a } const c = Number(s(n)); return a[c] } function Qc() { global.window.CKEDITOR_TRANSLATIONS = {} } function Zc(t, e) { return !!Za.window.CKEDITOR_TRANSLATIONS[t] && !!Za.window.CKEDITOR_TRANSLATIONS[t].dictionary[e] } function Jc() { return Object.keys(Za.window.CKEDITOR_TRANSLATIONS).length } const Xc = ["ar", "ara", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig"]; function tl(t) { return Xc.includes(t) ? "rtl" : "ltr" } class el { constructor({ uiLanguage: t = "en", contentLanguage: e } = {}) { this.uiLanguage = t; this.contentLanguage = e || this.uiLanguage; this.uiLanguageDirection = tl(this.uiLanguage); this.contentLanguageDirection = tl(this.contentLanguage); this.t = (t, e) => this._t(t, e) } get language() { console.warn("locale-deprecated-language-property: " + "The Locale#language property has been deprecated and will be removed in the near future. " + "Please use #uiLanguage and #contentLanguage properties instead."); return this.uiLanguage } _t(t, e = []) { e = $c(e); if (typeof t === "string") { t = { string: t } } const n = !!t.plural; const i = n ? e[0] : 1; const o = Yc(this.uiLanguage, t, i); return nl(o, e) } } function nl(t, e) { return t.replace(/%(\d+)/g, ((t, n) => n < e.length ? e[n] : t)) } class il extends (U()) { constructor(t = {}, e = {}) { super(); const n = Ct(t); if (!n) { e = t } this._items = []; this._itemMap = new Map; this._idProperty = e.idProperty || "id"; this._bindToExternalToInternalMap = new WeakMap; this._bindToInternalToExternalMap = new WeakMap; this._skippedIndexesFromExternal = []; if (n) { for (const e of t) { this._items.push(e); this._itemMap.set(this._getItemIdBeforeAdding(e), e) } } } get length() { return this._items.length } get first() { return this._items[0] || null } get last() { return this._items[this.length - 1] || null } add(t, e) { return this.addMany([t], e) } addMany(t, e) { if (e === undefined) { e = this._items.length } else if (e > this._items.length || e < 0) { throw new I("collection-add-item-invalid-index", this) } let n = 0; for (const i of t) { const t = this._getItemIdBeforeAdding(i); const o = e + n; this._items.splice(o, 0, i); this._itemMap.set(t, i); this.fire("add", i, o); n++ } this.fire("change", { added: t, removed: [], index: e }); return this } get(t) { let e; if (typeof t == "string") { e = this._itemMap.get(t) } else if (typeof t == "number") { e = this._items[t] } else { throw new I("collection-get-invalid-arg", this) } return e || null } has(t) { if (typeof t == "string") { return this._itemMap.has(t) } else { const e = this._idProperty; const n = t[e]; return n && this._itemMap.has(n) } } getIndex(t) { let e; if (typeof t == "string") { e = this._itemMap.get(t) } else { e = t } return e ? this._items.indexOf(e) : -1 } remove(t) { const [e, n] = this._remove(t); this.fire("change", { added: [], removed: [e], index: n }); return e } map(t, e) { return this._items.map(t, e) } find(t, e) { return this._items.find(t, e) } filter(t, e) { return this._items.filter(t, e) } clear() { if (this._bindToCollection) { this.stopListening(this._bindToCollection); this._bindToCollection = null } const t = Array.from(this._items); while (this.length) { this._remove(0) } this.fire("change", { added: [], removed: t, index: 0 }) } bindTo(t) { if (this._bindToCollection) { throw new I("collection-bind-to-rebind", this) } this._bindToCollection = t; return { as: t => { this._setUpBindToBinding((e => new t(e))) }, using: t => { if (typeof t == "function") { this._setUpBindToBinding(t) } else { this._setUpBindToBinding((e => e[t])) } } } } _setUpBindToBinding(t) { const e = this._bindToCollection; const n = (n, i, o) => { const r = e._bindToCollection == this; const s = e._bindToInternalToExternalMap.get(i); if (r && s) { this._bindToExternalToInternalMap.set(i, s); this._bindToInternalToExternalMap.set(s, i) } else { const n = t(i); if (!n) { this._skippedIndexesFromExternal.push(o); return } let r = o; for (const t of this._skippedIndexesFromExternal) { if (o > t) { r-- } } for (const t of e._skippedIndexesFromExternal) { if (r >= t) { r++ } } this._bindToExternalToInternalMap.set(i, n); this._bindToInternalToExternalMap.set(n, i); this.add(n, r); for (let t = 0; t < e._skippedIndexesFromExternal.length; t++) { if (r <= e._skippedIndexesFromExternal[t]) { e._skippedIndexesFromExternal[t]++ } } } }; for (const t of e) { n(null, t, e.getIndex(t)) } this.listenTo(e, "add", n); this.listenTo(e, "remove", ((t, e, n) => { const i = this._bindToExternalToInternalMap.get(e); if (i) { this.remove(i) } this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce(((t, e) => { if (n < e) { t.push(e - 1) } if (n > e) { t.push(e) } return t }), []) })) } _getItemIdBeforeAdding(t) { const e = this._idProperty; let n; if (e in t) { n = t[e]; if (typeof n != "string") { throw new I("collection-add-invalid-id", this) } if (this.get(n)) { throw new I("collection-add-item-already-exists", this) } } else { t[e] = n = x() } return n } _remove(t) { let e, n, i; let o = false; const r = this._idProperty; if (typeof t == "string") { n = t; i = this._itemMap.get(n); o = !i; if (i) { e = this._items.indexOf(i) } } else if (typeof t == "number") { e = t; i = this._items[e]; o = !i; if (i) { n = i[r] } } else { i = t; n = i[r]; e = this._items.indexOf(i); o = e == -1 || !this._itemMap.get(n) } if (o) { throw new I("collection-remove-404", this) } this._items.splice(e, 1); this._itemMap.delete(n); const s = this._bindToInternalToExternalMap.get(i); this._bindToInternalToExternalMap.delete(i); this._bindToExternalToInternalMap.delete(s); this.fire("remove", i, e); return [i, e] } [Symbol.iterator]() { return this._items[Symbol.iterator]() } } function ol(t) { const e = t.next(); if (e.done) { return null } return e.value } class rl extends (Ga(lt())) { constructor() { super(); this._elements = new Set; this._nextEventLoopTimeout = null; this.set("isFocused", false); this.set("focusedElement", null) } add(t) { if (this._elements.has(t)) { throw new I("focustracker-add-element-already-exist", this) } this.listenTo(t, "focus", (() => this._focus(t)), { useCapture: true }); this.listenTo(t, "blur", (() => this._blur()), { useCapture: true }); this._elements.add(t) } remove(t) { if (t === this.focusedElement) { this._blur() } if (this._elements.has(t)) { this.stopListening(t); this._elements.delete(t) } } destroy() { this.stopListening() } _focus(t) { clearTimeout(this._nextEventLoopTimeout); this.focusedElement = t; this.isFocused = true } _blur() { clearTimeout(this._nextEventLoopTimeout); this._nextEventLoopTimeout = setTimeout((() => { this.focusedElement = null; this.isFocused = false }), 0) } } class sl { constructor() { this._listener = new (Ga()) } listenTo(t) { this._listener.listenTo(t, "keydown", ((t, e) => { this._listener.fire("_keydown:" + Rc(e), e) })) } set(t, e, n = {}) { const i = Vc(t); const o = n.priority; this._listener.listenTo(this._listener, "_keydown:" + i, ((t, n) => { e(n, (() => { n.preventDefault(); n.stopPropagation(); t.stop() })); t.return = true }), { priority: o }) } press(t) { return !!this._listener.fire("_keydown:" + Rc(t), t) } stopListening(t) { this._listener.stopListening(t) } destroy() { this.stopListening() } } function al(t) { const e = new Map; for (const n in t) { e.set(n, t[n]) } return e } function cl(t) { if (Ct(t)) { return new Map(t) } else { return al(t) } } const ll = 1e4; function dl(t, e, n, i) { if (Math.max(e.length, t.length) > ll) { return t.slice(0, n).concat(e).concat(t.slice(n + i, t.length)) } else { const o = Array.from(t); o.splice(n, i, ...e); return o } } function ul(t) { return !!t && t.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(t) } function hl(t) { return !!t && t.length == 1 && /[\ud800-\udbff]/.test(t) } function gl(t) { return !!t && t.length == 1 && /[\udc00-\udfff]/.test(t) } function ml(t, e) { return hl(t.charAt(e - 1)) && gl(t.charAt(e)) } function fl(t, e) { return ul(t.charAt(e)) } const pl = kl(); function bl(t, e) { const n = String(t).matchAll(pl); return Array.from(n).some((t => t.index < e && e < t.index + t[0].length)) } function kl() { const t = [/\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u, /\p{Emoji}\u{FE0F}?\u{20E3}/u, /\p{Emoji}\u{FE0F}/u, /(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u]; const e = /\p{Regional_Indicator}{2}/u.source; const n = "(?:" + t.map((t => t.source)).join("|") + ")"; const i = `${e}|${n}(?:‍${n})*`; return new RegExp(i, "ug") } class wl extends (lt()) { constructor(t) { super(); this._disableStack = new Set; this.editor = t; this.set("isEnabled", true) } forceDisabled(t) { this._disableStack.add(t); if (this._disableStack.size == 1) { this.on("set:isEnabled", Al, { priority: "highest" }); this.isEnabled = false } } clearForceDisabled(t) { this._disableStack.delete(t); if (this._disableStack.size == 0) { this.off("set:isEnabled", Al); this.isEnabled = true } } destroy() { this.stopListening() } static get isContextPlugin() { return false } } function Al(t) { t.return = false; t.stop() } class _l extends (lt()) { constructor(t) { super(); this.editor = t; this.set("value", undefined); this.set("isEnabled", false); this._affectsData = true; this._disableStack = new Set; this.decorate("execute"); this.listenTo(this.editor.model.document, "change", (() => { this.refresh() })); this.on("execute", (t => { if (!this.isEnabled) { t.stop() } }), { priority: "high" }); this.listenTo(t, "change:isReadOnly", ((t, e, n) => { if (n && this.affectsData) { this.forceDisabled("readOnlyMode") } else { this.clearForceDisabled("readOnlyMode") } })) } get affectsData() { return this._affectsData } set affectsData(t) { this._affectsData = t } refresh() { this.isEnabled = true } forceDisabled(t) { this._disableStack.add(t); if (this._disableStack.size == 1) { this.on("set:isEnabled", Cl, { priority: "highest" }); this.isEnabled = false } } clearForceDisabled(t) { this._disableStack.delete(t); if (this._disableStack.size == 0) { this.off("set:isEnabled", Cl); this.refresh() } } execute(...t) { return undefined } destroy() { this.stopListening() } } function Cl(t) { t.return = false; t.stop() } class vl extends _l { constructor() { super(...arguments); this._childCommandsDefinitions = [] } refresh() { } execute(...t) { const e = this._getFirstEnabledCommand(); return !!e && e.execute(t) } registerChildCommand(t, e = {}) { S(this._childCommandsDefinitions, { command: t, priority: e.priority || "normal" }); t.on("change:isEnabled", (() => this._checkEnabled())); this._checkEnabled() } _checkEnabled() { this.isEnabled = !!this._getFirstEnabledCommand() } _getFirstEnabledCommand() { const t = this._childCommandsDefinitions.find((({ command: t }) => t.isEnabled)); return t && t.command } } class yl extends (U()) { constructor(t, e = [], n = []) { super(); this._plugins = new Map; this._context = t; this._availablePlugins = new Map; for (const t of e) { if (t.pluginName) { this._availablePlugins.set(t.pluginName, t) } } this._contextPlugins = new Map; for (const [t, e] of n) { this._contextPlugins.set(t, e); this._contextPlugins.set(e, t); if (t.pluginName) { this._availablePlugins.set(t.pluginName, t) } } } *[Symbol.iterator]() { for (const t of this._plugins) { if (typeof t[0] == "function") { yield t } } } get(t) { const e = this._plugins.get(t); if (!e) { let e = t; if (typeof t == "function") { e = t.pluginName || t.name } throw new I("plugincollection-plugin-not-loaded", this._context, { plugin: e }) } return e } has(t) { return this._plugins.has(t) } init(t, e = [], n = []) { const i = this; const o = this._context; h(t); m(t); const r = t.filter((t => !d(t, e))); const s = [...g(r)]; A(s, n); const a = k(s); return w(a, "init").then((() => w(a, "afterInit"))).then((() => a)); function c(t) { return typeof t === "function" } function l(t) { return c(t) && !!t.isContextPlugin } function d(t, e) { return e.some((e => { if (e === t) { return true } if (u(t) === e) { return true } if (u(e) === t) { return true } return false })) } function u(t) { return c(t) ? t.pluginName || t.name : t } function h(t, e = new Set) { t.forEach((t => { if (!c(t)) { return } if (e.has(t)) { return } e.add(t); if (t.pluginName && !i._availablePlugins.has(t.pluginName)) { i._availablePlugins.set(t.pluginName, t) } if (t.requires) { h(t.requires, e) } })) } function g(t, e = new Set) { return t.map((t => c(t) ? t : i._availablePlugins.get(t))).reduce(((t, n) => { if (e.has(n)) { return t } e.add(n); if (n.requires) { m(n.requires, n); g(n.requires, e).forEach((e => t.add(e))) } return t.add(n) }), new Set) } function m(t, e = null) { t.map((t => c(t) ? t : i._availablePlugins.get(t) || t)).forEach((t => { f(t, e); p(t, e); b(t, e) })) } function f(t, e) { if (c(t)) { return } if (e) { throw new I("plugincollection-soft-required", o, { missingPlugin: t, requiredBy: u(e) }) } throw new I("plugincollection-plugin-not-found", o, { plugin: t }) } function p(t, e) { if (!l(e)) { return } if (l(t)) { return } throw new I("plugincollection-context-required", o, { plugin: u(t), requiredBy: u(e) }) } function b(t, n) { if (!n) { return } if (!d(t, e)) { return } throw new I("plugincollection-required", o, { plugin: u(t), requiredBy: u(n) }) } function k(t) { return t.map((t => { let e = i._contextPlugins.get(t); e = e || new t(o); i._add(t, e); return e })) } function w(t, e) { return t.reduce(((t, n) => { if (!n[e]) { return t } if (i._contextPlugins.has(n)) { return t } return t.then(n[e].bind(n)) }), Promise.resolve()) } function A(t, e) { for (const n of e) { if (typeof n != "function") { throw new I("plugincollection-replace-plugin-invalid-type", null, { pluginItem: n }) } const e = n.pluginName; if (!e) { throw new I("plugincollection-replace-plugin-missing-name", null, { pluginItem: n }) } if (n.requires && n.requires.length) { throw new I("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, { pluginName: e }) } const o = i._availablePlugins.get(e); if (!o) { throw new I("plugincollection-plugin-for-replacing-not-exist", null, { pluginName: e }) } const r = t.indexOf(o); if (r === -1) { if (i._contextPlugins.has(o)) { return } throw new I("plugincollection-plugin-for-replacing-not-loaded", null, { pluginName: e }) } if (o.requires && o.requires.length) { throw new I("plugincollection-replaced-plugin-cannot-have-dependencies", null, { pluginName: e }) } t.splice(r, 1, n); i._availablePlugins.set(e, n) } } } destroy() { const t = []; for (const [, e] of this) { if (typeof e.destroy == "function" && !this._contextPlugins.has(e)) { t.push(e.destroy()) } } return Promise.all(t) } _add(t, e) { this._plugins.set(t, e); const n = t.pluginName; if (!n) { return } if (this._plugins.has(n)) { throw new I("plugincollection-plugin-name-conflict", null, { pluginName: n, plugin1: this._plugins.get(n).constructor, plugin2: t }) } this._plugins.set(n, e) } } class xl { constructor(t) { this._contextOwner = null; this.config = new ja(t, this.constructor.defaultConfig); const e = this.constructor.builtinPlugins; this.config.define("plugins", e); this.plugins = new yl(this, e); const n = this.config.get("language") || {}; this.locale = new el({ uiLanguage: typeof n === "string" ? n : n.ui, contentLanguage: this.config.get("language.content") }); this.t = this.locale.t; this.editors = new il } initPlugins() { const t = this.config.get("plugins") || []; const e = this.config.get("substitutePlugins") || []; for (const n of t.concat(e)) { if (typeof n != "function") { throw new I("context-initplugins-constructor-only", null, { Plugin: n }) } if (n.isContextPlugin !== true) { throw new I("context-initplugins-invalid-plugin", null, { Plugin: n }) } } return this.plugins.init(t, [], e) } destroy() { return Promise.all(Array.from(this.editors, (t => t.destroy()))).then((() => this.plugins.destroy())) } _addEditor(t, e) { if (this._contextOwner) { throw new I("context-addeditor-private-context") } this.editors.add(t); if (e) { this._contextOwner = t } } _removeEditor(t) { if (this.editors.has(t)) { this.editors.remove(t) } if (this._contextOwner === t) { return this.destroy() } return Promise.resolve() } _getEditorConfig() { const t = {}; for (const e of this.config.names()) { if (!["plugins", "removePlugins", "extraPlugins"].includes(e)) { t[e] = this.config.get(e) } } return t } static create(t) { return new Promise((e => { const n = new this(t); e(n.initPlugins().then((() => n))) })) } } class El extends (lt()) { constructor(t) { super(); this.context = t } destroy() { this.stopListening() } static get isContextPlugin() { return true } } var Dl = n(3379); var Sl = n.n(Dl); var Tl = n(8894); var Il = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Il.insert = "head"; Il.singleton = true; var Ml = Sl()(Tl.Z, Il); const Bl = Tl.Z.locals || {}; const Ll = new WeakMap; function Nl({ view: t, element: e, text: n, isDirectHost: i = true, keepOnFocus: o = false }) { const r = t.document; if (!Ll.has(r)) { Ll.set(r, new Map); r.registerPostFixer((t => Vl(r, t))); r.on("change:isComposing", (() => { t.change((t => Vl(r, t))) }), { priority: "high" }) } Ll.get(r).set(e, { text: n, isDirectHost: i, keepOnFocus: o, hostElement: i ? e : null }); t.change((t => Vl(r, t))) } function zl(t, e) { const n = e.document; if (!Ll.has(n)) { return } t.change((t => { const i = Ll.get(n); const o = i.get(e); t.removeAttribute("data-placeholder", o.hostElement); Ol(t, o.hostElement); i.delete(e) })) } function Pl(t, e) { if (!e.hasClass("ck-placeholder")) { t.addClass("ck-placeholder", e); return true } return false } function Ol(t, e) { if (e.hasClass("ck-placeholder")) { t.removeClass("ck-placeholder", e); return true } return false } function Rl(t, e) { if (!t.isAttached()) { return false } const n = Array.from(t.getChildren()).some((t => !t.is("uiElement"))); if (n) { return false } const i = t.document; const o = i.selection; const r = o.anchor; if (i.isComposing && r && r.parent === t) { return false } if (e) { return true } if (!i.isFocused) { return true } return !!r && r.parent !== t } function Vl(t, e) { const n = Ll.get(t); const i = []; let o = false; for (const [t, r] of n) { if (r.isDirectHost) { i.push(t); if (jl(e, t, r)) { o = true } } } for (const [t, r] of n) { if (r.isDirectHost) { continue } const n = Fl(t); if (!n) { continue } if (i.includes(n)) { continue } r.hostElement = n; if (jl(e, t, r)) { o = true } } return o } function jl(t, e, n) { const { text: i, isDirectHost: o, hostElement: r } = n; let s = false; if (r.getAttribute("data-placeholder") !== i) { t.setAttribute("data-placeholder", i, r); s = true } const a = o || e.childCount == 1; if (a && Rl(r, n.keepOnFocus)) { if (Pl(t, r)) { s = true } } else if (Ol(t, r)) { s = true } return s } function Fl(t) { if (t.childCount) { const e = t.getChild(0); if (e.is("element") && !e.is("uiElement") && !e.is("attributeElement")) { return e } } return null } class Hl { is() { throw new Error("is() method is abstract") } } var Ul = 4; function Wl(t) { return La(t, Ul) } const ql = Wl; class Gl extends (U(Hl)) { constructor(t) { super(); this.document = t; this.parent = null } get index() { let t; if (!this.parent) { return null } if ((t = this.parent.getChildIndex(this)) == -1) { throw new I("view-node-not-found-in-parent", this) } return t } get nextSibling() { const t = this.index; return t !== null && this.parent.getChild(t + 1) || null } get previousSibling() { const t = this.index; return t !== null && this.parent.getChild(t - 1) || null } get root() { let t = this; while (t.parent) { t = t.parent } return t } isAttached() { return this.root.is("rootElement") } getPath() { const t = []; let e = this; while (e.parent) { t.unshift(e.index); e = e.parent } return t } getAncestors(t = {}) { const e = []; let n = t.includeSelf ? this : this.parent; while (n) { e[t.parentFirst ? "push" : "unshift"](n); n = n.parent } return e } getCommonAncestor(t, e = {}) { const n = this.getAncestors(e); const i = t.getAncestors(e); let o = 0; while (n[o] == i[o] && n[o]) { o++ } return o === 0 ? null : n[o - 1] } isBefore(t) { if (this == t) { return false } if (this.root !== t.root) { return false } const e = this.getPath(); const n = t.getPath(); const i = _t(e, n); switch (i) { case "prefix": return true; case "extension": return false; default: return e[i] < n[i] } } isAfter(t) { if (this == t) { return false } if (this.root !== t.root) { return false } return !this.isBefore(t) } _remove() { this.parent._removeChildren(this.index) } _fireChange(t, e) { this.fire(`change:${t}`, e); if (this.parent) { this.parent._fireChange(t, e) } } toJSON() { const t = ql(this); delete t.parent; return t } } Gl.prototype.is = function (t) { return t === "node" || t === "view:node" }; class $l extends Gl { constructor(t, e) { super(t); this._textData = e } get data() { return this._textData } get _data() { return this.data } set _data(t) { this._fireChange("text", this); this._textData = t } isSimilar(t) { if (!(t instanceof $l)) { return false } return this === t || this.data === t.data } _clone() { return new $l(this.document, this.data) } } $l.prototype.is = function (t) { return t === "$text" || t === "view:$text" || t === "text" || t === "view:text" || t === "node" || t === "view:node" }; class Kl extends Hl { constructor(t, e, n) { super(); this.textNode = t; if (e < 0 || e > t.data.length) { throw new I("view-textproxy-wrong-offsetintext", this) } if (n < 0 || e + n > t.data.length) { throw new I("view-textproxy-wrong-length", this) } this.data = t.data.substring(e, e + n); this.offsetInText = e } get offsetSize() { return this.data.length } get isPartial() { return this.data.length !== this.textNode.data.length } get parent() { return this.textNode.parent } get root() { return this.textNode.root } get document() { return this.textNode.document } getAncestors(t = {}) { const e = []; let n = t.includeSelf ? this.textNode : this.parent; while (n !== null) { e[t.parentFirst ? "push" : "unshift"](n); n = n.parent } return e } } Kl.prototype.is = function (t) { return t === "$textProxy" || t === "view:$textProxy" || t === "textProxy" || t === "view:textProxy" }; class Yl { constructor(...t) { this._patterns = []; this.add(...t) } add(...t) { for (let e of t) { if (typeof e == "string" || e instanceof RegExp) { e = { name: e } } this._patterns.push(e) } } match(...t) { for (const e of t) { for (const t of this._patterns) { const n = Ql(e, t); if (n) { return { element: e, pattern: t, match: n } } } } return null } matchAll(...t) { const e = []; for (const n of t) { for (const t of this._patterns) { const i = Ql(n, t); if (i) { e.push({ element: n, pattern: t, match: i }) } } } return e.length > 0 ? e : null } getElementName() { if (this._patterns.length !== 1) { return null } const t = this._patterns[0]; const e = t.name; return typeof t != "function" && e && !(e instanceof RegExp) ? e : null } } function Ql(t, e) { if (typeof e == "function") { return e(t) } const n = {}; if (e.name) { n.name = Zl(e.name, t.name); if (!n.name) { return null } } if (e.attributes) { n.attributes = nd(e.attributes, t); if (!n.attributes) { return null } } if (e.classes) { n.classes = id(e.classes, t); if (!n.classes) { return null } } if (e.styles) { n.styles = od(e.styles, t); if (!n.styles) { return null } } return n } function Zl(t, e) { if (t instanceof RegExp) { return !!e.match(t) } return t === e } function Jl(t, e, n) { const i = Xl(t); const o = Array.from(e); const r = []; i.forEach((([t, e]) => { o.forEach((i => { if (td(t, i) && ed(e, i, n)) { r.push(i) } })) })); if (!i.length || r.length < i.length) { return undefined } return r } function Xl(t) { if (Array.isArray(t)) { return t.map((t => { if (de(t)) { if (t.key === undefined || t.value === undefined) { M("matcher-pattern-missing-key-or-value", t) } return [t.key, t.value] } return [t, true] })) } if (de(t)) { return Object.entries(t) } return [[t, true]] } function td(t, e) { return t === true || t === e || t instanceof RegExp && e.match(t) } function ed(t, e, n) { if (t === true) { return true } const i = n(e); return t === i || t instanceof RegExp && !!String(i).match(t) } function nd(t, e) { const n = new Set(e.getAttributeKeys()); if (de(t)) { if (t.style !== undefined) { M("matcher-pattern-deprecated-attributes-style-key", t) } if (t.class !== undefined) { M("matcher-pattern-deprecated-attributes-class-key", t) } } else { n.delete("style"); n.delete("class") } return Jl(t, n, (t => e.getAttribute(t))) } function id(t, e) { return Jl(t, e.getClassNames(), (() => { })) } function od(t, e) { return Jl(t, e.getStyleNames(true), (t => e.getStyle(t))) } var rd = "[object Symbol]"; function sd(t) { return typeof t == "symbol" || Kt(t) && Wt(t) == rd } const ad = sd; var cd = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, ld = /^\w*$/; function dd(t, e) { if (Gt(t)) { return false } var n = typeof t; if (n == "number" || n == "symbol" || n == "boolean" || t == null || ad(t)) { return true } return ld.test(t) || !cd.test(t) || e != null && t in Object(e) } const ud = dd; var hd = "Expected a function"; function gd(t, e) { if (typeof t != "function" || e != null && typeof e != "function") { throw new TypeError(hd) } var n = function () { var i = arguments, o = e ? e.apply(this, i) : i[0], r = n.cache; if (r.has(o)) { return r.get(o) } var s = t.apply(this, i); n.cache = r.set(o, s) || r; return s }; n.cache = new (gd.Cache || Yn); return n } gd.Cache = Yn; const md = gd; var fd = 500; function pd(t) { var e = md(t, (function (t) { if (n.size === fd) { n.clear() } return t })); var n = e.cache; return e } const bd = pd; var kd = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g; var wd = /\\(\\)?/g; var Ad = bd((function (t) { var e = []; if (t.charCodeAt(0) === 46) { e.push("") } t.replace(kd, (function (t, n, i, o) { e.push(i ? o.replace(wd, "$1") : n || t) })); return e })); const _d = Ad; function Cd(t, e) { var n = -1, i = t == null ? 0 : t.length, o = Array(i); while (++n < i) { o[n] = e(t[n], n, t) } return o } const vd = Cd; var yd = 1 / 0; var xd = Tt ? Tt.prototype : undefined, Ed = xd ? xd.toString : undefined; function Dd(t) { if (typeof t == "string") { return t } if (Gt(t)) { return vd(t, Dd) + "" } if (ad(t)) { return Ed ? Ed.call(t) : "" } var e = t + ""; return e == "0" && 1 / t == -yd ? "-0" : e } const Sd = Dd; function Td(t) { return t == null ? "" : Sd(t) } const Id = Td; function Md(t, e) { if (Gt(t)) { return t } return ud(t, e) ? [t] : _d(Id(t)) } const Bd = Md; function Ld(t) { var e = t == null ? 0 : t.length; return e ? t[e - 1] : undefined } const Nd = Ld; var zd = 1 / 0; function Pd(t) { if (typeof t == "string" || ad(t)) { return t } var e = t + ""; return e == "0" && 1 / t == -zd ? "-0" : e } const Od = Pd; function Rd(t, e) { e = Bd(e, t); var n = 0, i = e.length; while (t != null && n < i) { t = t[Od(e[n++])] } return n && n == i ? t : undefined } const Vd = Rd; function jd(t, e, n) { var i = -1, o = t.length; if (e < 0) { e = -e > o ? 0 : o + e } n = n > o ? o : n; if (n < 0) { n += o } o = e > n ? 0 : n - e >>> 0; e >>>= 0; var r = Array(o); while (++i < o) { r[i] = t[i + e] } return r } const Fd = jd; function Hd(t, e) { return e.length < 2 ? t : Vd(t, Fd(e, 0, -1)) } const Ud = Hd; function Wd(t, e) { e = Bd(e, t); t = Ud(t, e); return t == null || delete t[Od(Nd(e))] } const qd = Wd; function Gd(t, e) { return t == null ? true : qd(t, e) } const $d = Gd; function Kd(t, e, n) { var i = t == null ? undefined : Vd(t, e); return i === undefined ? n : i } const Yd = Kd; function Qd(t, e, n) { if (n !== undefined && !me(t[e], n) || n === undefined && !(e in t)) { si(t, e, n) } } const Zd = Qd; function Jd(t) { return function (e, n, i) { var o = -1, r = Object(e), s = i(e), a = s.length; while (a--) { var c = s[t ? a : ++o]; if (n(r[c], c, r) === false) { break } } return e } } const Xd = Jd; var tu = Xd(); const eu = tu; function nu(t) { return Kt(t) && Ro(t) } const iu = nu; function ou(t, e) { if (e === "constructor" && typeof t[e] === "function") { return } if (e == "__proto__") { return } return t[e] } const ru = ou; function su(t) { return hi(t, Qo(t)) } const au = su; function cu(t, e, n, i, o, r, s) { var a = ru(t, n), c = ru(e, n), l = s.get(c); if (l) { Zd(t, n, l); return } var d = r ? r(a, c, n + "", t, e, s) : undefined; var u = d === undefined; if (u) { var h = Gt(c), g = !h && Mi(c), m = !h && !g && vo(c); d = c; if (h || g || m) { if (Gt(a)) { d = a } else if (iu(a)) { d = ar(a) } else if (g) { u = false; d = rr(c, true) } else if (m) { u = false; d = bs(c, true) } else { d = [] } } else if (de(c) || Ci(c)) { d = a; if (Ci(a)) { d = au(a) } else if (!nt(a) || He(a)) { d = Us(c) } } else { u = false } } if (u) { s.set(c, d); o(d, c, i, r, s); s["delete"](c) } Zd(t, n, d) } const lu = cu; function du(t, e, n, i, o) { if (t === e) { return } eu(e, (function (r, s) { o || (o = new ti); if (nt(r)) { lu(t, e, s, n, du, i, o) } else { var a = i ? i(ru(t, s), r, s + "", t, e, o) : undefined; if (a === undefined) { a = r } Zd(t, s, a) } }), Qo) } const uu = du; function hu(t) { return t } const gu = hu; function mu(t, e, n) { switch (n.length) { case 0: return t.call(e); case 1: return t.call(e, n[0]); case 2: return t.call(e, n[0], n[1]); case 3: return t.call(e, n[0], n[1], n[2]) }return t.apply(e, n) } const fu = mu; var pu = Math.max; function bu(t, e, n) { e = pu(e === undefined ? t.length - 1 : e, 0); return function () { var i = arguments, o = -1, r = pu(i.length - e, 0), s = Array(r); while (++o < r) { s[o] = i[e + o] } o = -1; var a = Array(e + 1); while (++o < e) { a[o] = i[o] } a[e] = n(s); return fu(t, this, a) } } const ku = bu; function wu(t) { return function () { return t } } const Au = wu; var _u = !oi ? gu : function (t, e) { return oi(t, "toString", { configurable: true, enumerable: false, value: Au(e), writable: true }) }; const Cu = _u; var vu = 800, yu = 16; var xu = Date.now; function Eu(t) { var e = 0, n = 0; return function () { var i = xu(), o = yu - (i - n); n = i; if (o > 0) { if (++e >= vu) { return arguments[0] } } else { e = 0 } return t.apply(undefined, arguments) } } const Du = Eu; var Su = Du(Cu); const Tu = Su; function Iu(t, e) { return Tu(ku(t, e, gu), t + "") } const Mu = Iu; function Bu(t, e, n) { if (!nt(n)) { return false } var i = typeof e; if (i == "number" ? Ro(n) && zi(e, n.length) : i == "string" && e in n) { return me(n[e], t) } return false } const Lu = Bu; function Nu(t) { return Mu((function (e, n) { var i = -1, o = n.length, r = o > 1 ? n[o - 1] : undefined, s = o > 2 ? n[2] : undefined; r = t.length > 3 && typeof r == "function" ? (o--, r) : undefined; if (s && Lu(n[0], n[1], s)) { r = o < 3 ? undefined : r; o = 1 } e = Object(e); while (++i < o) { var a = n[i]; if (a) { t(e, a, i, r) } } return e })) } const zu = Nu; var Pu = zu((function (t, e, n) { uu(t, e, n) })); const Ou = Pu; function Ru(t, e, n, i) { if (!nt(t)) { return t } e = Bd(e, t); var o = -1, r = e.length, s = r - 1, a = t; while (a != null && ++o < r) { var c = Od(e[o]), l = n; if (c === "__proto__" || c === "constructor" || c === "prototype") { return t } if (o != s) { var d = a[c]; l = i ? i(d, c, a) : undefined; if (l === undefined) { l = nt(d) ? d : zi(e[o + 1]) ? [] : {} } } di(a, c, l); a = a[c] } return t } const Vu = Ru; function ju(t, e, n) { return t == null ? t : Vu(t, e, n) } const Fu = ju; class Hu { constructor(t) { this._styles = {}; this._styleProcessor = t } get isEmpty() { const t = Object.entries(this._styles); const e = Array.from(t); return !e.length } get size() { if (this.isEmpty) { return 0 } return this.getStyleNames().length } setTo(t) { this.clear(); const e = Array.from(Wu(t).entries()); for (const [t, n] of e) { this._styleProcessor.toNormalizedForm(t, n, this._styles) } } has(t) { if (this.isEmpty) { return false } const e = this._styleProcessor.getReducedForm(t, this._styles); const n = e.find((([e]) => e === t)); return Array.isArray(n) } set(t, e) { if (nt(t)) { for (const [e, n] of Object.entries(t)) { this._styleProcessor.toNormalizedForm(e, n, this._styles) } } else { this._styleProcessor.toNormalizedForm(t, e, this._styles) } } remove(t) { const e = qu(t); $d(this._styles, e); delete this._styles[t]; this._cleanEmptyObjectsOnPath(e) } getNormalized(t) { return this._styleProcessor.getNormalized(t, this._styles) } toString() { if (this.isEmpty) { return "" } return this._getStylesEntries().map((t => t.join(":"))).sort().join(";") + ";" } getAsString(t) { if (this.isEmpty) { return } if (this._styles[t] && !nt(this._styles[t])) { return this._styles[t] } const e = this._styleProcessor.getReducedForm(t, this._styles); const n = e.find((([e]) => e === t)); if (Array.isArray(n)) { return n[1] } } getStyleNames(t = false) { if (this.isEmpty) { return [] } if (t) { return this._styleProcessor.getStyleNames(this._styles) } const e = this._getStylesEntries(); return e.map((([t]) => t)) } clear() { this._styles = {} } _getStylesEntries() { const t = []; const e = Object.keys(this._styles); for (const n of e) { t.push(...this._styleProcessor.getReducedForm(n, this._styles)) } return t } _cleanEmptyObjectsOnPath(t) { const e = t.split("."); const n = e.length > 1; if (!n) { return } const i = e.splice(0, e.length - 1).join("."); const o = Yd(this._styles, i); if (!o) { return } const r = !Array.from(Object.keys(o)).length; if (r) { this.remove(i) } } } class Uu { constructor() { this._normalizers = new Map; this._extractors = new Map; this._reducers = new Map; this._consumables = new Map } toNormalizedForm(t, e, n) { if (nt(e)) { Gu(n, qu(t), e); return } if (this._normalizers.has(t)) { const i = this._normalizers.get(t); const { path: o, value: r } = i(e); Gu(n, o, r) } else { Gu(n, t, e) } } getNormalized(t, e) { if (!t) { return Ou({}, e) } if (e[t] !== undefined) { return e[t] } if (this._extractors.has(t)) { const n = this._extractors.get(t); if (typeof n === "string") { return Yd(e, n) } const i = n(t, e); if (i) { return i } } return Yd(e, qu(t)) } getReducedForm(t, e) { const n = this.getNormalized(t, e); if (n === undefined) { return [] } if (this._reducers.has(t)) { const e = this._reducers.get(t); return e(n) } return [[t, n]] } getStyleNames(t) { const e = Array.from(this._consumables.keys()).filter((e => { const n = this.getNormalized(e, t); if (n && typeof n == "object") { return Object.keys(n).length } return n })); const n = new Set([...e, ...Object.keys(t)]); return Array.from(n.values()) } getRelatedStyles(t) { return this._consumables.get(t) || [] } setNormalizer(t, e) { this._normalizers.set(t, e) } setExtractor(t, e) { this._extractors.set(t, e) } setReducer(t, e) { this._reducers.set(t, e) } setStyleRelation(t, e) { this._mapStyleNames(t, e); for (const n of e) { this._mapStyleNames(n, [t]) } } _mapStyleNames(t, e) { if (!this._consumables.has(t)) { this._consumables.set(t, []) } this._consumables.get(t).push(...e) } } function Wu(t) { let e = null; let n = 0; let i = 0; let o = null; const r = new Map; if (t === "") { return r } if (t.charAt(t.length - 1) != ";") { t = t + ";" } for (let s = 0; s < t.length; s++) { const a = t.charAt(s); if (e === null) { switch (a) { case ":": if (!o) { o = t.substr(n, s - n); i = s + 1 } break; case '"': case "'": e = a; break; case ";": { const e = t.substr(i, s - i); if (o) { r.set(o.trim(), e.trim()) } o = null; n = s + 1; break } } } else if (a === e) { e = null } } return r } function qu(t) { return t.replace("-", ".") } function Gu(t, e, n) { let i = n; if (nt(n)) { i = Ou({}, Yd(t, e), n) } Fu(t, e, i) } class $u extends Gl { constructor(t, e, n, i) { super(t); this._unsafeAttributesToRender = []; this._customProperties = new Map; this.name = e; this._attrs = Ku(n); this._children = []; if (i) { this._insertChild(0, i) } this._classes = new Set; if (this._attrs.has("class")) { const t = this._attrs.get("class"); Yu(this._classes, t); this._attrs.delete("class") } this._styles = new Hu(this.document.stylesProcessor); if (this._attrs.has("style")) { this._styles.setTo(this._attrs.get("style")); this._attrs.delete("style") } } get childCount() { return this._children.length } get isEmpty() { return this._children.length === 0 } getChild(t) { return this._children[t] } getChildIndex(t) { return this._children.indexOf(t) } getChildren() { return this._children[Symbol.iterator]() } *getAttributeKeys() { if (this._classes.size > 0) { yield "class" } if (!this._styles.isEmpty) { yield "style" } yield* this._attrs.keys() } *getAttributes() { yield* this._attrs.entries(); if (this._classes.size > 0) { yield ["class", this.getAttribute("class")] } if (!this._styles.isEmpty) { yield ["style", this.getAttribute("style")] } } getAttribute(t) { if (t == "class") { if (this._classes.size > 0) { return [...this._classes].join(" ") } return undefined } if (t == "style") { const t = this._styles.toString(); return t == "" ? undefined : t } return this._attrs.get(t) } hasAttribute(t) { if (t == "class") { return this._classes.size > 0 } if (t == "style") { return !this._styles.isEmpty } return this._attrs.has(t) } isSimilar(t) { if (!(t instanceof $u)) { return false } if (this === t) { return true } if (this.name != t.name) { return false } if (this._attrs.size !== t._attrs.size || this._classes.size !== t._classes.size || this._styles.size !== t._styles.size) { return false } for (const [e, n] of this._attrs) { if (!t._attrs.has(e) || t._attrs.get(e) !== n) { return false } } for (const e of this._classes) { if (!t._classes.has(e)) { return false } } for (const e of this._styles.getStyleNames()) { if (!t._styles.has(e) || t._styles.getAsString(e) !== this._styles.getAsString(e)) { return false } } return true } hasClass(...t) { for (const e of t) { if (!this._classes.has(e)) { return false } } return true } getClassNames() { return this._classes.keys() } getStyle(t) { return this._styles.getAsString(t) } getNormalizedStyle(t) { return this._styles.getNormalized(t) } getStyleNames(t) { return this._styles.getStyleNames(t) } hasStyle(...t) { for (const e of t) { if (!this._styles.has(e)) { return false } } return true } findAncestor(...t) { const e = new Yl(...t); let n = this.parent; while (n && !n.is("documentFragment")) { if (e.match(n)) { return n } n = n.parent } return null } getCustomProperty(t) { return this._customProperties.get(t) } *getCustomProperties() { yield* this._customProperties.entries() } getIdentity() { const t = Array.from(this._classes).sort().join(","); const e = this._styles.toString(); const n = Array.from(this._attrs).map((t => `${t[0]}="${t[1]}"`)).sort().join(" "); return this.name + (t == "" ? "" : ` class="${t}"`) + (!e ? "" : ` style="${e}"`) + (n == "" ? "" : ` ${n}`) } shouldRenderUnsafeAttribute(t) { return this._unsafeAttributesToRender.includes(t) } _clone(t = false) { const e = []; if (t) { for (const n of this.getChildren()) { e.push(n._clone(t)) } } const n = new this.constructor(this.document, this.name, this._attrs, e); n._classes = new Set(this._classes); n._styles.set(this._styles.getNormalized()); n._customProperties = new Map(this._customProperties); n.getFillerOffset = this.getFillerOffset; n._unsafeAttributesToRender = this._unsafeAttributesToRender; return n } _appendChild(t) { return this._insertChild(this.childCount, t) } _insertChild(t, e) { this._fireChange("children", this); let n = 0; const i = Qu(this.document, e); for (const e of i) { if (e.parent !== null) { e._remove() } e.parent = this; e.document = this.document; this._children.splice(t, 0, e); t++; n++ } return n } _removeChildren(t, e = 1) { this._fireChange("children", this); for (let n = t; n < t + e; n++) { this._children[n].parent = null } return this._children.splice(t, e) } _setAttribute(t, e) { const n = String(e); this._fireChange("attributes", this); if (t == "class") { Yu(this._classes, n) } else if (t == "style") { this._styles.setTo(n) } else { this._attrs.set(t, n) } } _removeAttribute(t) { this._fireChange("attributes", this); if (t == "class") { if (this._classes.size > 0) { this._classes.clear(); return true } return false } if (t == "style") { if (!this._styles.isEmpty) { this._styles.clear(); return true } return false } return this._attrs.delete(t) } _addClass(t) { this._fireChange("attributes", this); for (const e of $c(t)) { this._classes.add(e) } } _removeClass(t) { this._fireChange("attributes", this); for (const e of $c(t)) { this._classes.delete(e) } } _setStyle(t, e) { this._fireChange("attributes", this); if (typeof t != "string") { this._styles.set(t) } else { this._styles.set(t, e) } } _removeStyle(t) { this._fireChange("attributes", this); for (const e of $c(t)) { this._styles.remove(e) } } _setCustomProperty(t, e) { this._customProperties.set(t, e) } _removeCustomProperty(t) { return this._customProperties.delete(t) } } $u.prototype.is = function (t, e) { if (!e) { return t === "element" || t === "view:element" || t === "node" || t === "view:node" } else { return e === this.name && (t === "element" || t === "view:element") } }; function Ku(t) { const e = cl(t); for (const [t, n] of e) { if (n === null) { e.delete(t) } else if (typeof n != "string") { e.set(t, String(n)) } } return e } function Yu(t, e) { const n = e.split(/\s+/); t.clear(); n.forEach((e => t.add(e))) } function Qu(t, e) { if (typeof e == "string") { return [new $l(t, e)] } if (!Ct(e)) { e = [e] } return Array.from(e).map((e => { if (typeof e == "string") { return new $l(t, e) } if (e instanceof Kl) { return new $l(t, e.data) } return e })) } class Zu extends $u { constructor(t, e, n, i) { super(t, e, n, i); this.getFillerOffset = Ju } } Zu.prototype.is = function (t, e) { if (!e) { return t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node" } else { return e === this.name && (t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element") } }; function Ju() { const t = [...this.getChildren()]; const e = t[this.childCount - 1]; if (e && e.is("element", "br")) { return this.childCount } for (const e of t) { if (!e.is("uiElement")) { return null } } return this.childCount } class Xu extends (lt(Zu)) { constructor(t, e, n, i) { super(t, e, n, i); this.set("isReadOnly", false); this.set("isFocused", false); this.bind("isReadOnly").to(t); this.bind("isFocused").to(t, "isFocused", (e => e && t.selection.editableElement == this)); this.listenTo(t.selection, "change", (() => { this.isFocused = t.isFocused && t.selection.editableElement == this })) } destroy() { this.stopListening() } } Xu.prototype.is = function (t, e) { if (!e) { return t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node" } else { return e === this.name && (t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element") } }; const th = Symbol("rootName"); class eh extends Xu { constructor(t, e) { super(t, e); this.rootName = "main" } get rootName() { return this.getCustomProperty(th) } set rootName(t) { this._setCustomProperty(th, t) } set _name(t) { this.name = t } } eh.prototype.is = function (t, e) { if (!e) { return t === "rootElement" || t === "view:rootElement" || t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node" } else { return e === this.name && (t === "rootElement" || t === "view:rootElement" || t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element") } }; class nh { constructor(t = {}) { if (!t.boundaries && !t.startPosition) { throw new I("view-tree-walker-no-start-position", null) } if (t.direction && t.direction != "forward" && t.direction != "backward") { throw new I("view-tree-walker-unknown-direction", t.startPosition, { direction: t.direction }) } this.boundaries = t.boundaries || null; if (t.startPosition) { this._position = ih._createAt(t.startPosition) } else { this._position = ih._createAt(t.boundaries[t.direction == "backward" ? "end" : "start"]) } this.direction = t.direction || "forward"; this.singleCharacters = !!t.singleCharacters; this.shallow = !!t.shallow; this.ignoreElementEnd = !!t.ignoreElementEnd; this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null; this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null } [Symbol.iterator]() { return this } get position() { return this._position } skip(t) { let e; let n; do { n = this.position; e = this.next() } while (!e.done && t(e.value)); if (!e.done) { this._position = n } } next() { if (this.direction == "forward") { return this._next() } else { return this._previous() } } _next() { let t = this.position.clone(); const e = this.position; const n = t.parent; if (n.parent === null && t.offset === n.childCount) { return { done: true, value: undefined } } if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset) { return { done: true, value: undefined } } let i; if (n instanceof $l) { if (t.isAtEnd) { this._position = ih._createAfter(n); return this._next() } i = n.data[t.offset] } else { i = n.getChild(t.offset) } if (i instanceof $u) { if (!this.shallow) { t = new ih(i, 0) } else { t.offset++ } this._position = t; return this._formatReturnValue("elementStart", i, e, t, 1) } else if (i instanceof $l) { if (this.singleCharacters) { t = new ih(i, 0); this._position = t; return this._next() } else { let n = i.data.length; let o; if (i == this._boundaryEndParent) { n = this.boundaries.end.offset; o = new Kl(i, 0, n); t = ih._createAfter(o) } else { o = new Kl(i, 0, i.data.length); t.offset++ } this._position = t; return this._formatReturnValue("text", o, e, t, n) } } else if (typeof i == "string") { let i; if (this.singleCharacters) { i = 1 } else { const e = n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length; i = e - t.offset } const o = new Kl(n, t.offset, i); t.offset += i; this._position = t; return this._formatReturnValue("text", o, e, t, i) } else { t = ih._createAfter(n); this._position = t; if (this.ignoreElementEnd) { return this._next() } else { return this._formatReturnValue("elementEnd", n, e, t) } } } _previous() { let t = this.position.clone(); const e = this.position; const n = t.parent; if (n.parent === null && t.offset === 0) { return { done: true, value: undefined } } if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset) { return { done: true, value: undefined } } let i; if (n instanceof $l) { if (t.isAtStart) { this._position = ih._createBefore(n); return this._previous() } i = n.data[t.offset - 1] } else { i = n.getChild(t.offset - 1) } if (i instanceof $u) { if (!this.shallow) { t = new ih(i, i.childCount); this._position = t; if (this.ignoreElementEnd) { return this._previous() } else { return this._formatReturnValue("elementEnd", i, e, t) } } else { t.offset--; this._position = t; return this._formatReturnValue("elementStart", i, e, t, 1) } } else if (i instanceof $l) { if (this.singleCharacters) { t = new ih(i, i.data.length); this._position = t; return this._previous() } else { let n = i.data.length; let o; if (i == this._boundaryStartParent) { const e = this.boundaries.start.offset; o = new Kl(i, e, i.data.length - e); n = o.data.length; t = ih._createBefore(o) } else { o = new Kl(i, 0, i.data.length); t.offset-- } this._position = t; return this._formatReturnValue("text", o, e, t, n) } } else if (typeof i == "string") { let i; if (!this.singleCharacters) { const e = n === this._boundaryStartParent ? this.boundaries.start.offset : 0; i = t.offset - e } else { i = 1 } t.offset -= i; const o = new Kl(n, t.offset, i); this._position = t; return this._formatReturnValue("text", o, e, t, i) } else { t = ih._createBefore(n); this._position = t; return this._formatReturnValue("elementStart", n, e, t, 1) } } _formatReturnValue(t, e, n, i, o) { if (e instanceof Kl) { if (e.offsetInText + e.data.length == e.textNode.data.length) { if (this.direction == "forward" && !(this.boundaries && this.boundaries.end.isEqual(this.position))) { i = ih._createAfter(e.textNode); this._position = i } else { n = ih._createAfter(e.textNode) } } if (e.offsetInText === 0) { if (this.direction == "backward" && !(this.boundaries && this.boundaries.start.isEqual(this.position))) { i = ih._createBefore(e.textNode); this._position = i } else { n = ih._createBefore(e.textNode) } } } return { done: false, value: { type: t, item: e, previousPosition: n, nextPosition: i, length: o } } } } class ih extends Hl { constructor(t, e) { super(); this.parent = t; this.offset = e } get nodeAfter() { if (this.parent.is("$text")) { return null } return this.parent.getChild(this.offset) || null } get nodeBefore() { if (this.parent.is("$text")) { return null } return this.parent.getChild(this.offset - 1) || null } get isAtStart() { return this.offset === 0 } get isAtEnd() { const t = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount; return this.offset === t } get root() { return this.parent.root } get editableElement() { let t = this.parent; while (!(t instanceof Xu)) { if (t.parent) { t = t.parent } else { return null } } return t } getShiftedBy(t) { const e = ih._createAt(this); const n = e.offset + t; e.offset = n < 0 ? 0 : n; return e } getLastMatchingPosition(t, e = {}) { e.startPosition = this; const n = new nh(e); n.skip(t); return n.position } getAncestors() { if (this.parent.is("documentFragment")) { return [this.parent] } else { return this.parent.getAncestors({ includeSelf: true }) } } getCommonAncestor(t) { const e = this.getAncestors(); const n = t.getAncestors(); let i = 0; while (e[i] == n[i] && e[i]) { i++ } return i === 0 ? null : e[i - 1] } isEqual(t) { return this.parent == t.parent && this.offset == t.offset } isBefore(t) { return this.compareWith(t) == "before" } isAfter(t) { return this.compareWith(t) == "after" } compareWith(t) { if (this.root !== t.root) { return "different" } if (this.isEqual(t)) { return "same" } const e = this.parent.is("node") ? this.parent.getPath() : []; const n = t.parent.is("node") ? t.parent.getPath() : []; e.push(this.offset); n.push(t.offset); const i = _t(e, n); switch (i) { case "prefix": return "before"; case "extension": return "after"; default: return e[i] < n[i] ? "before" : "after" } } getWalker(t = {}) { t.startPosition = this; return new nh(t) } clone() { return new ih(this.parent, this.offset) } static _createAt(t, e) { if (t instanceof ih) { return new this(t.parent, t.offset) } else { const n = t; if (e == "end") { e = n.is("$text") ? n.data.length : n.childCount } else if (e == "before") { return this._createBefore(n) } else if (e == "after") { return this._createAfter(n) } else if (e !== 0 && !e) { throw new I("view-createpositionat-offset-required", n) } return new ih(n, e) } } static _createAfter(t) { if (t.is("$textProxy")) { return new ih(t.textNode, t.offsetInText + t.data.length) } if (!t.parent) { throw new I("view-position-after-root", t, { root: t }) } return new ih(t.parent, t.index + 1) } static _createBefore(t) { if (t.is("$textProxy")) { return new ih(t.textNode, t.offsetInText) } if (!t.parent) { throw new I("view-position-before-root", t, { root: t }) } return new ih(t.parent, t.index) } } ih.prototype.is = function (t) { return t === "position" || t === "view:position" }; class oh extends Hl { constructor(t, e = null) { super(); this.start = t.clone(); this.end = e ? e.clone() : t.clone() } *[Symbol.iterator]() { yield* new nh({ boundaries: this, ignoreElementEnd: true }) } get isCollapsed() { return this.start.isEqual(this.end) } get isFlat() { return this.start.parent === this.end.parent } get root() { return this.start.root } getEnlarged() { let t = this.start.getLastMatchingPosition(rh, { direction: "backward" }); let e = this.end.getLastMatchingPosition(rh); if (t.parent.is("$text") && t.isAtStart) { t = ih._createBefore(t.parent) } if (e.parent.is("$text") && e.isAtEnd) { e = ih._createAfter(e.parent) } return new oh(t, e) } getTrimmed() { let t = this.start.getLastMatchingPosition(rh); if (t.isAfter(this.end) || t.isEqual(this.end)) { return new oh(t, t) } let e = this.end.getLastMatchingPosition(rh, { direction: "backward" }); const n = t.nodeAfter; const i = e.nodeBefore; if (n && n.is("$text")) { t = new ih(n, 0) } if (i && i.is("$text")) { e = new ih(i, i.data.length) } return new oh(t, e) } isEqual(t) { return this == t || this.start.isEqual(t.start) && this.end.isEqual(t.end) } containsPosition(t) { return t.isAfter(this.start) && t.isBefore(this.end) } containsRange(t, e = false) { if (t.isCollapsed) { e = false } const n = this.containsPosition(t.start) || e && this.start.isEqual(t.start); const i = this.containsPosition(t.end) || e && this.end.isEqual(t.end); return n && i } getDifference(t) { const e = []; if (this.isIntersecting(t)) { if (this.containsPosition(t.start)) { e.push(new oh(this.start, t.start)) } if (this.containsPosition(t.end)) { e.push(new oh(t.end, this.end)) } } else { e.push(this.clone()) } return e } getIntersection(t) { if (this.isIntersecting(t)) { let e = this.start; let n = this.end; if (this.containsPosition(t.start)) { e = t.start } if (this.containsPosition(t.end)) { n = t.end } return new oh(e, n) } return null } getWalker(t = {}) { t.boundaries = this; return new nh(t) } getCommonAncestor() { return this.start.getCommonAncestor(this.end) } getContainedElement() { if (this.isCollapsed) { return null } let t = this.start.nodeAfter; let e = this.end.nodeBefore; if (this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling) { t = this.start.parent.nextSibling } if (this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling) { e = this.end.parent.previousSibling } if (t && t.is("element") && t === e) { return t } return null } clone() { return new oh(this.start, this.end) } *getItems(t = {}) { t.boundaries = this; t.ignoreElementEnd = true; const e = new nh(t); for (const t of e) { yield t.item } } *getPositions(t = {}) { t.boundaries = this; const e = new nh(t); yield e.position; for (const t of e) { yield t.nextPosition } } isIntersecting(t) { return this.start.isBefore(t.end) && this.end.isAfter(t.start) } static _createFromParentsAndOffsets(t, e, n, i) { return new this(new ih(t, e), new ih(n, i)) } static _createFromPositionAndShift(t, e) { const n = t; const i = t.getShiftedBy(e); return e > 0 ? new this(n, i) : new this(i, n) } static _createIn(t) { return this._createFromParentsAndOffsets(t, 0, t, t.childCount) } static _createOn(t) { const e = t.is("$textProxy") ? t.offsetSize : 1; return this._createFromPositionAndShift(ih._createBefore(t), e) } } oh.prototype.is = function (t) { return t === "range" || t === "view:range" }; function rh(t) { if (t.item.is("attributeElement") || t.item.is("uiElement")) { return true } return false } class sh extends (U(Hl)) { constructor(...t) { super(); this._ranges = []; this._lastRangeBackward = false; this._isFake = false; this._fakeSelectionLabel = ""; if (t.length) { this.setTo(...t) } } get isFake() { return this._isFake } get fakeSelectionLabel() { return this._fakeSelectionLabel } get anchor() { if (!this._ranges.length) { return null } const t = this._ranges[this._ranges.length - 1]; const e = this._lastRangeBackward ? t.end : t.start; return e.clone() } get focus() { if (!this._ranges.length) { return null } const t = this._ranges[this._ranges.length - 1]; const e = this._lastRangeBackward ? t.start : t.end; return e.clone() } get isCollapsed() { return this.rangeCount === 1 && this._ranges[0].isCollapsed } get rangeCount() { return this._ranges.length } get isBackward() { return !this.isCollapsed && this._lastRangeBackward } get editableElement() { if (this.anchor) { return this.anchor.editableElement } return null } *getRanges() { for (const t of this._ranges) { yield t.clone() } } getFirstRange() { let t = null; for (const e of this._ranges) { if (!t || e.start.isBefore(t.start)) { t = e } } return t ? t.clone() : null } getLastRange() { let t = null; for (const e of this._ranges) { if (!t || e.end.isAfter(t.end)) { t = e } } return t ? t.clone() : null } getFirstPosition() { const t = this.getFirstRange(); return t ? t.start.clone() : null } getLastPosition() { const t = this.getLastRange(); return t ? t.end.clone() : null } isEqual(t) { if (this.isFake != t.isFake) { return false } if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel) { return false } if (this.rangeCount != t.rangeCount) { return false } else if (this.rangeCount === 0) { return true } if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) { return false } for (const e of this._ranges) { let n = false; for (const i of t._ranges) { if (e.isEqual(i)) { n = true; break } } if (!n) { return false } } return true } isSimilar(t) { if (this.isBackward != t.isBackward) { return false } const e = At(this.getRanges()); const n = At(t.getRanges()); if (e != n) { return false } if (e == 0) { return true } for (let e of this.getRanges()) { e = e.getTrimmed(); let n = false; for (let i of t.getRanges()) { i = i.getTrimmed(); if (e.start.isEqual(i.start) && e.end.isEqual(i.end)) { n = true; break } } if (!n) { return false } } return true } getSelectedElement() { if (this.rangeCount !== 1) { return null } return this.getFirstRange().getContainedElement() } setTo(...t) { let [e, n, i] = t; if (typeof n == "object") { i = n; n = undefined } if (e === null) { this._setRanges([]); this._setFakeOptions(i) } else if (e instanceof sh || e instanceof ah) { this._setRanges(e.getRanges(), e.isBackward); this._setFakeOptions({ fake: e.isFake, label: e.fakeSelectionLabel }) } else if (e instanceof oh) { this._setRanges([e], i && i.backward); this._setFakeOptions(i) } else if (e instanceof ih) { this._setRanges([new oh(e)]); this._setFakeOptions(i) } else if (e instanceof Gl) { const t = !!i && !!i.backward; let o; if (n === undefined) { throw new I("view-selection-setto-required-second-parameter", this) } else if (n == "in") { o = oh._createIn(e) } else if (n == "on") { o = oh._createOn(e) } else { o = new oh(ih._createAt(e, n)) } this._setRanges([o], t); this._setFakeOptions(i) } else if (Ct(e)) { this._setRanges(e, i && i.backward); this._setFakeOptions(i) } else { throw new I("view-selection-setto-not-selectable", this) } this.fire("change") } setFocus(t, e) { if (this.anchor === null) { throw new I("view-selection-setfocus-no-ranges", this) } const n = ih._createAt(t, e); if (n.compareWith(this.focus) == "same") { return } const i = this.anchor; this._ranges.pop(); if (n.compareWith(i) == "before") { this._addRange(new oh(n, i), true) } else { this._addRange(new oh(i, n)) } this.fire("change") } _setRanges(t, e = false) { t = Array.from(t); this._ranges = []; for (const e of t) { this._addRange(e) } this._lastRangeBackward = !!e } _setFakeOptions(t = {}) { this._isFake = !!t.fake; this._fakeSelectionLabel = t.fake ? t.label || "" : "" } _addRange(t, e = false) { if (!(t instanceof oh)) { throw new I("view-selection-add-range-not-range", this) } this._pushRange(t); this._lastRangeBackward = !!e } _pushRange(t) { for (const e of this._ranges) { if (t.isIntersecting(e)) { throw new I("view-selection-range-intersects", this, { addedRange: t, intersectingRange: e }) } } this._ranges.push(new oh(t.start, t.end)) } } sh.prototype.is = function (t) { return t === "selection" || t === "view:selection" }; class ah extends (U(Hl)) { constructor(...t) { super(); this._selection = new sh; this._selection.delegate("change").to(this); if (t.length) { this._selection.setTo(...t) } } get isFake() { return this._selection.isFake } get fakeSelectionLabel() { return this._selection.fakeSelectionLabel } get anchor() { return this._selection.anchor } get focus() { return this._selection.focus } get isCollapsed() { return this._selection.isCollapsed } get rangeCount() { return this._selection.rangeCount } get isBackward() { return this._selection.isBackward } get editableElement() { return this._selection.editableElement } get _ranges() { return this._selection._ranges } *getRanges() { yield* this._selection.getRanges() } getFirstRange() { return this._selection.getFirstRange() } getLastRange() { return this._selection.getLastRange() } getFirstPosition() { return this._selection.getFirstPosition() } getLastPosition() { return this._selection.getLastPosition() } getSelectedElement() { return this._selection.getSelectedElement() } isEqual(t) { return this._selection.isEqual(t) } isSimilar(t) { return this._selection.isSimilar(t) } _setTo(...t) { this._selection.setTo(...t) } _setFocus(t, e) { this._selection.setFocus(t, e) } } ah.prototype.is = function (t) { return t === "selection" || t == "documentSelection" || t == "view:selection" || t == "view:documentSelection" }; class ch extends v { constructor(t, e, n) { super(t, e); this.startRange = n; this._eventPhase = "none"; this._currentTarget = null } get eventPhase() { return this._eventPhase } get currentTarget() { return this._currentTarget } } const lh = Symbol("bubbling contexts"); function dh(t) { class e extends t { fire(t, ...e) { try { const n = t instanceof v ? t : new v(this, t); const i = mh(this); if (!i.size) { return } uh(n, "capturing", this); if (hh(i, "$capture", n, ...e)) { return n.return } const o = n.startRange || this.selection.getFirstRange(); const r = o ? o.getContainedElement() : null; const s = r ? Boolean(gh(i, r)) : false; let a = r || fh(o); uh(n, "atTarget", a); if (!s) { if (hh(i, "$text", n, ...e)) { return n.return } uh(n, "bubbling", a) } while (a) { if (a.is("rootElement")) { if (hh(i, "$root", n, ...e)) { return n.return } } else if (a.is("element")) { if (hh(i, a.name, n, ...e)) { return n.return } } if (hh(i, a, n, ...e)) { return n.return } a = a.parent; uh(n, "bubbling", a) } uh(n, "bubbling", this); hh(i, "$document", n, ...e); return n.return } catch (t) { I.rethrowUnexpectedError(t, this) } } _addEventListener(t, e, n) { const i = $c(n.context || "$document"); const o = mh(this); for (const r of i) { let i = o.get(r); if (!i) { i = new (U()); o.set(r, i) } this.listenTo(i, t, e, n) } } _removeEventListener(t, e) { const n = mh(this); for (const i of n.values()) { this.stopListening(i, t, e) } } } return e } { const t = dh(Object);["fire", "_addEventListener", "_removeEventListener"].forEach((e => { dh[e] = t.prototype[e] })) } function uh(t, e, n) { if (t instanceof ch) { t._eventPhase = e; t._currentTarget = n } } function hh(t, e, n, ...i) { const o = typeof e == "string" ? t.get(e) : gh(t, e); if (!o) { return false } o.fire(n, ...i); return n.stop.called } function gh(t, e) { for (const [n, i] of t) { if (typeof n == "function" && n(e)) { return i } } return null } function mh(t) { if (!t[lh]) { t[lh] = new Map } return t[lh] } function fh(t) { if (!t) { return null } const e = t.start.parent; const n = t.end.parent; const i = e.getPath(); const o = n.getPath(); return i.length > o.length ? e : n } class ph extends (dh(lt())) { constructor(t) { super(); this._postFixers = new Set; this.selection = new ah; this.roots = new il({ idProperty: "rootName" }); this.stylesProcessor = t; this.set("isReadOnly", false); this.set("isFocused", false); this.set("isSelecting", false); this.set("isComposing", false) } getRoot(t = "main") { return this.roots.get(t) } registerPostFixer(t) { this._postFixers.add(t) } destroy() { this.roots.map((t => t.destroy())); this.stopListening() } _callPostFixers(t) { let e = false; do { for (const n of this._postFixers) { e = n(t); if (e) { break } } } while (e) } } const bh = 10; class kh extends $u { constructor(t, e, n, i) { super(t, e, n, i); this._priority = bh; this._id = null; this._clonesGroup = null; this.getFillerOffset = wh } get priority() { return this._priority } get id() { return this._id } getElementsWithSameId() { if (this.id === null) { throw new I("attribute-element-get-elements-with-same-id-no-id", this) } return new Set(this._clonesGroup) } isSimilar(t) { if (this.id !== null || t.id !== null) { return this.id === t.id } return super.isSimilar(t) && this.priority == t.priority } _clone(t = false) { const e = super._clone(t); e._priority = this._priority; e._id = this._id; return e } } kh.DEFAULT_PRIORITY = bh; kh.prototype.is = function (t, e) { if (!e) { return t === "attributeElement" || t === "view:attributeElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node" } else { return e === this.name && (t === "attributeElement" || t === "view:attributeElement" || t === "element" || t === "view:element") } }; function wh() { if (Ah(this)) { return null } let t = this.parent; while (t && t.is("attributeElement")) { if (Ah(t) > 1) { return null } t = t.parent } if (!t || Ah(t) > 1) { return null } return this.childCount } function Ah(t) { return Array.from(t.getChildren()).filter((t => !t.is("uiElement"))).length } class _h extends $u { constructor(t, e, n, i) { super(t, e, n, i); this.getFillerOffset = Ch } _insertChild(t, e) { if (e && (e instanceof Gl || Array.from(e).length > 0)) { throw new I("view-emptyelement-cannot-add", [this, e]) } return 0 } } _h.prototype.is = function (t, e) { if (!e) { return t === "emptyElement" || t === "view:emptyElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node" } else { return e === this.name && (t === "emptyElement" || t === "view:emptyElement" || t === "element" || t === "view:element") } }; function Ch() { return null } class vh extends $u { constructor(t, e, n, i) { super(t, e, n, i); this.getFillerOffset = xh } _insertChild(t, e) { if (e && (e instanceof Gl || Array.from(e).length > 0)) { throw new I("view-uielement-cannot-add", [this, e]) } return 0 } render(t, e) { return this.toDomElement(t) } toDomElement(t) { const e = t.createElement(this.name); for (const t of this.getAttributeKeys()) { e.setAttribute(t, this.getAttribute(t)) } return e } } vh.prototype.is = function (t, e) { if (!e) { return t === "uiElement" || t === "view:uiElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node" } else { return e === this.name && (t === "uiElement" || t === "view:uiElement" || t === "element" || t === "view:element") } }; function yh(t) { t.document.on("arrowKey", ((e, n) => Eh(e, n, t.domConverter)), { priority: "low" }) } function xh() { return null } function Eh(t, e, n) { if (e.keyCode == Pc.arrowright) { const t = e.domTarget.ownerDocument.defaultView.getSelection(); const i = t.rangeCount == 1 && t.getRangeAt(0).collapsed; if (i || e.shiftKey) { const e = t.focusNode; const o = t.focusOffset; const r = n.domPositionToView(e, o); if (r === null) { return } let s = false; const a = r.getLastMatchingPosition((t => { if (t.item.is("uiElement")) { s = true } if (t.item.is("uiElement") || t.item.is("attributeElement")) { return true } return false })); if (s) { const e = n.viewPositionToDom(a); if (i) { t.collapse(e.parent, e.offset) } else { t.extend(e.parent, e.offset) } } } } } class Dh extends $u { constructor(t, e, n, i) { super(t, e, n, i); this.getFillerOffset = Sh } _insertChild(t, e) { if (e && (e instanceof Gl || Array.from(e).length > 0)) { throw new I("view-rawelement-cannot-add", [this, e]) } return 0 } render(t, e) { } } Dh.prototype.is = function (t, e) { if (!e) { return t === "rawElement" || t === "view:rawElement" || t === this.name || t === "view:" + this.name || t === "element" || t === "view:element" || t === "node" || t === "view:node" } else { return e === this.name && (t === "rawElement" || t === "view:rawElement" || t === "element" || t === "view:element") } }; function Sh() { return null } class Th extends (U(Hl)) { constructor(t, e) { super(); this._children = []; this._customProperties = new Map; this.document = t; if (e) { this._insertChild(0, e) } } [Symbol.iterator]() { return this._children[Symbol.iterator]() } get childCount() { return this._children.length } get isEmpty() { return this.childCount === 0 } get root() { return this } get parent() { return null } get name() { return undefined } getCustomProperty(t) { return this._customProperties.get(t) } *getCustomProperties() { yield* this._customProperties.entries() } _appendChild(t) { return this._insertChild(this.childCount, t) } getChild(t) { return this._children[t] } getChildIndex(t) { return this._children.indexOf(t) } getChildren() { return this._children[Symbol.iterator]() } _insertChild(t, e) { this._fireChange("children", this); let n = 0; const i = Ih(this.document, e); for (const e of i) { if (e.parent !== null) { e._remove() } e.parent = this; this._children.splice(t, 0, e); t++; n++ } return n } _removeChildren(t, e = 1) { this._fireChange("children", this); for (let n = t; n < t + e; n++) { this._children[n].parent = null } return this._children.splice(t, e) } _fireChange(t, e) { this.fire("change:" + t, e) } _setCustomProperty(t, e) { this._customProperties.set(t, e) } _removeCustomProperty(t) { return this._customProperties.delete(t) } } Th.prototype.is = function (t) { return t === "documentFragment" || t === "view:documentFragment" }; function Ih(t, e) { if (typeof e == "string") { return [new $l(t, e)] } if (!Ct(e)) { e = [e] } return Array.from(e).map((e => { if (typeof e == "string") { return new $l(t, e) } if (e instanceof Kl) { return new $l(t, e.data) } return e })) } class Mh { constructor(t) { this._cloneGroups = new Map; this._slotFactory = null; this.document = t } setSelection(...t) { this.document.selection._setTo(...t) } setSelectionFocus(t, e) { this.document.selection._setFocus(t, e) } createDocumentFragment(t) { return new Th(this.document, t) } createText(t) { return new $l(this.document, t) } createAttributeElement(t, e, n = {}) { const i = new kh(this.document, t, e); if (typeof n.priority === "number") { i._priority = n.priority } if (n.id) { i._id = n.id } if (n.renderUnsafeAttributes) { i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes) } return i } createContainerElement(t, e, n = {}, i = {}) { let o = null; if (de(n)) { i = n } else { o = n } const r = new Zu(this.document, t, e, o); if (i.renderUnsafeAttributes) { r._unsafeAttributesToRender.push(...i.renderUnsafeAttributes) } return r } createEditableElement(t, e, n = {}) { const i = new Xu(this.document, t, e); if (n.renderUnsafeAttributes) { i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes) } return i } createEmptyElement(t, e, n = {}) { const i = new _h(this.document, t, e); if (n.renderUnsafeAttributes) { i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes) } return i } createUIElement(t, e, n) { const i = new vh(this.document, t, e); if (n) { i.render = n } return i } createRawElement(t, e, n, i = {}) { const o = new Dh(this.document, t, e); if (n) { o.render = n } if (i.renderUnsafeAttributes) { o._unsafeAttributesToRender.push(...i.renderUnsafeAttributes) } return o } setAttribute(t, e, n) { n._setAttribute(t, e) } removeAttribute(t, e) { e._removeAttribute(t) } addClass(t, e) { e._addClass(t) } removeClass(t, e) { e._removeClass(t) } setStyle(t, e, n) { if (de(t) && n === undefined) { e._setStyle(t) } else { n._setStyle(t, e) } } removeStyle(t, e) { e._removeStyle(t) } setCustomProperty(t, e, n) { n._setCustomProperty(t, e) } removeCustomProperty(t, e) { return e._removeCustomProperty(t) } breakAttributes(t) { if (t instanceof ih) { return this._breakAttributes(t) } else { return this._breakAttributesRange(t) } } breakContainer(t) { const e = t.parent; if (!e.is("containerElement")) { throw new I("view-writer-break-non-container-element", this.document) } if (!e.parent) { throw new I("view-writer-break-root", this.document) } if (t.isAtStart) { return ih._createBefore(e) } else if (!t.isAtEnd) { const n = e._clone(false); this.insert(ih._createAfter(e), n); const i = new oh(t, ih._createAt(e, "end")); const o = new ih(n, 0); this.move(i, o) } return ih._createAfter(e) } mergeAttributes(t) { const e = t.offset; const n = t.parent; if (n.is("$text")) { return t } if (n.is("attributeElement") && n.childCount === 0) { const t = n.parent; const e = n.index; n._remove(); this._removeFromClonedElementsGroup(n); return this.mergeAttributes(new ih(t, e)) } const i = n.getChild(e - 1); const o = n.getChild(e); if (!i || !o) { return t } if (i.is("$text") && o.is("$text")) { return Oh(i, o) } else if (i.is("attributeElement") && o.is("attributeElement") && i.isSimilar(o)) { const t = i.childCount; i._appendChild(o.getChildren()); o._remove(); this._removeFromClonedElementsGroup(o); return this.mergeAttributes(new ih(i, t)) } return t } mergeContainers(t) { const e = t.nodeBefore; const n = t.nodeAfter; if (!e || !n || !e.is("containerElement") || !n.is("containerElement")) { throw new I("view-writer-merge-containers-invalid-position", this.document) } const i = e.getChild(e.childCount - 1); const o = i instanceof $l ? ih._createAt(i, "end") : ih._createAt(e, "end"); this.move(oh._createIn(n), ih._createAt(e, "end")); this.remove(oh._createOn(n)); return o } insert(t, e) { e = Ct(e) ? [...e] : [e]; Vh(e, this.document); const n = e.reduce(((t, e) => { const n = t[t.length - 1]; const i = !e.is("uiElement"); if (!n || n.breakAttributes != i) { t.push({ breakAttributes: i, nodes: [e] }) } else { n.nodes.push(e) } return t }), []); let i = null; let o = t; for (const { nodes: t, breakAttributes: e } of n) { const n = this._insertNodes(o, t, e); if (!i) { i = n.start } o = n.end } if (!i) { return new oh(t) } return new oh(i, o) } remove(t) { const e = t instanceof oh ? t : oh._createOn(t); Fh(e, this.document); if (e.isCollapsed) { return new Th(this.document) } const { start: n, end: i } = this._breakAttributesRange(e, true); const o = n.parent; const r = i.offset - n.offset; const s = o._removeChildren(n.offset, r); for (const t of s) { this._removeFromClonedElementsGroup(t) } const a = this.mergeAttributes(n); e.start = a; e.end = a.clone(); return new Th(this.document, s) } clear(t, e) { Fh(t, this.document); const n = t.getWalker({ direction: "backward", ignoreElementEnd: true }); for (const i of n) { const n = i.item; let o; if (n.is("element") && e.isSimilar(n)) { o = oh._createOn(n) } else if (!i.nextPosition.isAfter(t.start) && n.is("$textProxy")) { const t = n.getAncestors().find((t => t.is("element") && e.isSimilar(t))); if (t) { o = oh._createIn(t) } } if (o) { if (o.end.isAfter(t.end)) { o.end = t.end } if (o.start.isBefore(t.start)) { o.start = t.start } this.remove(o) } } } move(t, e) { let n; if (e.isAfter(t.end)) { e = this._breakAttributes(e, true); const i = e.parent; const o = i.childCount; t = this._breakAttributesRange(t, true); n = this.remove(t); e.offset += i.childCount - o } else { n = this.remove(t) } return this.insert(e, n) } wrap(t, e) { if (!(e instanceof kh)) { throw new I("view-writer-wrap-invalid-attribute", this.document) } Fh(t, this.document); if (!t.isCollapsed) { return this._wrapRange(t, e) } else { let n = t.start; if (n.parent.is("element") && !Bh(n.parent)) { n = n.getLastMatchingPosition((t => t.item.is("uiElement"))) } n = this._wrapPosition(n, e); const i = this.document.selection; if (i.isCollapsed && i.getFirstPosition().isEqual(t.start)) { this.setSelection(n) } return new oh(n) } } unwrap(t, e) { if (!(e instanceof kh)) { throw new I("view-writer-unwrap-invalid-attribute", this.document) } Fh(t, this.document); if (t.isCollapsed) { return t } const { start: n, end: i } = this._breakAttributesRange(t, true); const o = n.parent; const r = this._unwrapChildren(o, n.offset, i.offset, e); const s = this.mergeAttributes(r.start); if (!s.isEqual(r.start)) { r.end.offset-- } const a = this.mergeAttributes(r.end); return new oh(s, a) } rename(t, e) { const n = new Zu(this.document, t, e.getAttributes()); this.insert(ih._createAfter(e), n); this.move(oh._createIn(e), ih._createAt(n, 0)); this.remove(oh._createOn(e)); return n } clearClonedElementsGroup(t) { this._cloneGroups.delete(t) } createPositionAt(t, e) { return ih._createAt(t, e) } createPositionAfter(t) { return ih._createAfter(t) } createPositionBefore(t) { return ih._createBefore(t) } createRange(t, e) { return new oh(t, e) } createRangeOn(t) { return oh._createOn(t) } createRangeIn(t) { return oh._createIn(t) } createSelection(...t) { return new sh(...t) } createSlot(t = "children") { if (!this._slotFactory) { throw new I("view-writer-invalid-create-slot-context", this.document) } return this._slotFactory(this, t) } _registerSlotFactory(t) { this._slotFactory = t } _clearSlotFactory() { this._slotFactory = null } _insertNodes(t, e, n) { let i; if (n) { i = Lh(t) } else { i = t.parent.is("$text") ? t.parent.parent : t.parent } if (!i) { throw new I("view-writer-invalid-position-container", this.document) } let o; if (n) { o = this._breakAttributes(t, true) } else { o = t.parent.is("$text") ? Ph(t) : t } const r = i._insertChild(o.offset, e); for (const t of e) { this._addToClonedElementsGroup(t) } const s = o.getShiftedBy(r); const a = this.mergeAttributes(o); if (!a.isEqual(o)) { s.offset-- } const c = this.mergeAttributes(s); return new oh(a, c) } _wrapChildren(t, e, n, i) { let o = e; const r = []; while (o < n) { const e = t.getChild(o); const n = e.is("$text"); const s = e.is("attributeElement"); if (s && this._wrapAttributeElement(i, e)) { r.push(new ih(t, o)) } else if (n || !s || Nh(i, e)) { const n = i._clone(); e._remove(); n._appendChild(e); t._insertChild(o, n); this._addToClonedElementsGroup(n); r.push(new ih(t, o)) } else { this._wrapChildren(e, 0, e.childCount, i) } o++ } let s = 0; for (const t of r) { t.offset -= s; if (t.offset == e) { continue } const i = this.mergeAttributes(t); if (!i.isEqual(t)) { s++; n-- } } return oh._createFromParentsAndOffsets(t, e, t, n) } _unwrapChildren(t, e, n, i) { let o = e; const r = []; while (o < n) { const e = t.getChild(o); if (!e.is("attributeElement")) { o++; continue } if (e.isSimilar(i)) { const i = e.getChildren(); const s = e.childCount; e._remove(); t._insertChild(o, i); this._removeFromClonedElementsGroup(e); r.push(new ih(t, o), new ih(t, o + s)); o += s; n += s - 1; continue } if (this._unwrapAttributeElement(i, e)) { r.push(new ih(t, o), new ih(t, o + 1)); o++; continue } this._unwrapChildren(e, 0, e.childCount, i); o++ } let s = 0; for (const t of r) { t.offset -= s; if (t.offset == e || t.offset == n) { continue } const i = this.mergeAttributes(t); if (!i.isEqual(t)) { s++; n-- } } return oh._createFromParentsAndOffsets(t, e, t, n) } _wrapRange(t, e) { const { start: n, end: i } = this._breakAttributesRange(t, true); const o = n.parent; const r = this._wrapChildren(o, n.offset, i.offset, e); const s = this.mergeAttributes(r.start); if (!s.isEqual(r.start)) { r.end.offset-- } const a = this.mergeAttributes(r.end); return new oh(s, a) } _wrapPosition(t, e) { if (e.isSimilar(t.parent)) { return zh(t.clone()) } if (t.parent.is("$text")) { t = Ph(t) } const n = this.createAttributeElement("_wrapPosition-fake-element"); n._priority = Number.POSITIVE_INFINITY; n.isSimilar = () => false; t.parent._insertChild(t.offset, n); const i = new oh(t, t.getShiftedBy(1)); this.wrap(i, e); const o = new ih(n.parent, n.index); n._remove(); const r = o.nodeBefore; const s = o.nodeAfter; if (r instanceof $l && s instanceof $l) { return Oh(r, s) } return zh(o) } _wrapAttributeElement(t, e) { if (!Hh(t, e)) { return false } if (t.name !== e.name || t.priority !== e.priority) { return false } for (const n of t.getAttributeKeys()) { if (n === "class" || n === "style") { continue } if (e.hasAttribute(n) && e.getAttribute(n) !== t.getAttribute(n)) { return false } } for (const n of t.getStyleNames()) { if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) { return false } } for (const n of t.getAttributeKeys()) { if (n === "class" || n === "style") { continue } if (!e.hasAttribute(n)) { this.setAttribute(n, t.getAttribute(n), e) } } for (const n of t.getStyleNames()) { if (!e.hasStyle(n)) { this.setStyle(n, t.getStyle(n), e) } } for (const n of t.getClassNames()) { if (!e.hasClass(n)) { this.addClass(n, e) } } return true } _unwrapAttributeElement(t, e) { if (!Hh(t, e)) { return false } if (t.name !== e.name || t.priority !== e.priority) { return false } for (const n of t.getAttributeKeys()) { if (n === "class" || n === "style") { continue } if (!e.hasAttribute(n) || e.getAttribute(n) !== t.getAttribute(n)) { return false } } if (!e.hasClass(...t.getClassNames())) { return false } for (const n of t.getStyleNames()) { if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) { return false } } for (const n of t.getAttributeKeys()) { if (n === "class" || n === "style") { continue } this.removeAttribute(n, e) } this.removeClass(Array.from(t.getClassNames()), e); this.removeStyle(Array.from(t.getStyleNames()), e); return true } _breakAttributesRange(t, e = false) { const n = t.start; const i = t.end; Fh(t, this.document); if (t.isCollapsed) { const n = this._breakAttributes(t.start, e); return new oh(n, n) } const o = this._breakAttributes(i, e); const r = o.parent.childCount; const s = this._breakAttributes(n, e); o.offset += o.parent.childCount - r; return new oh(s, o) } _breakAttributes(t, e = false) { const n = t.offset; const i = t.parent; if (t.parent.is("emptyElement")) { throw new I("view-writer-cannot-break-empty-element", this.document) } if (t.parent.is("uiElement")) { throw new I("view-writer-cannot-break-ui-element", this.document) } if (t.parent.is("rawElement")) { throw new I("view-writer-cannot-break-raw-element", this.document) } if (!e && i.is("$text") && jh(i.parent)) { return t.clone() } if (jh(i)) { return t.clone() } if (i.is("$text")) { return this._breakAttributes(Ph(t), e) } const o = i.childCount; if (n == o) { const t = new ih(i.parent, i.index + 1); return this._breakAttributes(t, e) } else { if (n === 0) { const t = new ih(i.parent, i.index); return this._breakAttributes(t, e) } else { const t = i.index + 1; const o = i._clone(); i.parent._insertChild(t, o); this._addToClonedElementsGroup(o); const r = i.childCount - n; const s = i._removeChildren(n, r); o._appendChild(s); const a = new ih(i.parent, t); return this._breakAttributes(a, e) } } } _addToClonedElementsGroup(t) { if (!t.root.is("rootElement")) { return } if (t.is("element")) { for (const e of t.getChildren()) { this._addToClonedElementsGroup(e) } } const e = t.id; if (!e) { return } let n = this._cloneGroups.get(e); if (!n) { n = new Set; this._cloneGroups.set(e, n) } n.add(t); t._clonesGroup = n } _removeFromClonedElementsGroup(t) { if (t.is("element")) { for (const e of t.getChildren()) { this._removeFromClonedElementsGroup(e) } } const e = t.id; if (!e) { return } const n = this._cloneGroups.get(e); if (!n) { return } n.delete(t) } } function Bh(t) { return Array.from(t.getChildren()).some((t => !t.is("uiElement"))) } function Lh(t) { let e = t.parent; while (!jh(e)) { if (!e) { return undefined } e = e.parent } return e } function Nh(t, e) { if (t.priority < e.priority) { return true } else if (t.priority > e.priority) { return false } return t.getIdentity() < e.getIdentity() } function zh(t) { const e = t.nodeBefore; if (e && e.is("$text")) { return new ih(e, e.data.length) } const n = t.nodeAfter; if (n && n.is("$text")) { return new ih(n, 0) } return t } function Ph(t) { if (t.offset == t.parent.data.length) { return new ih(t.parent.parent, t.parent.index + 1) } if (t.offset === 0) { return new ih(t.parent.parent, t.parent.index) } const e = t.parent.data.slice(t.offset); t.parent._data = t.parent.data.slice(0, t.offset); t.parent.parent._insertChild(t.parent.index + 1, new $l(t.root.document, e)); return new ih(t.parent.parent, t.parent.index + 1) } function Oh(t, e) { const n = t.data.length; t._data += e.data; e._remove(); return new ih(t, n) } const Rh = [$l, kh, Zu, _h, Dh, vh]; function Vh(t, e) { for (const n of t) { if (!Rh.some((t => n instanceof t))) { throw new I("view-writer-insert-invalid-node-type", e) } if (!n.is("$text")) { Vh(n.getChildren(), e) } } } function jh(t) { return t && (t.is("containerElement") || t.is("documentFragment")) } function Fh(t, e) { const n = Lh(t.start); const i = Lh(t.end); if (!n || !i || n !== i) { throw new I("view-writer-invalid-range-container", e) } } function Hh(t, e) { return t.id === null && e.id === null } const Uh = t => t.createTextNode(" "); const Wh = t => { const e = t.createElement("span"); e.dataset.ckeFiller = "true"; e.innerText = " "; return e }; const qh = t => { const e = t.createElement("br"); e.dataset.ckeFiller = "true"; return e }; const Gh = 7; const $h = "⁠".repeat(Gh); function Kh(t) { return tc(t) && t.data.substr(0, Gh) === $h } function Yh(t) { return t.data.length == Gh && Kh(t) } function Qh(t) { if (Kh(t)) { return t.data.slice(Gh) } else { return t.data } } function Zh(t) { t.document.on("arrowKey", Jh, { priority: "low" }) } function Jh(t, e) { if (e.keyCode == Pc.arrowleft) { const t = e.domTarget.ownerDocument.defaultView.getSelection(); if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) { const e = t.getRangeAt(0).startContainer; const n = t.getRangeAt(0).startOffset; if (Kh(e) && n <= Gh) { t.collapse(e, 0) } } } } var Xh = n(4401); var tg = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; tg.insert = "head"; tg.singleton = true; var eg = Sl()(Xh.Z, tg); const ng = Xh.Z.locals || {}; class ig extends (lt()) { constructor(t, e) { super(); this.domDocuments = new Set; this.markedAttributes = new Set; this.markedChildren = new Set; this.markedTexts = new Set; this._inlineFiller = null; this._fakeSelectionContainer = null; this.domConverter = t; this.selection = e; this.set("isFocused", false); this.set("isSelecting", false); if (r.isBlink && !r.isAndroid) { this.on("change:isSelecting", (() => { if (!this.isSelecting) { this.render() } })) } this.set("isComposing", false); this.on("change:isComposing", (() => { if (!this.isComposing) { this.render() } })) } markToSync(t, e) { if (t === "text") { if (this.domConverter.mapViewToDom(e.parent)) { this.markedTexts.add(e) } } else { if (!this.domConverter.mapViewToDom(e)) { return } if (t === "attributes") { this.markedAttributes.add(e) } else if (t === "children") { this.markedChildren.add(e) } else { const e = t; throw new I("view-renderer-unknown-type", this) } } } render() { if (this.isComposing && !r.isAndroid) { return } let t = null; const e = r.isBlink && !r.isAndroid ? !this.isSelecting : true; for (const t of this.markedChildren) { this._updateChildrenMappings(t) } if (e) { if (this._inlineFiller && !this._isSelectionInInlineFiller()) { this._removeInlineFiller() } if (this._inlineFiller) { t = this._getInlineFillerPosition() } else if (this._needsInlineFillerAtSelection()) { t = this.selection.getFirstPosition(); this.markedChildren.add(t.parent) } } else if (this._inlineFiller && this._inlineFiller.parentNode) { t = this.domConverter.domPositionToView(this._inlineFiller); if (t && t.parent.is("$text")) { t = ih._createBefore(t.parent) } } for (const t of this.markedAttributes) { this._updateAttrs(t) } for (const e of this.markedChildren) { this._updateChildren(e, { inlineFillerPosition: t }) } for (const e of this.markedTexts) { if (!this.markedChildren.has(e.parent) && this.domConverter.mapViewToDom(e.parent)) { this._updateText(e, { inlineFillerPosition: t }) } } if (e) { if (t) { const e = this.domConverter.viewPositionToDom(t); const n = e.parent.ownerDocument; if (!Kh(e.parent)) { this._inlineFiller = rg(n, e.parent, e.offset) } else { this._inlineFiller = e.parent } } else { this._inlineFiller = null } } this._updateFocus(); this._updateSelection(); this.markedTexts.clear(); this.markedAttributes.clear(); this.markedChildren.clear() } _updateChildrenMappings(t) { const e = this.domConverter.mapViewToDom(t); if (!e) { return } const n = Array.from(this.domConverter.mapViewToDom(t).childNodes); const i = Array.from(this.domConverter.viewChildrenToDom(t, { withChildren: false })); const o = this._diffNodeLists(n, i); const r = this._findUpdateActions(o, n, i, sg); if (r.indexOf("update") !== -1) { const e = { equal: 0, insert: 0, delete: 0 }; for (const o of r) { if (o === "update") { const o = e.equal + e.insert; const r = e.equal + e.delete; const s = t.getChild(o); if (s && !(s.is("uiElement") || s.is("rawElement"))) { this._updateElementMappings(s, n[r]) } Cc(i[o]); e.equal++ } else { e[o]++ } } } } _updateElementMappings(t, e) { this.domConverter.unbindDomElement(e); this.domConverter.bindElements(e, t); this.markedChildren.add(t); this.markedAttributes.add(t) } _getInlineFillerPosition() { const t = this.selection.getFirstPosition(); if (t.parent.is("$text")) { return ih._createBefore(t.parent) } else { return t } } _isSelectionInInlineFiller() { if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) { return false } const t = this.selection.getFirstPosition(); const e = this.domConverter.viewPositionToDom(t); if (e && tc(e.parent) && Kh(e.parent)) { return true } return false } _removeInlineFiller() { const t = this._inlineFiller; if (!Kh(t)) { throw new I("view-renderer-filler-was-lost", this) } if (Yh(t)) { t.remove() } else { t.data = t.data.substr(Gh) } this._inlineFiller = null } _needsInlineFillerAtSelection() { if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) { return false } const t = this.selection.getFirstPosition(); const e = t.parent; const n = t.offset; if (!this.domConverter.mapViewToDom(e.root)) { return false } if (!e.is("element")) { return false } if (!og(e)) { return false } if (n === e.getFillerOffset()) { return false } const i = t.nodeBefore; const o = t.nodeAfter; if (i instanceof $l || o instanceof $l) { return false } if (r.isAndroid && (i || o)) { return false } return true } _updateText(t, e) { const n = this.domConverter.findCorrespondingDomText(t); const i = this.domConverter.viewToDom(t); let o = i.data; const r = e.inlineFillerPosition; if (r && r.parent == t.parent && r.offset == t.index) { o = $h + o } hg(n, o) } _updateAttrs(t) { const e = this.domConverter.mapViewToDom(t); if (!e) { return } const n = Array.from(e.attributes).map((t => t.name)); const i = t.getAttributeKeys(); for (const n of i) { this.domConverter.setDomElementAttribute(e, n, t.getAttribute(n), t) } for (const i of n) { if (!t.hasAttribute(i)) { this.domConverter.removeDomElementAttribute(e, i) } } } _updateChildren(t, e) { const n = this.domConverter.mapViewToDom(t); if (!n) { return } if (r.isAndroid) { let t = null; for (const e of Array.from(n.childNodes)) { if (t && tc(t) && tc(e)) { n.normalize(); break } t = e } } const i = e.inlineFillerPosition; const o = n.childNodes; const s = Array.from(this.domConverter.viewChildrenToDom(t, { bind: true })); if (i && i.parent === t) { rg(n.ownerDocument, s, i.offset) } const a = this._diffNodeLists(o, s); const c = this._findUpdateActions(a, o, s, ag); let l = 0; const d = new Set; for (const t of c) { if (t === "delete") { d.add(o[l]); Cc(o[l]) } else if (t === "equal" || t === "update") { l++ } } l = 0; for (const t of c) { if (t === "insert") { hc(n, l, s[l]); l++ } else if (t === "update") { hg(o[l], s[l].data); l++ } else if (t === "equal") { this._markDescendantTextToSync(this.domConverter.domToView(s[l])); l++ } } for (const t of d) { if (!t.parentNode) { this.domConverter.unbindDomElement(t) } } } _diffNodeLists(t, e) { t = dg(t, this._fakeSelectionContainer); return A(t, e, cg.bind(null, this.domConverter)) } _findUpdateActions(t, e, n, i) { if (t.indexOf("insert") === -1 || t.indexOf("delete") === -1) { return t } let o = []; let r = []; let s = []; const a = { equal: 0, insert: 0, delete: 0 }; for (const c of t) { if (c === "insert") { s.push(n[a.equal + a.insert]) } else if (c === "delete") { r.push(e[a.equal + a.delete]) } else { o = o.concat(A(r, s, i).map((t => t === "equal" ? "update" : t))); o.push("equal"); r = []; s = [] } a[c]++ } return o.concat(A(r, s, i).map((t => t === "equal" ? "update" : t))) } _markDescendantTextToSync(t) { if (!t) { return } if (t.is("$text")) { this.markedTexts.add(t) } else if (t.is("element")) { for (const e of t.getChildren()) { this._markDescendantTextToSync(e) } } } _updateSelection() { if (r.isBlink && !r.isAndroid && this.isSelecting && !this.markedChildren.size) { return } if (this.selection.rangeCount === 0) { this._removeDomSelection(); this._removeFakeSelection(); return } const t = this.domConverter.mapViewToDom(this.selection.editableElement); if (!this.isFocused || !t) { return } if (this.selection.isFake) { this._updateFakeSelection(t) } else if (this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected) { this._removeFakeSelection(); this._updateDomSelection(t) } else if (!(this.isComposing && r.isAndroid)) { this._updateDomSelection(t) } } _updateFakeSelection(t) { const e = t.ownerDocument; if (!this._fakeSelectionContainer) { this._fakeSelectionContainer = ug(e) } const n = this._fakeSelectionContainer; this.domConverter.bindFakeSelection(n, this.selection); if (!this._fakeSelectionNeedsUpdate(t)) { return } if (!n.parentElement || n.parentElement != t) { t.appendChild(n) } n.textContent = this.selection.fakeSelectionLabel || " "; const i = e.getSelection(); const o = e.createRange(); i.removeAllRanges(); o.selectNodeContents(n); i.addRange(o) } _updateDomSelection(t) { const e = t.ownerDocument.defaultView.getSelection(); if (!this._domSelectionNeedsUpdate(e)) { return } const n = this.domConverter.viewPositionToDom(this.selection.anchor); const i = this.domConverter.viewPositionToDom(this.selection.focus); e.collapse(n.parent, n.offset); e.extend(i.parent, i.offset); if (r.isGecko) { lg(i, e) } } _domSelectionNeedsUpdate(t) { if (!this.domConverter.isDomSelectionCorrect(t)) { return true } const e = t && this.domConverter.domSelectionToView(t); if (e && this.selection.isEqual(e)) { return false } if (!this.selection.isCollapsed && this.selection.isSimilar(e)) { return false } return true } _fakeSelectionNeedsUpdate(t) { const e = this._fakeSelectionContainer; const n = t.ownerDocument.getSelection(); if (!e || e.parentElement !== t) { return true } if (n.anchorNode !== e && !e.contains(n.anchorNode)) { return true } return e.textContent !== this.selection.fakeSelectionLabel } _removeDomSelection() { for (const t of this.domDocuments) { const e = t.getSelection(); if (e.rangeCount) { const n = t.activeElement; const i = this.domConverter.mapDomToView(n); if (n && i) { e.removeAllRanges() } } } } _removeFakeSelection() { const t = this._fakeSelectionContainer; if (t) { t.remove() } } _updateFocus() { if (this.isFocused) { const t = this.selection.editableElement; if (t) { this.domConverter.focus(t) } } } } function og(t) { if (t.getAttribute("contenteditable") == "false") { return false } const e = t.findAncestor((t => t.hasAttribute("contenteditable"))); return !e || e.getAttribute("contenteditable") == "true" } function rg(t, e, n) { const i = e instanceof Array ? e : e.childNodes; const o = i[n]; if (tc(o)) { o.data = $h + o.data; return o } else { const o = t.createTextNode($h); if (Array.isArray(e)) { i.splice(n, 0, o) } else { hc(e, n, o) } return o } } function sg(t, e) { return Ua(t) && Ua(e) && !tc(t) && !tc(e) && !gc(t) && !gc(e) && t.tagName.toLowerCase() === e.tagName.toLowerCase() } function ag(t, e) { return Ua(t) && Ua(e) && tc(t) && tc(e) } function cg(t, e, n) { if (e === n) { return true } else if (tc(e) && tc(n)) { return e.data === n.data } else if (t.isBlockFiller(e) && t.isBlockFiller(n)) { return true } return false } function lg(t, e) { const n = t.parent; if (n.nodeType != Node.ELEMENT_NODE || t.offset != n.childNodes.length - 1) { return } const i = n.childNodes[t.offset]; if (i && i.tagName == "BR") { e.addRange(e.getRangeAt(0)) } } function dg(t, e) { const n = Array.from(t); if (n.length == 0 || !e) { return n } const i = n[n.length - 1]; if (i == e) { n.pop() } return n } function ug(t) { const e = t.createElement("div"); e.className = "ck-fake-selection-container"; Object.assign(e.style, { position: "fixed", top: 0, left: "-9999px", width: "42px" }); e.textContent = " "; return e } function hg(t, e) { const n = t.data; if (n == e) { return } const i = m(n, e); for (const e of i) { if (e.type === "insert") { t.insertData(e.index, e.values.join("")) } else { t.deleteData(e.index, e.howMany) } } } const gg = qh(Za.document); const mg = Uh(Za.document); const fg = Wh(Za.document); const pg = "data-ck-unsafe-attribute-"; const bg = "data-ck-unsafe-element"; class kg { constructor(t, { blockFillerMode: e, renderingMode: n = "editing" } = {}) { this._domToViewMapping = new WeakMap; this._viewToDomMapping = new WeakMap; this._fakeSelectionMapping = new WeakMap; this._rawContentElementMatcher = new Yl; this._encounteredRawContentDomNodes = new WeakSet; this.document = t; this.renderingMode = n; this.blockFillerMode = e || (n === "editing" ? "br" : "nbsp"); this.preElements = ["pre"]; this.blockElements = ["address", "article", "aside", "blockquote", "caption", "center", "dd", "details", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "legend", "li", "main", "menu", "nav", "ol", "p", "pre", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "ul"]; this.inlineObjectElements = ["object", "iframe", "input", "button", "textarea", "select", "option", "video", "embed", "audio", "img", "canvas"]; this.unsafeElements = ["script", "style"]; this._domDocument = this.renderingMode === "editing" ? Za.document : Za.document.implementation.createHTMLDocument("") } bindFakeSelection(t, e) { this._fakeSelectionMapping.set(t, new sh(e)) } fakeSelectionToView(t) { return this._fakeSelectionMapping.get(t) } bindElements(t, e) { this._domToViewMapping.set(t, e); this._viewToDomMapping.set(e, t) } unbindDomElement(t) { const e = this._domToViewMapping.get(t); if (e) { this._domToViewMapping.delete(t); this._viewToDomMapping.delete(e); for (const e of Array.from(t.children)) { this.unbindDomElement(e) } } } bindDocumentFragments(t, e) { this._domToViewMapping.set(t, e); this._viewToDomMapping.set(e, t) } shouldRenderAttribute(t, e, n) { if (this.renderingMode === "data") { return true } t = t.toLowerCase(); if (t.startsWith("on")) { return false } if (t === "srcdoc" && e.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) { return false } if (n === "img" && (t === "src" || t === "srcset")) { return true } if (n === "source" && t === "srcset") { return true } if (e.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i)) { return false } return true } setContentOf(t, e) { if (this.renderingMode === "data") { t.innerHTML = e; return } const n = (new DOMParser).parseFromString(e, "text/html"); const i = n.createDocumentFragment(); const o = n.body.childNodes; while (o.length > 0) { i.appendChild(o[0]) } const r = n.createTreeWalker(i, NodeFilter.SHOW_ELEMENT); const s = []; let a; while (a = r.nextNode()) { s.push(a) } for (const t of s) { for (const e of t.getAttributeNames()) { this.setDomElementAttribute(t, e, t.getAttribute(e)) } const e = t.tagName.toLowerCase(); if (this._shouldRenameElement(e)) { vg(e); t.replaceWith(this._createReplacementDomElement(e, t)) } } while (t.firstChild) { t.firstChild.remove() } t.append(i) } viewToDom(t, e = {}) { if (t.is("$text")) { const e = this._processDataFromViewText(t); return this._domDocument.createTextNode(e) } else { if (this.mapViewToDom(t)) { return this.mapViewToDom(t) } let n; if (t.is("documentFragment")) { n = this._domDocument.createDocumentFragment(); if (e.bind) { this.bindDocumentFragments(n, t) } } else if (t.is("uiElement")) { if (t.name === "$comment") { n = this._domDocument.createComment(t.getCustomProperty("$rawContent")) } else { n = t.render(this._domDocument, this) } if (e.bind) { this.bindElements(n, t) } return n } else { if (this._shouldRenameElement(t.name)) { vg(t.name); n = this._createReplacementDomElement(t.name) } else if (t.hasAttribute("xmlns")) { n = this._domDocument.createElementNS(t.getAttribute("xmlns"), t.name) } else { n = this._domDocument.createElement(t.name) } if (t.is("rawElement")) { t.render(n, this) } if (e.bind) { this.bindElements(n, t) } for (const e of t.getAttributeKeys()) { this.setDomElementAttribute(n, e, t.getAttribute(e), t) } } if (e.withChildren !== false) { for (const i of this.viewChildrenToDom(t, e)) { n.appendChild(i) } } return n } } setDomElementAttribute(t, e, n, i) { const o = this.shouldRenderAttribute(e, n, t.tagName.toLowerCase()) || i && i.shouldRenderUnsafeAttribute(e); if (!o) { M("domconverter-unsafe-attribute-detected", { domElement: t, key: e, value: n }) } if (t.hasAttribute(e) && !o) { t.removeAttribute(e) } else if (t.hasAttribute(pg + e) && o) { t.removeAttribute(pg + e) } t.setAttribute(o ? e : pg + e, n) } removeDomElementAttribute(t, e) { if (e == bg) { return } t.removeAttribute(e); t.removeAttribute(pg + e) } *viewChildrenToDom(t, e = {}) { const n = t.getFillerOffset && t.getFillerOffset(); let i = 0; for (const o of t.getChildren()) { if (n === i) { yield this._getBlockFiller() } const t = o.is("element") && !!o.getCustomProperty("dataPipeline:transparentRendering") && !ol(o.getAttributes()); if (t && this.renderingMode == "data") { yield* this.viewChildrenToDom(o, e) } else { if (t) { M("domconverter-transparent-rendering-unsupported-in-editing-pipeline", { viewElement: o }) } yield this.viewToDom(o, e) } i++ } if (n === i) { yield this._getBlockFiller() } } viewRangeToDom(t) { const e = this.viewPositionToDom(t.start); const n = this.viewPositionToDom(t.end); const i = this._domDocument.createRange(); i.setStart(e.parent, e.offset); i.setEnd(n.parent, n.offset); return i } viewPositionToDom(t) { const e = t.parent; if (e.is("$text")) { const n = this.findCorrespondingDomText(e); if (!n) { return null } let i = t.offset; if (Kh(n)) { i += Gh } return { parent: n, offset: i } } else { let n, i, o; if (t.offset === 0) { n = this.mapViewToDom(e); if (!n) { return null } o = n.childNodes[0] } else { const e = t.nodeBefore; i = e.is("$text") ? this.findCorrespondingDomText(e) : this.mapViewToDom(e); if (!i) { return null } n = i.parentNode; o = i.nextSibling } if (tc(o) && Kh(o)) { return { parent: o, offset: Gh } } const r = i ? uc(i) + 1 : 0; return { parent: n, offset: r } } } domToView(t, e = {}) { if (this.isBlockFiller(t)) { return null } const n = this.getHostViewElement(t); if (n) { return n } if (gc(t) && e.skipComments) { return null } if (tc(t)) { if (Yh(t)) { return null } else { const e = this._processDataFromDomText(t); return e === "" ? null : new $l(this.document, e) } } else { if (this.mapDomToView(t)) { return this.mapDomToView(t) } let n; if (this.isDocumentFragment(t)) { n = new Th(this.document); if (e.bind) { this.bindDocumentFragments(t, n) } } else { n = this._createViewElement(t, e); if (e.bind) { this.bindElements(t, n) } const i = t.attributes; if (i) { for (let t = i.length, e = 0; e < t; e++) { n._setAttribute(i[e].name, i[e].value) } } if (this._isViewElementWithRawContent(n, e) || gc(t)) { const e = gc(t) ? t.data : t.innerHTML; n._setCustomProperty("$rawContent", e); this._encounteredRawContentDomNodes.add(t); return n } } if (e.withChildren !== false) { for (const i of this.domChildrenToView(t, e)) { n._appendChild(i) } } return n } } *domChildrenToView(t, e) { for (let n = 0; n < t.childNodes.length; n++) { const i = t.childNodes[n]; const o = this.domToView(i, e); if (o !== null) { yield o } } } domSelectionToView(t) { if (t.rangeCount === 1) { let e = t.getRangeAt(0).startContainer; if (tc(e)) { e = e.parentNode } const n = this.fakeSelectionToView(e); if (n) { return n } } const e = this.isDomSelectionBackward(t); const n = []; for (let e = 0; e < t.rangeCount; e++) { const i = t.getRangeAt(e); const o = this.domRangeToView(i); if (o) { n.push(o) } } return new sh(n, { backward: e }) } domRangeToView(t) { const e = this.domPositionToView(t.startContainer, t.startOffset); const n = this.domPositionToView(t.endContainer, t.endOffset); if (e && n) { return new oh(e, n) } return null } domPositionToView(t, e = 0) { if (this.isBlockFiller(t)) { return this.domPositionToView(t.parentNode, uc(t)) } const n = this.mapDomToView(t); if (n && (n.is("uiElement") || n.is("rawElement"))) { return ih._createBefore(n) } if (tc(t)) { if (Yh(t)) { return this.domPositionToView(t.parentNode, uc(t)) } const n = this.findCorrespondingViewText(t); let i = e; if (!n) { return null } if (Kh(t)) { i -= Gh; i = i < 0 ? 0 : i } return new ih(n, i) } else { if (e === 0) { const e = this.mapDomToView(t); if (e) { return new ih(e, 0) } } else { const n = t.childNodes[e - 1]; if (tc(n) && Yh(n) || n && this.isBlockFiller(n)) { return this.domPositionToView(n.parentNode, uc(n)) } const i = tc(n) ? this.findCorrespondingViewText(n) : this.mapDomToView(n); if (i && i.parent) { return new ih(i.parent, i.index + 1) } } return null } } mapDomToView(t) { const e = this.getHostViewElement(t); return e || this._domToViewMapping.get(t) } findCorrespondingViewText(t) { if (Yh(t)) { return null } const e = this.getHostViewElement(t); if (e) { return e } const n = t.previousSibling; if (n) { if (!this.isElement(n)) { return null } const t = this.mapDomToView(n); if (t) { const e = t.nextSibling; if (e instanceof $l) { return e } else { return null } } } else { const e = this.mapDomToView(t.parentNode); if (e) { const t = e.getChild(0); if (t instanceof $l) { return t } else { return null } } } return null } mapViewToDom(t) { return this._viewToDomMapping.get(t) } findCorrespondingDomText(t) { const e = t.previousSibling; if (e && this.mapViewToDom(e)) { return this.mapViewToDom(e).nextSibling } if (!e && t.parent && this.mapViewToDom(t.parent)) { return this.mapViewToDom(t.parent).childNodes[0] } return null } focus(t) { const e = this.mapViewToDom(t); if (e && e.ownerDocument.activeElement !== e) { const { scrollX: t, scrollY: n } = Za.window; const i = []; Ag(e, (t => { const { scrollLeft: e, scrollTop: n } = t; i.push([e, n]) })); e.focus(); Ag(e, (t => { const [e, n] = i.shift(); t.scrollLeft = e; t.scrollTop = n })); Za.window.scrollTo(t, n) } } isElement(t) { return t && t.nodeType == Node.ELEMENT_NODE } isDocumentFragment(t) { return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE } isBlockFiller(t) { if (this.blockFillerMode == "br") { return t.isEqualNode(gg) } if (t.tagName === "BR" && Cg(t, this.blockElements) && t.parentNode.childNodes.length === 1) { return true } return t.isEqualNode(fg) || _g(t, this.blockElements) } isDomSelectionBackward(t) { if (t.isCollapsed) { return false } const e = this._domDocument.createRange(); try { e.setStart(t.anchorNode, t.anchorOffset); e.setEnd(t.focusNode, t.focusOffset) } catch (t) { return false } const n = e.collapsed; e.detach(); return n } getHostViewElement(t) { const e = Ja(t); e.pop(); while (e.length) { const t = e.pop(); const n = this._domToViewMapping.get(t); if (n && (n.is("uiElement") || n.is("rawElement"))) { return n } } return null } isDomSelectionCorrect(t) { return this._isDomSelectionPositionCorrect(t.anchorNode, t.anchorOffset) && this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset) } registerRawContentMatcher(t) { this._rawContentElementMatcher.add(t) } _getBlockFiller() { switch (this.blockFillerMode) { case "nbsp": return Uh(this._domDocument); case "markedNbsp": return Wh(this._domDocument); case "br": return qh(this._domDocument) } } _isDomSelectionPositionCorrect(t, e) { if (tc(t) && Kh(t) && e < Gh) { return false } if (this.isElement(t) && Kh(t.childNodes[e])) { return false } const n = this.mapDomToView(t); if (n && (n.is("uiElement") || n.is("rawElement"))) { return false } return true } _processDataFromViewText(t) { let e = t.data; if (t.getAncestors().some((t => this.preElements.includes(t.name)))) { return e } if (e.charAt(0) == " ") { const n = this._getTouchingInlineViewNode(t, false); const i = n && n.is("$textProxy") && this._nodeEndsWithSpace(n); if (i || !n) { e = " " + e.substr(1) } } if (e.charAt(e.length - 1) == " ") { const n = this._getTouchingInlineViewNode(t, true); const i = n && n.is("$textProxy") && n.data.charAt(0) == " "; if (e.charAt(e.length - 2) == " " || !n || i) { e = e.substr(0, e.length - 1) + " " } } return e.replace(/ {2}/g, "  ") } _nodeEndsWithSpace(t) { if (t.getAncestors().some((t => this.preElements.includes(t.name)))) { return false } const e = this._processDataFromViewText(t); return e.charAt(e.length - 1) == " " } _processDataFromDomText(t) { let e = t.data; if (wg(t, this.preElements)) { return Qh(t) } e = e.replace(/[ \n\t\r]{1,}/g, " "); const n = this._getTouchingInlineDomNode(t, false); const i = this._getTouchingInlineDomNode(t, true); const o = this._checkShouldLeftTrimDomText(t, n); const r = this._checkShouldRightTrimDomText(t, i); if (o) { e = e.replace(/^ /, "") } if (r) { e = e.replace(/ $/, "") } e = Qh(new Text(e)); e = e.replace(/ \u00A0/g, "  "); const s = i && this.isElement(i) && i.tagName != "BR"; const a = i && tc(i) && i.data.charAt(0) == " "; if (/( |\u00A0)\u00A0$/.test(e) || !i || s || a) { e = e.replace(/\u00A0$/, " ") } if (o || n && this.isElement(n) && n.tagName != "BR") { e = e.replace(/^\u00A0/, " ") } return e } _checkShouldLeftTrimDomText(t, e) { if (!e) { return true } if (this.isElement(e)) { return e.tagName === "BR" } if (this._encounteredRawContentDomNodes.has(t.previousSibling)) { return false } return /[^\S\u00A0]/.test(e.data.charAt(e.data.length - 1)) } _checkShouldRightTrimDomText(t, e) { if (e) { return false } return !Kh(t) } _getTouchingInlineViewNode(t, e) { const n = new nh({ startPosition: e ? ih._createAfter(t) : ih._createBefore(t), direction: e ? "forward" : "backward" }); for (const t of n) { if (t.item.is("element") && this.inlineObjectElements.includes(t.item.name)) { return t.item } else if (t.item.is("containerElement")) { return null } else if (t.item.is("element", "br")) { return null } else if (t.item.is("$textProxy")) { return t.item } } return null } _getTouchingInlineDomNode(t, e) { if (!t.parentNode) { return null } const n = e ? "firstChild" : "lastChild"; const i = e ? "nextSibling" : "previousSibling"; let o = true; let r = t; do { if (!o && r[n]) { r = r[n] } else if (r[i]) { r = r[i]; o = false } else { r = r.parentNode; o = true } if (!r || this._isBlockElement(r)) { return null } } while (!(tc(r) || r.tagName == "BR" || this._isInlineObjectElement(r))); return r } _isBlockElement(t) { return this.isElement(t) && this.blockElements.includes(t.tagName.toLowerCase()) } _isInlineObjectElement(t) { return this.isElement(t) && this.inlineObjectElements.includes(t.tagName.toLowerCase()) } _createViewElement(t, e) { if (gc(t)) { return new vh(this.document, "$comment") } const n = e.keepOriginalCase ? t.tagName : t.tagName.toLowerCase(); return new $u(this.document, n) } _isViewElementWithRawContent(t, e) { return e.withChildren !== false && !!this._rawContentElementMatcher.match(t) } _shouldRenameElement(t) { const e = t.toLowerCase(); return this.renderingMode === "editing" && this.unsafeElements.includes(e) } _createReplacementDomElement(t, e) { const n = this._domDocument.createElement("span"); n.setAttribute(bg, t); if (e) { while (e.firstChild) { n.appendChild(e.firstChild) } for (const t of e.getAttributeNames()) { n.setAttribute(t, e.getAttribute(t)) } } return n } } function wg(t, e) { const n = Ja(t); return n.some((t => t.tagName && e.includes(t.tagName.toLowerCase()))) } function Ag(t, e) { let n = t; while (n) { e(n); n = n.parentElement } } function _g(t, e) { const n = t.isEqualNode(mg); return n && Cg(t, e) && t.parentNode.childNodes.length === 1 } function Cg(t, e) { const n = t.parentNode; return !!n && !!n.tagName && e.includes(n.tagName.toLowerCase()) } function vg(t) { if (t === "script") { M("domconverter-unsafe-script-element-detected") } if (t === "style") { M("domconverter-unsafe-style-element-detected") } } class yg extends (Ga()) { constructor(t) { super(); this._isEnabled = false; this.view = t; this.document = t.document } get isEnabled() { return this._isEnabled } enable() { this._isEnabled = true } disable() { this._isEnabled = false } destroy() { this.disable(); this.stopListening() } checkShouldIgnoreEventFromTarget(t) { if (t && t.nodeType === 3) { t = t.parentNode } if (!t || t.nodeType !== 1) { return false } return t.matches("[data-cke-ignore-events], [data-cke-ignore-events] *") } } var xg = zu((function (t, e) { hi(e, Qo(e), t) })); const Eg = xg; class Dg { constructor(t, e, n) { this.view = t; this.document = t.document; this.domEvent = e; this.domTarget = e.target; Eg(this, n) } get target() { return this.view.domConverter.mapDomToView(this.domTarget) } preventDefault() { this.domEvent.preventDefault() } stopPropagation() { this.domEvent.stopPropagation() } } class Sg extends yg { constructor() { super(...arguments); this.useCapture = false } observe(t) { const e = typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType; e.forEach((e => { this.listenTo(t, e, ((t, e) => { if (this.isEnabled && !this.checkShouldIgnoreEventFromTarget(e.target)) { this.onDomEvent(e) } }), { useCapture: this.useCapture }) })) } stopObserving(t) { this.stopListening(t) } fire(t, e, n) { if (this.isEnabled) { this.document.fire(t, new Dg(this.view, e, n)) } } } class Tg extends Sg { constructor() { super(...arguments); this.domEventType = ["keydown", "keyup"] } onDomEvent(t) { const e = { keyCode: t.keyCode, altKey: t.altKey, ctrlKey: t.ctrlKey, shiftKey: t.shiftKey, metaKey: t.metaKey, get keystroke() { return Rc(this) } }; this.fire(t.type, t, e) } } var Ig = function () { return Dt.Date.now() }; const Mg = Ig; var Bg = /\s/; function Lg(t) { var e = t.length; while (e-- && Bg.test(t.charAt(e))) { } return e } const Ng = Lg; var zg = /^\s+/; function Pg(t) { return t ? t.slice(0, Ng(t) + 1).replace(zg, "") : t } const Og = Pg; var Rg = 0 / 0; var Vg = /^[-+]0x[0-9a-f]+$/i; var jg = /^0b[01]+$/i; var Fg = /^0o[0-7]+$/i; var Hg = parseInt; function Ug(t) { if (typeof t == "number") { return t } if (ad(t)) { return Rg } if (nt(t)) { var e = typeof t.valueOf == "function" ? t.valueOf() : t; t = nt(e) ? e + "" : e } if (typeof t != "string") { return t === 0 ? t : +t } t = Og(t); var n = jg.test(t); return n || Fg.test(t) ? Hg(t.slice(2), n ? 2 : 8) : Vg.test(t) ? Rg : +t } const Wg = Ug; var qg = "Expected a function"; var Gg = Math.max, $g = Math.min; function Kg(t, e, n) { var i, o, r, s, a, c, l = 0, d = false, u = false, h = true; if (typeof t != "function") { throw new TypeError(qg) } e = Wg(e) || 0; if (nt(n)) { d = !!n.leading; u = "maxWait" in n; r = u ? Gg(Wg(n.maxWait) || 0, e) : r; h = "trailing" in n ? !!n.trailing : h } function g(e) { var n = i, r = o; i = o = undefined; l = e; s = t.apply(r, n); return s } function m(t) { l = t; a = setTimeout(b, e); return d ? g(t) : s } function f(t) { var n = t - c, i = t - l, o = e - n; return u ? $g(o, r - i) : o } function p(t) { var n = t - c, i = t - l; return c === undefined || n >= e || n < 0 || u && i >= r } function b() { var t = Mg(); if (p(t)) { return k(t) } a = setTimeout(b, f(t)) } function k(t) { a = undefined; if (h && i) { return g(t) } i = o = undefined; return s } function w() { if (a !== undefined) { clearTimeout(a) } l = 0; i = c = o = a = undefined } function A() { return a === undefined ? s : k(Mg()) } function _() { var t = Mg(), n = p(t); i = arguments; o = this; c = t; if (n) { if (a === undefined) { return m(c) } if (u) { clearTimeout(a); a = setTimeout(b, e); return g(c) } } if (a === undefined) { a = setTimeout(b, e) } return s } _.cancel = w; _.flush = A; return _ } const Yg = Kg; class Qg extends yg { constructor(t) { super(t); this._fireSelectionChangeDoneDebounced = Yg((t => { this.document.fire("selectionChangeDone", t) }), 200) } observe() { const t = this.document; t.on("arrowKey", ((e, n) => { const i = t.selection; if (i.isFake && this.isEnabled) { n.preventDefault() } }), { context: "$capture" }); t.on("arrowKey", ((e, n) => { const i = t.selection; if (i.isFake && this.isEnabled) { this._handleSelectionMove(n.keyCode) } }), { priority: "lowest" }) } stopObserving() { } destroy() { super.destroy(); this._fireSelectionChangeDoneDebounced.cancel() } _handleSelectionMove(t) { const e = this.document.selection; const n = new sh(e.getRanges(), { backward: e.isBackward, fake: false }); if (t == Pc.arrowleft || t == Pc.arrowup) { n.setTo(n.getFirstPosition()) } if (t == Pc.arrowright || t == Pc.arrowdown) { n.setTo(n.getLastPosition()) } const i = { oldSelection: e, newSelection: n, domSelection: null }; this.document.fire("selectionChange", i); this._fireSelectionChangeDoneDebounced(i) } } var Zg = "__lodash_hash_undefined__"; function Jg(t) { this.__data__.set(t, Zg); return this } const Xg = Jg; function tm(t) { return this.__data__.has(t) } const em = tm; function nm(t) { var e = -1, n = t == null ? 0 : t.length; this.__data__ = new Yn; while (++e < n) { this.add(t[e]) } } nm.prototype.add = nm.prototype.push = Xg; nm.prototype.has = em; const im = nm; function om(t, e) { var n = -1, i = t == null ? 0 : t.length; while (++n < i) { if (e(t[n], n, t)) { return true } } return false } const rm = om; function sm(t, e) { return t.has(e) } const am = sm; var cm = 1, lm = 2; function dm(t, e, n, i, o, r) { var s = n & cm, a = t.length, c = e.length; if (a != c && !(s && c > a)) { return false } var l = r.get(t); var d = r.get(e); if (l && d) { return l == e && d == t } var u = -1, h = true, g = n & lm ? new im : undefined; r.set(t, e); r.set(e, t); while (++u < a) { var m = t[u], f = e[u]; if (i) { var p = s ? i(f, m, u, e, t, r) : i(m, f, u, t, e, r) } if (p !== undefined) { if (p) { continue } h = false; break } if (g) { if (!rm(e, (function (t, e) { if (!am(g, e) && (m === t || o(m, t, n, i, r))) { return g.push(e) } }))) { h = false; break } } else if (!(m === f || o(m, f, n, i, r))) { h = false; break } } r["delete"](t); r["delete"](e); return h } const um = dm; function hm(t) { var e = -1, n = Array(t.size); t.forEach((function (t, i) { n[++e] = [i, t] })); return n } const gm = hm; function mm(t) { var e = -1, n = Array(t.size); t.forEach((function (t) { n[++e] = t })); return n } const fm = mm; var pm = 1, bm = 2; var km = "[object Boolean]", wm = "[object Date]", Am = "[object Error]", _m = "[object Map]", Cm = "[object Number]", vm = "[object RegExp]", ym = "[object Set]", xm = "[object String]", Em = "[object Symbol]"; var Dm = "[object ArrayBuffer]", Sm = "[object DataView]"; var Tm = Tt ? Tt.prototype : undefined, Im = Tm ? Tm.valueOf : undefined; function Mm(t, e, n, i, o, r, s) { switch (n) { case Sm: if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) { return false } t = t.buffer; e = e.buffer; case Dm: if (t.byteLength != e.byteLength || !r(new os(t), new os(e))) { return false } return true; case km: case wm: case Cm: return me(+t, +e); case Am: return t.name == e.name && t.message == e.message; case vm: case xm: return t == e + ""; case _m: var a = gm; case ym: var c = i & pm; a || (a = fm); if (t.size != e.size && !c) { return false } var l = s.get(t); if (l) { return l == e } i |= bm; s.set(t, e); var d = um(a(t), a(e), i, o, r, s); s["delete"](t); return d; case Em: if (Im) { return Im.call(t) == Im.call(e) } }return false } const Bm = Mm; var Lm = 1; var Nm = Object.prototype; var zm = Nm.hasOwnProperty; function Pm(t, e, n, i, o, r) { var s = n & Lm, a = Tr(t), c = a.length, l = Tr(e), d = l.length; if (c != d && !s) { return false } var u = c; while (u--) { var h = a[u]; if (!(s ? h in e : zm.call(e, h))) { return false } } var g = r.get(t); var m = r.get(e); if (g && m) { return g == e && m == t } var f = true; r.set(t, e); r.set(e, t); var p = s; while (++u < c) { h = a[u]; var b = t[h], k = e[h]; if (i) { var w = s ? i(k, b, h, e, t, r) : i(b, k, h, t, e, r) } if (!(w === undefined ? b === k || o(b, k, n, i, r) : w)) { f = false; break } p || (p = h == "constructor") } if (f && !p) { var A = t.constructor, _ = e.constructor; if (A != _ && ("constructor" in t && "constructor" in e) && !(typeof A == "function" && A instanceof A && typeof _ == "function" && _ instanceof _)) { f = false } } r["delete"](t); r["delete"](e); return f } const Om = Pm; var Rm = 1; var Vm = "[object Arguments]", jm = "[object Array]", Fm = "[object Object]"; var Hm = Object.prototype; var Um = Hm.hasOwnProperty; function Wm(t, e, n, i, o, r) { var s = Gt(t), a = Gt(e), c = s ? jm : Jr(t), l = a ? jm : Jr(e); c = c == Vm ? Fm : c; l = l == Vm ? Fm : l; var d = c == Fm, u = l == Fm, h = c == l; if (h && Mi(t)) { if (!Mi(e)) { return false } s = true; d = false } if (h && !d) { r || (r = new ti); return s || vo(t) ? um(t, e, n, i, o, r) : Bm(t, e, c, n, i, o, r) } if (!(n & Rm)) { var g = d && Um.call(t, "__wrapped__"), m = u && Um.call(e, "__wrapped__"); if (g || m) { var f = g ? t.value() : t, p = m ? e.value() : e; r || (r = new ti); return o(f, p, n, i, r) } } if (!h) { return false } r || (r = new ti); return Om(t, e, n, i, o, r) } const qm = Wm; function Gm(t, e, n, i, o) { if (t === e) { return true } if (t == null || e == null || !Kt(t) && !Kt(e)) { return t !== t && e !== e } return qm(t, e, n, i, Gm, o) } const $m = Gm; function Km(t, e, n) { n = typeof n == "function" ? n : undefined; var i = n ? n(t, e) : undefined; return i === undefined ? $m(t, e, undefined, n) : !!i } const Ym = Km; class Qm extends yg { constructor(t) { super(t); this._config = { childList: true, characterData: true, subtree: true }; this.domConverter = t.domConverter; this.renderer = t._renderer; this._domElements = new Set; this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this)) } flush() { this._onMutations(this._mutationObserver.takeRecords()) } observe(t) { this._domElements.add(t); if (this.isEnabled) { this._mutationObserver.observe(t, this._config) } } stopObserving(t) { this._domElements.delete(t); if (this.isEnabled) { this._mutationObserver.disconnect(); for (const t of this._domElements) { this._mutationObserver.observe(t, this._config) } } } enable() { super.enable(); for (const t of this._domElements) { this._mutationObserver.observe(t, this._config) } } disable() { super.disable(); this._mutationObserver.disconnect() } destroy() { super.destroy(); this._mutationObserver.disconnect() } _onMutations(t) { if (t.length === 0) { return } const e = this.domConverter; const n = new Set; const i = new Set; for (const n of t) { const t = e.mapDomToView(n.target); if (!t) { continue } if (t.is("uiElement") || t.is("rawElement")) { continue } if (n.type === "childList" && !this._isBogusBrMutation(n)) { i.add(t) } } for (const o of t) { const t = e.mapDomToView(o.target); if (t && (t.is("uiElement") || t.is("rawElement"))) { continue } if (o.type === "characterData") { const t = e.findCorrespondingViewText(o.target); if (t && !i.has(t.parent)) { n.add(t) } else if (!t && Kh(o.target)) { i.add(e.mapDomToView(o.target.parentNode)) } } } let o = false; for (const t of n) { o = true; this.renderer.markToSync("text", t) } for (const t of i) { const n = e.mapViewToDom(t); const i = Array.from(t.getChildren()); const r = Array.from(e.domChildrenToView(n, { withChildren: false })); if (!Ym(i, r, Zm)) { o = true; this.renderer.markToSync("children", t) } } if (o) { this.view.forceRender() } } _isBogusBrMutation(t) { let e = null; if (t.nextSibling === null && t.removedNodes.length === 0 && t.addedNodes.length == 1) { e = this.domConverter.domToView(t.addedNodes[0], { withChildren: false }) } return e && e.is("element", "br") } } function Zm(t, e) { if (Array.isArray(t)) { return } if (t === e) { return true } else if (t.is("$text") && e.is("$text")) { return t.data === e.data } return false } class Jm extends Sg { constructor(t) { super(t); this._isFocusChanging = false; this.domEventType = ["focus", "blur"]; this.useCapture = true; const e = this.document; e.on("focus", (() => { this._isFocusChanging = true; this._renderTimeoutId = setTimeout((() => { this.flush(); t.change((() => { })) }), 50) })); e.on("blur", ((n, i) => { const o = e.selection.editableElement; if (o === null || o === i.target) { e.isFocused = false; this._isFocusChanging = false; t.change((() => { })) } })) } flush() { if (this._isFocusChanging) { this._isFocusChanging = false; this.document.isFocused = true } } onDomEvent(t) { this.fire(t.type, t) } destroy() { if (this._renderTimeoutId) { clearTimeout(this._renderTimeoutId) } super.destroy() } } class Xm extends yg { constructor(t) { super(t); this.mutationObserver = t.getObserver(Qm); this.focusObserver = t.getObserver(Jm); this.selection = this.document.selection; this.domConverter = t.domConverter; this._documents = new WeakSet; this._fireSelectionChangeDoneDebounced = Yg((t => { this.document.fire("selectionChangeDone", t) }), 200); this._clearInfiniteLoopInterval = setInterval((() => this._clearInfiniteLoop()), 1e3); this._documentIsSelectingInactivityTimeoutDebounced = Yg((() => this.document.isSelecting = false), 5e3); this._loopbackCounter = 0 } observe(t) { const e = t.ownerDocument; const n = () => { this.document.isSelecting = true; this._documentIsSelectingInactivityTimeoutDebounced() }; const i = () => { if (!this.document.isSelecting) { return } this._handleSelectionChange(null, e); this.document.isSelecting = false; this._documentIsSelectingInactivityTimeoutDebounced.cancel() }; this.listenTo(t, "selectstart", n, { priority: "highest" }); this.listenTo(t, "keydown", i, { priority: "highest", useCapture: true }); this.listenTo(t, "keyup", i, { priority: "highest", useCapture: true }); if (this._documents.has(e)) { return } this.listenTo(e, "mouseup", i, { priority: "highest", useCapture: true }); this.listenTo(e, "selectionchange", ((t, n) => { if (this.document.isComposing && !r.isAndroid) { return } this._handleSelectionChange(n, e); this._documentIsSelectingInactivityTimeoutDebounced() })); this._documents.add(e) } stopObserving(t) { this.stopListening(t) } destroy() { super.destroy(); clearInterval(this._clearInfiniteLoopInterval); this._fireSelectionChangeDoneDebounced.cancel(); this._documentIsSelectingInactivityTimeoutDebounced.cancel() } _reportInfiniteLoop() { } _handleSelectionChange(t, e) { if (!this.isEnabled) { return } const n = e.defaultView.getSelection(); if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) { return } this.mutationObserver.flush(); const i = this.domConverter.domSelectionToView(n); if (i.rangeCount == 0) { this.view.hasDomSelection = false; return } this.view.hasDomSelection = true; if (this.selection.isEqual(i) && this.domConverter.isDomSelectionCorrect(n)) { return } if (++this._loopbackCounter > 60) { this._reportInfiniteLoop(); return } this.focusObserver.flush(); if (this.selection.isSimilar(i)) { this.view.forceRender() } else { const t = { oldSelection: this.selection, newSelection: i, domSelection: n }; this.document.fire("selectionChange", t); this._fireSelectionChangeDoneDebounced(t) } } _clearInfiniteLoop() { this._loopbackCounter = 0 } } class tf extends Sg { constructor(t) { super(t); this.domEventType = ["compositionstart", "compositionupdate", "compositionend"]; const e = this.document; e.on("compositionstart", (() => { e.isComposing = true }), { priority: "low" }); e.on("compositionend", (() => { e.isComposing = false }), { priority: "low" }) } onDomEvent(t) { this.fire(t.type, t, { data: t.data }) } } class ef { constructor(t, e = {}) { this._files = e.cacheFiles ? nf(t) : null; this._native = t } get files() { if (!this._files) { this._files = nf(this._native) } return this._files } get types() { return this._native.types } getData(t) { return this._native.getData(t) } setData(t, e) { this._native.setData(t, e) } set effectAllowed(t) { this._native.effectAllowed = t } get effectAllowed() { return this._native.effectAllowed } set dropEffect(t) { this._native.dropEffect = t } get dropEffect() { return this._native.dropEffect } get isCanceled() { return this._native.dropEffect == "none" || !!this._native.mozUserCancelled } } function nf(t) { const e = Array.from(t.files || []); const n = Array.from(t.items || []); if (e.length) { return e } return n.filter((t => t.kind === "file")).map((t => t.getAsFile())) } class of extends Sg { constructor() { super(...arguments); this.domEventType = "beforeinput" } onDomEvent(t) { const e = t.getTargetRanges(); const n = this.view; const i = n.document; let o = null; let s = null; let a = []; if (t.dataTransfer) { o = new ef(t.dataTransfer) } if (t.data !== null) { s = t.data } else if (o) { s = o.getData("text/plain") } if (i.selection.isFake) { a = Array.from(i.selection.getRanges()) } else if (e.length) { a = e.map((t => n.domConverter.domRangeToView(t))) } else if (r.isAndroid) { const e = t.target.ownerDocument.defaultView.getSelection(); a = Array.from(n.domConverter.domSelectionToView(e).getRanges()) } if (r.isAndroid && t.inputType == "insertCompositionText" && s && s.endsWith("\n")) { this.fire(t.type, t, { inputType: "insertParagraph", targetRanges: [n.createRange(a[0].end)] }); return } if (t.inputType == "insertText" && s && s.includes("\n")) { const e = s.split(/\n{1,2}/g); let n = a; for (let r = 0; r < e.length; r++) { const s = e[r]; if (s != "") { this.fire(t.type, t, { data: s, dataTransfer: o, targetRanges: n, inputType: t.inputType, isComposing: t.isComposing }); n = [i.selection.getFirstRange()] } if (r + 1 < e.length) { this.fire(t.type, t, { inputType: "insertParagraph", targetRanges: n }); n = [i.selection.getFirstRange()] } } return } this.fire(t.type, t, { data: s, dataTransfer: o, targetRanges: a, inputType: t.inputType, isComposing: t.isComposing }) } } class rf extends yg { constructor(t) { super(t); this.document.on("keydown", ((t, e) => { if (this.isEnabled && Fc(e.keyCode)) { const n = new ch(this.document, "arrowKey", this.document.selection.getFirstRange()); this.document.fire(n, e); if (n.stop.called) { t.stop() } } })) } observe() { } stopObserving() { } } class sf extends yg { constructor(t) { super(t); const e = this.document; e.on("keydown", ((t, n) => { if (!this.isEnabled || n.keyCode != Pc.tab || n.ctrlKey) { return } const i = new ch(e, "tab", e.selection.getFirstRange()); e.fire(i, n); if (i.stop.called) { t.stop() } })) } observe() { } stopObserving() { } } class af extends (lt()) { constructor(t) { super(); this.domRoots = new Map; this._initialDomRootAttributes = new WeakMap; this._observers = new Map; this._ongoingChange = false; this._postFixersInProgress = false; this._renderingDisabled = false; this._hasChangedSinceTheLastRendering = false; this.document = new ph(t); this.domConverter = new kg(this.document); this.set("isRenderingInProgress", false); this.set("hasDomSelection", false); this._renderer = new ig(this.domConverter, this.document.selection); this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing"); this._writer = new Mh(this.document); this.addObserver(Qm); this.addObserver(Jm); this.addObserver(Xm); this.addObserver(Tg); this.addObserver(Qg); this.addObserver(tf); this.addObserver(rf); this.addObserver(of); this.addObserver(sf); Zh(this); yh(this); this.on("render", (() => { this._render(); this.document.fire("layoutChanged"); this._hasChangedSinceTheLastRendering = false })); this.listenTo(this.document.selection, "change", (() => { this._hasChangedSinceTheLastRendering = true })); this.listenTo(this.document, "change:isFocused", (() => { this._hasChangedSinceTheLastRendering = true })) } attachDomRoot(t, e = "main") { const n = this.document.getRoot(e); n._name = t.tagName.toLowerCase(); const i = {}; for (const { name: e, value: o } of Array.from(t.attributes)) { i[e] = o; if (e === "class") { this._writer.addClass(o.split(" "), n) } else { this._writer.setAttribute(e, o, n) } } this._initialDomRootAttributes.set(t, i); const o = () => { this._writer.setAttribute("contenteditable", (!n.isReadOnly).toString(), n); if (n.isReadOnly) { this._writer.addClass("ck-read-only", n) } else { this._writer.removeClass("ck-read-only", n) } }; o(); this.domRoots.set(e, t); this.domConverter.bindElements(t, n); this._renderer.markToSync("children", n); this._renderer.markToSync("attributes", n); this._renderer.domDocuments.add(t.ownerDocument); n.on("change:children", ((t, e) => this._renderer.markToSync("children", e))); n.on("change:attributes", ((t, e) => this._renderer.markToSync("attributes", e))); n.on("change:text", ((t, e) => this._renderer.markToSync("text", e))); n.on("change:isReadOnly", (() => this.change(o))); n.on("change", (() => { this._hasChangedSinceTheLastRendering = true })); for (const n of this._observers.values()) { n.observe(t, e) } } detachDomRoot(t) { const e = this.domRoots.get(t); Array.from(e.attributes).forEach((({ name: t }) => e.removeAttribute(t))); const n = this._initialDomRootAttributes.get(e); for (const t in n) { e.setAttribute(t, n[t]) } this.domRoots.delete(t); this.domConverter.unbindDomElement(e); for (const t of this._observers.values()) { t.stopObserving(e) } } getDomRoot(t = "main") { return this.domRoots.get(t) } addObserver(t) { let e = this._observers.get(t); if (e) { return e } e = new t(this); this._observers.set(t, e); for (const [t, n] of this.domRoots) { e.observe(n, t) } e.enable(); return e } getObserver(t) { return this._observers.get(t) } disableObservers() { for (const t of this._observers.values()) { t.disable() } } enableObservers() { for (const t of this._observers.values()) { t.enable() } } scrollToTheSelection({ alignToTop: t, forceScroll: e, viewportOffset: n = 20, ancestorOffset: i = 20 } = {}) { const o = this.document.selection.getFirstRange(); if (o) { vc({ target: this.domConverter.viewRangeToDom(o), viewportOffset: n, ancestorOffset: i, alignToTop: t, forceScroll: e }) } } focus() { if (!this.document.isFocused) { const t = this.document.selection.editableElement; if (t) { this.domConverter.focus(t); this.forceRender() } else { } } } change(t) { if (this.isRenderingInProgress || this._postFixersInProgress) { throw new I("cannot-change-view-tree", this) } try { if (this._ongoingChange) { return t(this._writer) } this._ongoingChange = true; const e = t(this._writer); this._ongoingChange = false; if (!this._renderingDisabled && this._hasChangedSinceTheLastRendering) { this._postFixersInProgress = true; this.document._callPostFixers(this._writer); this._postFixersInProgress = false; this.fire("render") } return e } catch (t) { I.rethrowUnexpectedError(t, this) } } forceRender() { this._hasChangedSinceTheLastRendering = true; this.getObserver(Jm).flush(); this.change((() => { })) } destroy() { for (const t of this._observers.values()) { t.destroy() } this.document.destroy(); this.stopListening() } createPositionAt(t, e) { return ih._createAt(t, e) } createPositionAfter(t) { return ih._createAfter(t) } createPositionBefore(t) { return ih._createBefore(t) } createRange(t, e) { return new oh(t, e) } createRangeOn(t) { return oh._createOn(t) } createRangeIn(t) { return oh._createIn(t) } createSelection(...t) { return new sh(...t) } _disableRendering(t) { this._renderingDisabled = t; if (t == false) { this.change((() => { })) } } _render() { this.isRenderingInProgress = true; this.disableObservers(); this._renderer.render(); this.enableObservers(); this.isRenderingInProgress = false } } class cf { is() { throw new Error("is() method is abstract") } } class lf extends cf { constructor(t) { super(); this.parent = null; this._attrs = cl(t) } get document() { return null } get index() { let t; if (!this.parent) { return null } if ((t = this.parent.getChildIndex(this)) === null) { throw new I("model-node-not-found-in-parent", this) } return t } get startOffset() { let t; if (!this.parent) { return null } if ((t = this.parent.getChildStartOffset(this)) === null) { throw new I("model-node-not-found-in-parent", this) } return t } get offsetSize() { return 1 } get endOffset() { if (!this.parent) { return null } return this.startOffset + this.offsetSize } get nextSibling() { const t = this.index; return t !== null && this.parent.getChild(t + 1) || null } get previousSibling() { const t = this.index; return t !== null && this.parent.getChild(t - 1) || null } get root() { let t = this; while (t.parent) { t = t.parent } return t } isAttached() { return this.parent === null ? false : this.root.isAttached() } getPath() { const t = []; let e = this; while (e.parent) { t.unshift(e.startOffset); e = e.parent } return t } getAncestors(t = {}) { const e = []; let n = t.includeSelf ? this : this.parent; while (n) { e[t.parentFirst ? "push" : "unshift"](n); n = n.parent } return e } getCommonAncestor(t, e = {}) { const n = this.getAncestors(e); const i = t.getAncestors(e); let o = 0; while (n[o] == i[o] && n[o]) { o++ } return o === 0 ? null : n[o - 1] } isBefore(t) { if (this == t) { return false } if (this.root !== t.root) { return false } const e = this.getPath(); const n = t.getPath(); const i = _t(e, n); switch (i) { case "prefix": return true; case "extension": return false; default: return e[i] < n[i] } } isAfter(t) { if (this == t) { return false } if (this.root !== t.root) { return false } return !this.isBefore(t) } hasAttribute(t) { return this._attrs.has(t) } getAttribute(t) { return this._attrs.get(t) } getAttributes() { return this._attrs.entries() } getAttributeKeys() { return this._attrs.keys() } toJSON() { const t = {}; if (this._attrs.size) { t.attributes = Array.from(this._attrs).reduce(((t, e) => { t[e[0]] = e[1]; return t }), {}) } return t } _clone(t) { return new this.constructor(this._attrs) } _remove() { this.parent._removeChildren(this.index) } _setAttribute(t, e) { this._attrs.set(t, e) } _setAttributesTo(t) { this._attrs = cl(t) } _removeAttribute(t) { return this._attrs.delete(t) } _clearAttributes() { this._attrs.clear() } } lf.prototype.is = function (t) { return t === "node" || t === "model:node" }; class df { constructor(t) { this._nodes = []; if (t) { this._insertNodes(0, t) } } [Symbol.iterator]() { return this._nodes[Symbol.iterator]() } get length() { return this._nodes.length } get maxOffset() { return this._nodes.reduce(((t, e) => t + e.offsetSize), 0) } getNode(t) { return this._nodes[t] || null } getNodeIndex(t) { const e = this._nodes.indexOf(t); return e == -1 ? null : e } getNodeStartOffset(t) { const e = this.getNodeIndex(t); return e === null ? null : this._nodes.slice(0, e).reduce(((t, e) => t + e.offsetSize), 0) } indexToOffset(t) { if (t == this._nodes.length) { return this.maxOffset } const e = this._nodes[t]; if (!e) { throw new I("model-nodelist-index-out-of-bounds", this) } return this.getNodeStartOffset(e) } offsetToIndex(t) { let e = 0; for (const n of this._nodes) { if (t >= e && t < e + n.offsetSize) { return this.getNodeIndex(n) } e += n.offsetSize } if (e != t) { throw new I("model-nodelist-offset-out-of-bounds", this, { offset: t, nodeList: this }) } return this.length } _insertNodes(t, e) { for (const t of e) { if (!(t instanceof lf)) { throw new I("model-nodelist-insertnodes-not-node", this) } } this._nodes = dl(this._nodes, Array.from(e), t, 0) } _removeNodes(t, e = 1) { return this._nodes.splice(t, e) } toJSON() { return this._nodes.map((t => t.toJSON())) } } class uf extends lf { constructor(t, e) { super(e); this._data = t || "" } get offsetSize() { return this.data.length } get data() { return this._data } toJSON() { const t = super.toJSON(); t.data = this.data; return t } _clone() { return new uf(this.data, this.getAttributes()) } static fromJSON(t) { return new uf(t.data, t.attributes) } } uf.prototype.is = function (t) { return t === "$text" || t === "model:$text" || t === "text" || t === "model:text" || t === "node" || t === "model:node" }; class hf extends cf { constructor(t, e, n) { super(); this.textNode = t; if (e < 0 || e > t.offsetSize) { throw new I("model-textproxy-wrong-offsetintext", this) } if (n < 0 || e + n > t.offsetSize) { throw new I("model-textproxy-wrong-length", this) } this.data = t.data.substring(e, e + n); this.offsetInText = e } get startOffset() { return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null } get offsetSize() { return this.data.length } get endOffset() { return this.startOffset !== null ? this.startOffset + this.offsetSize : null } get isPartial() { return this.offsetSize !== this.textNode.offsetSize } get parent() { return this.textNode.parent } get root() { return this.textNode.root } getPath() { const t = this.textNode.getPath(); if (t.length > 0) { t[t.length - 1] += this.offsetInText } return t } getAncestors(t = {}) { const e = []; let n = t.includeSelf ? this : this.parent; while (n) { e[t.parentFirst ? "push" : "unshift"](n); n = n.parent } return e } hasAttribute(t) { return this.textNode.hasAttribute(t) } getAttribute(t) { return this.textNode.getAttribute(t) } getAttributes() { return this.textNode.getAttributes() } getAttributeKeys() { return this.textNode.getAttributeKeys() } } hf.prototype.is = function (t) { return t === "$textProxy" || t === "model:$textProxy" || t === "textProxy" || t === "model:textProxy" }; class gf extends lf { constructor(t, e, n) { super(e); this._children = new df; this.name = t; if (n) { this._insertChild(0, n) } } get childCount() { return this._children.length } get maxOffset() { return this._children.maxOffset } get isEmpty() { return this.childCount === 0 } getChild(t) { return this._children.getNode(t) } getChildren() { return this._children[Symbol.iterator]() } getChildIndex(t) { return this._children.getNodeIndex(t) } getChildStartOffset(t) { return this._children.getNodeStartOffset(t) } offsetToIndex(t) { return this._children.offsetToIndex(t) } getNodeByPath(t) { let e = this; for (const n of t) { e = e.getChild(e.offsetToIndex(n)) } return e } findAncestor(t, e = {}) { let n = e.includeSelf ? this : this.parent; while (n) { if (n.name === t) { return n } n = n.parent } return null } toJSON() { const t = super.toJSON(); t.name = this.name; if (this._children.length > 0) { t.children = []; for (const e of this._children) { t.children.push(e.toJSON()) } } return t } _clone(t = false) { const e = t ? Array.from(this._children).map((t => t._clone(true))) : undefined; return new gf(this.name, this.getAttributes(), e) } _appendChild(t) { this._insertChild(this.childCount, t) } _insertChild(t, e) { const n = mf(e); for (const t of n) { if (t.parent !== null) { t._remove() } t.parent = this } this._children._insertNodes(t, n) } _removeChildren(t, e = 1) { const n = this._children._removeNodes(t, e); for (const t of n) { t.parent = null } return n } static fromJSON(t) { let e; if (t.children) { e = []; for (const n of t.children) { if (n.name) { e.push(gf.fromJSON(n)) } else { e.push(uf.fromJSON(n)) } } } return new gf(t.name, t.attributes, e) } } gf.prototype.is = function (t, e) { if (!e) { return t === "element" || t === "model:element" || t === "node" || t === "model:node" } return e === this.name && (t === "element" || t === "model:element") }; function mf(t) { if (typeof t == "string") { return [new uf(t)] } if (!Ct(t)) { t = [t] } return Array.from(t).map((t => { if (typeof t == "string") { return new uf(t) } if (t instanceof hf) { return new uf(t.data, t.getAttributes()) } return t })) } class ff { constructor(t) { if (!t || !t.boundaries && !t.startPosition) { throw new I("model-tree-walker-no-start-position", null) } const e = t.direction || "forward"; if (e != "forward" && e != "backward") { throw new I("model-tree-walker-unknown-direction", t, { direction: e }) } this.direction = e; this.boundaries = t.boundaries || null; if (t.startPosition) { this._position = t.startPosition.clone() } else { this._position = bf._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]) } this.position.stickiness = "toNone"; this.singleCharacters = !!t.singleCharacters; this.shallow = !!t.shallow; this.ignoreElementEnd = !!t.ignoreElementEnd; this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null; this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null; this._visitedParent = this.position.parent } [Symbol.iterator]() { return this } get position() { return this._position } skip(t) { let e, n, i, o; do { i = this.position; o = this._visitedParent; ({ done: e, value: n } = this.next()) } while (!e && t(n)); if (!e) { this._position = i; this._visitedParent = o } } next() { if (this.direction == "forward") { return this._next() } else { return this._previous() } } _next() { const t = this.position; const e = this.position.clone(); const n = this._visitedParent; if (n.parent === null && e.offset === n.maxOffset) { return { done: true, value: undefined } } if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset) { return { done: true, value: undefined } } const i = kf(e, n); const o = i ? i : wf(e, n, i); if (o instanceof gf) { if (!this.shallow) { e.path.push(0); this._visitedParent = o } else { e.offset++ } this._position = e; return pf("elementStart", o, t, e, 1) } else if (o instanceof uf) { let i; if (this.singleCharacters) { i = 1 } else { let t = o.endOffset; if (this._boundaryEndParent == n && this.boundaries.end.offset < t) { t = this.boundaries.end.offset } i = t - e.offset } const r = e.offset - o.startOffset; const s = new hf(o, r, i); e.offset += i; this._position = e; return pf("text", s, t, e, i) } else { e.path.pop(); e.offset++; this._position = e; this._visitedParent = n.parent; if (this.ignoreElementEnd) { return this._next() } else { return pf("elementEnd", n, t, e) } } } _previous() { const t = this.position; const e = this.position.clone(); const n = this._visitedParent; if (n.parent === null && e.offset === 0) { return { done: true, value: undefined } } if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset) { return { done: true, value: undefined } } const i = e.parent; const o = kf(e, i); const r = o ? o : Af(e, i, o); if (r instanceof gf) { e.offset--; if (!this.shallow) { e.path.push(r.maxOffset); this._position = e; this._visitedParent = r; if (this.ignoreElementEnd) { return this._previous() } else { return pf("elementEnd", r, t, e) } } else { this._position = e; return pf("elementStart", r, t, e, 1) } } else if (r instanceof uf) { let i; if (this.singleCharacters) { i = 1 } else { let t = r.startOffset; if (this._boundaryStartParent == n && this.boundaries.start.offset > t) { t = this.boundaries.start.offset } i = e.offset - t } const o = e.offset - r.startOffset; const s = new hf(r, o - i, i); e.offset -= i; this._position = e; return pf("text", s, t, e, i) } else { e.path.pop(); this._position = e; this._visitedParent = n.parent; return pf("elementStart", n, t, e, 1) } } } function pf(t, e, n, i, o) { return { done: false, value: { type: t, item: e, previousPosition: n, nextPosition: i, length: o } } } class bf extends cf { constructor(t, e, n = "toNone") { super(); if (!t.is("element") && !t.is("documentFragment")) { throw new I("model-position-root-invalid", t) } if (!(e instanceof Array) || e.length === 0) { throw new I("model-position-path-incorrect-format", t, { path: e }) } if (t.is("rootElement")) { e = e.slice() } else { e = [...t.getPath(), ...e]; t = t.root } this.root = t; this.path = e; this.stickiness = n } get offset() { return this.path[this.path.length - 1] } set offset(t) { this.path[this.path.length - 1] = t } get parent() { let t = this.root; for (let e = 0; e < this.path.length - 1; e++) { t = t.getChild(t.offsetToIndex(this.path[e])); if (!t) { throw new I("model-position-path-incorrect", this, { position: this }) } } if (t.is("$text")) { throw new I("model-position-path-incorrect", this, { position: this }) } return t } get index() { return this.parent.offsetToIndex(this.offset) } get textNode() { return kf(this, this.parent) } get nodeAfter() { const t = this.parent; return wf(this, t, kf(this, t)) } get nodeBefore() { const t = this.parent; return Af(this, t, kf(this, t)) } get isAtStart() { return this.offset === 0 } get isAtEnd() { return this.offset == this.parent.maxOffset } compareWith(t) { if (this.root != t.root) { return "different" } const e = _t(this.path, t.path); switch (e) { case "same": return "same"; case "prefix": return "before"; case "extension": return "after"; default: return this.path[e] < t.path[e] ? "before" : "after" } } getLastMatchingPosition(t, e = {}) { e.startPosition = this; const n = new ff(e); n.skip(t); return n.position } getParentPath() { return this.path.slice(0, -1) } getAncestors() { const t = this.parent; if (t.is("documentFragment")) { return [t] } else { return t.getAncestors({ includeSelf: true }) } } findAncestor(t) { const e = this.parent; if (e.is("element")) { return e.findAncestor(t, { includeSelf: true }) } return null } getCommonPath(t) { if (this.root != t.root) { return [] } const e = _t(this.path, t.path); const n = typeof e == "string" ? Math.min(this.path.length, t.path.length) : e; return this.path.slice(0, n) } getCommonAncestor(t) { const e = this.getAncestors(); const n = t.getAncestors(); let i = 0; while (e[i] == n[i] && e[i]) { i++ } return i === 0 ? null : e[i - 1] } getShiftedBy(t) { const e = this.clone(); const n = e.offset + t; e.offset = n < 0 ? 0 : n; return e } isAfter(t) { return this.compareWith(t) == "after" } isBefore(t) { return this.compareWith(t) == "before" } isEqual(t) { return this.compareWith(t) == "same" } isTouching(t) { if (this.root !== t.root) { return false } const e = Math.min(this.path.length, t.path.length); for (let n = 0; n < e; n++) { const e = this.path[n] - t.path[n]; if (e < -1 || e > 1) { return false } else if (e === 1) { return _f(t, this, n) } else if (e === -1) { return _f(this, t, n) } } if (this.path.length === t.path.length) { return true } else if (this.path.length > t.path.length) { return Cf(this.path, e) } else { return Cf(t.path, e) } } hasSameParentAs(t) { if (this.root !== t.root) { return false } const e = this.getParentPath(); const n = t.getParentPath(); return _t(e, n) == "same" } getTransformedByOperation(t) { let e; switch (t.type) { case "insert": e = this._getTransformedByInsertOperation(t); break; case "move": case "remove": case "reinsert": e = this._getTransformedByMoveOperation(t); break; case "split": e = this._getTransformedBySplitOperation(t); break; case "merge": e = this._getTransformedByMergeOperation(t); break; default: e = bf._createAt(this); break }return e } _getTransformedByInsertOperation(t) { return this._getTransformedByInsertion(t.position, t.howMany) } _getTransformedByMoveOperation(t) { return this._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany) } _getTransformedBySplitOperation(t) { const e = t.movedRange; const n = e.containsPosition(this) || e.start.isEqual(this) && this.stickiness == "toNext"; if (n) { return this._getCombined(t.splitPosition, t.moveTargetPosition) } else { if (t.graveyardPosition) { return this._getTransformedByMove(t.graveyardPosition, t.insertionPosition, 1) } else { return this._getTransformedByInsertion(t.insertionPosition, 1) } } } _getTransformedByMergeOperation(t) { const e = t.movedRange; const n = e.containsPosition(this) || e.start.isEqual(this); let i; if (n) { i = this._getCombined(t.sourcePosition, t.targetPosition); if (t.sourcePosition.isBefore(t.targetPosition)) { i = i._getTransformedByDeletion(t.deletionPosition, 1) } } else if (this.isEqual(t.deletionPosition)) { i = bf._createAt(t.deletionPosition) } else { i = this._getTransformedByMove(t.deletionPosition, t.graveyardPosition, 1) } return i } _getTransformedByDeletion(t, e) { const n = bf._createAt(this); if (this.root != t.root) { return n } if (_t(t.getParentPath(), this.getParentPath()) == "same") { if (t.offset < this.offset) { if (t.offset + e > this.offset) { return null } else { n.offset -= e } } } else if (_t(t.getParentPath(), this.getParentPath()) == "prefix") { const i = t.path.length - 1; if (t.offset <= this.path[i]) { if (t.offset + e > this.path[i]) { return null } else { n.path[i] -= e } } } return n } _getTransformedByInsertion(t, e) { const n = bf._createAt(this); if (this.root != t.root) { return n } if (_t(t.getParentPath(), this.getParentPath()) == "same") { if (t.offset < this.offset || t.offset == this.offset && this.stickiness != "toPrevious") { n.offset += e } } else if (_t(t.getParentPath(), this.getParentPath()) == "prefix") { const i = t.path.length - 1; if (t.offset <= this.path[i]) { n.path[i] += e } } return n } _getTransformedByMove(t, e, n) { e = e._getTransformedByDeletion(t, n); if (t.isEqual(e)) { return bf._createAt(this) } const i = this._getTransformedByDeletion(t, n); const o = i === null || t.isEqual(this) && this.stickiness == "toNext" || t.getShiftedBy(n).isEqual(this) && this.stickiness == "toPrevious"; if (o) { return this._getCombined(t, e) } else { return i._getTransformedByInsertion(e, n) } } _getCombined(t, e) { const n = t.path.length - 1; const i = bf._createAt(e); i.stickiness = this.stickiness; i.offset = i.offset + this.path[n] - t.offset; i.path = [...i.path, ...this.path.slice(n + 1)]; return i } toJSON() { return { root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness } } clone() { return new this.constructor(this.root, this.path, this.stickiness) } static _createAt(t, e, n = "toNone") { if (t instanceof bf) { return new bf(t.root, t.path, t.stickiness) } else { const i = t; if (e == "end") { e = i.maxOffset } else if (e == "before") { return this._createBefore(i, n) } else if (e == "after") { return this._createAfter(i, n) } else if (e !== 0 && !e) { throw new I("model-createpositionat-offset-required", [this, t]) } if (!i.is("element") && !i.is("documentFragment")) { throw new I("model-position-parent-incorrect", [this, t]) } const o = i.getPath(); o.push(e); return new this(i.root, o, n) } } static _createAfter(t, e) { if (!t.parent) { throw new I("model-position-after-root", [this, t], { root: t }) } return this._createAt(t.parent, t.endOffset, e) } static _createBefore(t, e) { if (!t.parent) { throw new I("model-position-before-root", t, { root: t }) } return this._createAt(t.parent, t.startOffset, e) } static fromJSON(t, e) { if (t.root === "$graveyard") { const n = new bf(e.graveyard, t.path); n.stickiness = t.stickiness; return n } if (!e.getRoot(t.root)) { throw new I("model-position-fromjson-no-root", e, { rootName: t.root }) } return new bf(e.getRoot(t.root), t.path, t.stickiness) } } bf.prototype.is = function (t) { return t === "position" || t === "model:position" }; function kf(t, e) { const n = e.getChild(e.offsetToIndex(t.offset)); if (n && n.is("$text") && n.startOffset < t.offset) { return n } return null } function wf(t, e, n) { if (n !== null) { return null } return e.getChild(e.offsetToIndex(t.offset)) } function Af(t, e, n) { if (n !== null) { return null } return e.getChild(e.offsetToIndex(t.offset) - 1) } function _f(t, e, n) { if (n + 1 === t.path.length) { return false } if (!Cf(e.path, n + 1)) { return false } if (!vf(t, n + 1)) { return false } return true } function Cf(t, e) { while (e < t.length) { if (t[e] !== 0) { return false } e++ } return true } function vf(t, e) { let n = t.parent; let i = t.path.length - 1; let o = 0; while (i >= e) { if (t.path[i] + o !== n.maxOffset) { return false } o = 1; i--; n = n.parent } return true } class yf extends cf { constructor(t, e) { super(); this.start = bf._createAt(t); this.end = e ? bf._createAt(e) : bf._createAt(t); this.start.stickiness = this.isCollapsed ? "toNone" : "toNext"; this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious" } *[Symbol.iterator]() { yield* new ff({ boundaries: this, ignoreElementEnd: true }) } get isCollapsed() { return this.start.isEqual(this.end) } get isFlat() { const t = this.start.getParentPath(); const e = this.end.getParentPath(); return _t(t, e) == "same" } get root() { return this.start.root } containsPosition(t) { return t.isAfter(this.start) && t.isBefore(this.end) } containsRange(t, e = false) { if (t.isCollapsed) { e = false } const n = this.containsPosition(t.start) || e && this.start.isEqual(t.start); const i = this.containsPosition(t.end) || e && this.end.isEqual(t.end); return n && i } containsItem(t) { const e = bf._createBefore(t); return this.containsPosition(e) || this.start.isEqual(e) } isEqual(t) { return this.start.isEqual(t.start) && this.end.isEqual(t.end) } isIntersecting(t) { return this.start.isBefore(t.end) && this.end.isAfter(t.start) } getDifference(t) { const e = []; if (this.isIntersecting(t)) { if (this.containsPosition(t.start)) { e.push(new yf(this.start, t.start)) } if (this.containsPosition(t.end)) { e.push(new yf(t.end, this.end)) } } else { e.push(new yf(this.start, this.end)) } return e } getIntersection(t) { if (this.isIntersecting(t)) { let e = this.start; let n = this.end; if (this.containsPosition(t.start)) { e = t.start } if (this.containsPosition(t.end)) { n = t.end } return new yf(e, n) } return null } getJoined(t, e = false) { let n = this.isIntersecting(t); if (!n) { if (this.start.isBefore(t.start)) { n = e ? this.end.isTouching(t.start) : this.end.isEqual(t.start) } else { n = e ? t.end.isTouching(this.start) : t.end.isEqual(this.start) } } if (!n) { return null } let i = this.start; let o = this.end; if (t.start.isBefore(i)) { i = t.start } if (t.end.isAfter(o)) { o = t.end } return new yf(i, o) } getMinimalFlatRanges() { const t = []; const e = this.start.getCommonPath(this.end).length; const n = bf._createAt(this.start); let i = n.parent; while (n.path.length > e + 1) { const e = i.maxOffset - n.offset; if (e !== 0) { t.push(new yf(n, n.getShiftedBy(e))) } n.path = n.path.slice(0, -1); n.offset++; i = i.parent } while (n.path.length <= this.end.path.length) { const e = this.end.path[n.path.length - 1]; const i = e - n.offset; if (i !== 0) { t.push(new yf(n, n.getShiftedBy(i))) } n.offset = e; n.path.push(0) } return t } getWalker(t = {}) { t.boundaries = this; return new ff(t) } *getItems(t = {}) { t.boundaries = this; t.ignoreElementEnd = true; const e = new ff(t); for (const t of e) { yield t.item } } *getPositions(t = {}) { t.boundaries = this; const e = new ff(t); yield e.position; for (const t of e) { yield t.nextPosition } } getTransformedByOperation(t) { switch (t.type) { case "insert": return this._getTransformedByInsertOperation(t); case "move": case "remove": case "reinsert": return this._getTransformedByMoveOperation(t); case "split": return [this._getTransformedBySplitOperation(t)]; case "merge": return [this._getTransformedByMergeOperation(t)] }return [new yf(this.start, this.end)] } getTransformedByOperations(t) { const e = [new yf(this.start, this.end)]; for (const n of t) { for (let t = 0; t < e.length; t++) { const i = e[t].getTransformedByOperation(n); e.splice(t, 1, ...i); t += i.length - 1 } } for (let t = 0; t < e.length; t++) { const n = e[t]; for (let i = t + 1; i < e.length; i++) { const t = e[i]; if (n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) { e.splice(i, 1) } } } return e } getCommonAncestor() { return this.start.getCommonAncestor(this.end) } getContainedElement() { if (this.isCollapsed) { return null } const t = this.start.nodeAfter; const e = this.end.nodeBefore; if (t && t.is("element") && t === e) { return t } return null } toJSON() { return { start: this.start.toJSON(), end: this.end.toJSON() } } clone() { return new this.constructor(this.start, this.end) } _getTransformedByInsertOperation(t, e = false) { return this._getTransformedByInsertion(t.position, t.howMany, e) } _getTransformedByMoveOperation(t, e = false) { const n = t.sourcePosition; const i = t.howMany; const o = t.targetPosition; return this._getTransformedByMove(n, o, i, e) } _getTransformedBySplitOperation(t) { const e = this.start._getTransformedBySplitOperation(t); let n = this.end._getTransformedBySplitOperation(t); if (this.end.isEqual(t.insertionPosition)) { n = this.end.getShiftedBy(1) } if (e.root != n.root) { n = this.end.getShiftedBy(-1) } return new yf(e, n) } _getTransformedByMergeOperation(t) { if (this.start.isEqual(t.targetPosition) && this.end.isEqual(t.deletionPosition)) { return new yf(this.start) } let e = this.start._getTransformedByMergeOperation(t); let n = this.end._getTransformedByMergeOperation(t); if (e.root != n.root) { n = this.end.getShiftedBy(-1) } if (e.isAfter(n)) { if (t.sourcePosition.isBefore(t.targetPosition)) { e = bf._createAt(n); e.offset = 0 } else { if (!t.deletionPosition.isEqual(e)) { n = t.deletionPosition } e = t.targetPosition } return new yf(e, n) } return new yf(e, n) } _getTransformedByInsertion(t, e, n = false) { if (n && this.containsPosition(t)) { return [new yf(this.start, t), new yf(t.getShiftedBy(e), this.end._getTransformedByInsertion(t, e))] } else { const n = new yf(this.start, this.end); n.start = n.start._getTransformedByInsertion(t, e); n.end = n.end._getTransformedByInsertion(t, e); return [n] } } _getTransformedByMove(t, e, n, i = false) { if (this.isCollapsed) { const i = this.start._getTransformedByMove(t, e, n); return [new yf(i)] } const o = yf._createFromPositionAndShift(t, n); const r = e._getTransformedByDeletion(t, n); if (this.containsPosition(e) && !i) { if (o.containsPosition(this.start) || o.containsPosition(this.end)) { const i = this.start._getTransformedByMove(t, e, n); const o = this.end._getTransformedByMove(t, e, n); return [new yf(i, o)] } } let s; const a = this.getDifference(o); let c = null; const l = this.getIntersection(o); if (a.length == 1) { c = new yf(a[0].start._getTransformedByDeletion(t, n), a[0].end._getTransformedByDeletion(t, n)) } else if (a.length == 2) { c = new yf(this.start, this.end._getTransformedByDeletion(t, n)) } if (c) { s = c._getTransformedByInsertion(r, n, l !== null || i) } else { s = [] } if (l) { const t = new yf(l.start._getCombined(o.start, r), l.end._getCombined(o.start, r)); if (s.length == 2) { s.splice(1, 0, t) } else { s.push(t) } } return s } _getTransformedByDeletion(t, e) { let n = this.start._getTransformedByDeletion(t, e); let i = this.end._getTransformedByDeletion(t, e); if (n == null && i == null) { return null } if (n == null) { n = t } if (i == null) { i = t } return new yf(n, i) } static _createFromPositionAndShift(t, e) { const n = t; const i = t.getShiftedBy(e); return e > 0 ? new this(n, i) : new this(i, n) } static _createIn(t) { return new this(bf._createAt(t, 0), bf._createAt(t, t.maxOffset)) } static _createOn(t) { return this._createFromPositionAndShift(bf._createBefore(t), t.offsetSize) } static _createFromRanges(t) { if (t.length === 0) { throw new I("range-create-from-ranges-empty-array", null) } else if (t.length == 1) { return t[0].clone() } const e = t[0]; t.sort(((t, e) => t.start.isAfter(e.start) ? 1 : -1)); const n = t.indexOf(e); const i = new this(e.start, e.end); if (n > 0) { for (let e = n - 1; true; e++) { if (t[e].end.isEqual(i.start)) { i.start = bf._createAt(t[e].start) } else { break } } } for (let e = n + 1; e < t.length; e++) { if (t[e].start.isEqual(i.end)) { i.end = bf._createAt(t[e].end) } else { break } } return i } static fromJSON(t, e) { return new this(bf.fromJSON(t.start, e), bf.fromJSON(t.end, e)) } } yf.prototype.is = function (t) { return t === "range" || t === "model:range" }; class xf extends (U()) { constructor() { super(); this._modelToViewMapping = new WeakMap; this._viewToModelMapping = new WeakMap; this._viewToModelLengthCallbacks = new Map; this._markerNameToElements = new Map; this._elementToMarkerNames = new Map; this._deferredBindingRemovals = new Map; this._unboundMarkerNames = new Set; this.on("modelToViewPosition", ((t, e) => { if (e.viewPosition) { return } const n = this._modelToViewMapping.get(e.modelPosition.parent); if (!n) { throw new I("mapping-model-position-view-parent-not-found", this, { modelPosition: e.modelPosition }) } e.viewPosition = this.findPositionIn(n, e.modelPosition.offset) }), { priority: "low" }); this.on("viewToModelPosition", ((t, e) => { if (e.modelPosition) { return } const n = this.findMappedViewAncestor(e.viewPosition); const i = this._viewToModelMapping.get(n); const o = this._toModelOffset(e.viewPosition.parent, e.viewPosition.offset, n); e.modelPosition = bf._createAt(i, o) }), { priority: "low" }) } bindElements(t, e) { this._modelToViewMapping.set(t, e); this._viewToModelMapping.set(e, t) } unbindViewElement(t, e = {}) { const n = this.toModelElement(t); if (this._elementToMarkerNames.has(t)) { for (const e of this._elementToMarkerNames.get(t)) { this._unboundMarkerNames.add(e) } } if (e.defer) { this._deferredBindingRemovals.set(t, t.root) } else { this._viewToModelMapping.delete(t); if (this._modelToViewMapping.get(n) == t) { this._modelToViewMapping.delete(n) } } } unbindModelElement(t) { const e = this.toViewElement(t); this._modelToViewMapping.delete(t); if (this._viewToModelMapping.get(e) == t) { this._viewToModelMapping.delete(e) } } bindElementToMarker(t, e) { const n = this._markerNameToElements.get(e) || new Set; n.add(t); const i = this._elementToMarkerNames.get(t) || new Set; i.add(e); this._markerNameToElements.set(e, n); this._elementToMarkerNames.set(t, i) } unbindElementFromMarkerName(t, e) { const n = this._markerNameToElements.get(e); if (n) { n.delete(t); if (n.size == 0) { this._markerNameToElements.delete(e) } } const i = this._elementToMarkerNames.get(t); if (i) { i.delete(e); if (i.size == 0) { this._elementToMarkerNames.delete(t) } } } flushUnboundMarkerNames() { const t = Array.from(this._unboundMarkerNames); this._unboundMarkerNames.clear(); return t } flushDeferredBindings() { for (const [t, e] of this._deferredBindingRemovals) { if (t.root == e) { this.unbindViewElement(t) } } this._deferredBindingRemovals = new Map } clearBindings() { this._modelToViewMapping = new WeakMap; this._viewToModelMapping = new WeakMap; this._markerNameToElements = new Map; this._elementToMarkerNames = new Map; this._unboundMarkerNames = new Set; this._deferredBindingRemovals = new Map } toModelElement(t) { return this._viewToModelMapping.get(t) } toViewElement(t) { return this._modelToViewMapping.get(t) } toModelRange(t) { return new yf(this.toModelPosition(t.start), this.toModelPosition(t.end)) } toViewRange(t) { return new oh(this.toViewPosition(t.start), this.toViewPosition(t.end)) } toModelPosition(t) { const e = { viewPosition: t, mapper: this }; this.fire("viewToModelPosition", e); return e.modelPosition } toViewPosition(t, e = {}) { const n = { modelPosition: t, mapper: this, isPhantom: e.isPhantom }; this.fire("modelToViewPosition", n); return n.viewPosition } markerNameToElements(t) { const e = this._markerNameToElements.get(t); if (!e) { return null } const n = new Set; for (const t of e) { if (t.is("attributeElement")) { for (const e of t.getElementsWithSameId()) { n.add(e) } } else { n.add(t) } } return n } registerViewToModelLength(t, e) { this._viewToModelLengthCallbacks.set(t, e) } findMappedViewAncestor(t) { let e = t.parent; while (!this._viewToModelMapping.has(e)) { e = e.parent } return e } _toModelOffset(t, e, n) { if (n != t) { const i = this._toModelOffset(t.parent, t.index, n); const o = this._toModelOffset(t, e, t); return i + o } if (t.is("$text")) { return e } let i = 0; for (let n = 0; n < e; n++) { i += this.getModelLength(t.getChild(n)) } return i } getModelLength(t) { if (this._viewToModelLengthCallbacks.get(t.name)) { const e = this._viewToModelLengthCallbacks.get(t.name); return e(t) } else if (this._viewToModelMapping.has(t)) { return 1 } else if (t.is("$text")) { return t.data.length } else if (t.is("uiElement")) { return 0 } else { let e = 0; for (const n of t.getChildren()) { e += this.getModelLength(n) } return e } } findPositionIn(t, e) { let n; let i = 0; let o = 0; let r = 0; if (t.is("$text")) { return new ih(t, e) } while (o < e) { n = t.getChild(r); i = this.getModelLength(n); o += i; r++ } if (o == e) { return this._moveViewPositionToTextNode(new ih(t, r)) } else { return this.findPositionIn(n, e - (o - i)) } } _moveViewPositionToTextNode(t) { const e = t.nodeBefore; const n = t.nodeAfter; if (e instanceof $l) { return new ih(e, e.data.length) } else if (n instanceof $l) { return new ih(n, 0) } return t } } class Ef { constructor() { this._consumable = new Map; this._textProxyRegistry = new Map } add(t, e) { e = Df(e); if (t instanceof hf) { t = this._getSymbolForTextProxy(t) } if (!this._consumable.has(t)) { this._consumable.set(t, new Map) } this._consumable.get(t).set(e, true) } consume(t, e) { e = Df(e); if (t instanceof hf) { t = this._getSymbolForTextProxy(t) } if (this.test(t, e)) { this._consumable.get(t).set(e, false); return true } else { return false } } test(t, e) { e = Df(e); if (t instanceof hf) { t = this._getSymbolForTextProxy(t) } const n = this._consumable.get(t); if (n === undefined) { return null } const i = n.get(e); if (i === undefined) { return null } return i } revert(t, e) { e = Df(e); if (t instanceof hf) { t = this._getSymbolForTextProxy(t) } const n = this.test(t, e); if (n === false) { this._consumable.get(t).set(e, true); return true } else if (n === true) { return false } return null } verifyAllConsumed(t) { const e = []; for (const [n, i] of this._consumable) { for (const [o, r] of i) { const i = o.split(":")[0]; if (r && t == i) { e.push({ event: o, item: n.name || n.description }) } } } if (e.length) { throw new I("conversion-model-consumable-not-consumed", null, { items: e }) } } _getSymbolForTextProxy(t) { let e = null; const n = this._textProxyRegistry.get(t.startOffset); if (n) { const i = n.get(t.endOffset); if (i) { e = i.get(t.parent) } } if (!e) { e = this._addSymbolForTextProxy(t) } return e } _addSymbolForTextProxy(t) { const e = t.startOffset; const n = t.endOffset; const i = t.parent; const o = Symbol("$textProxy:" + t.data); let r; let s; r = this._textProxyRegistry.get(e); if (!r) { r = new Map; this._textProxyRegistry.set(e, r) } s = r.get(n); if (!s) { s = new Map; r.set(n, s) } s.set(i, o); return o } } function Df(t) { const e = t.split(":"); if (e[0] == "insert") { return e[0] } if (e[0] == "addMarker" || e[0] == "removeMarker") { return t } return e.length > 1 ? e[0] + ":" + e[1] : e[0] } class Sf extends (U()) { constructor(t) { super(); this._conversionApi = { dispatcher: this, ...t }; this._firedEventsMap = new WeakMap } convertChanges(t, e, n) { const i = this._createConversionApi(n, t.getRefreshedItems()); for (const e of t.getMarkersToRemove()) { this._convertMarkerRemove(e.name, e.range, i) } const o = this._reduceChanges(t.getChanges()); for (const t of o) { if (t.type === "insert") { this._convertInsert(yf._createFromPositionAndShift(t.position, t.length), i) } else if (t.type === "reinsert") { this._convertReinsert(yf._createFromPositionAndShift(t.position, t.length), i) } else if (t.type === "remove") { this._convertRemove(t.position, t.length, t.name, i) } else { this._convertAttribute(t.range, t.attributeKey, t.attributeOldValue, t.attributeNewValue, i) } } for (const t of i.mapper.flushUnboundMarkerNames()) { const n = e.get(t).getRange(); this._convertMarkerRemove(t, n, i); this._convertMarkerAdd(t, n, i) } for (const e of t.getMarkersToAdd()) { this._convertMarkerAdd(e.name, e.range, i) } i.mapper.flushDeferredBindings(); i.consumable.verifyAllConsumed("insert") } convert(t, e, n, i = {}) { const o = this._createConversionApi(n, undefined, i); this._convertInsert(t, o); for (const [t, n] of e) { this._convertMarkerAdd(t, n, o) } o.consumable.verifyAllConsumed("insert") } convertSelection(t, e, n) { const i = Array.from(e.getMarkersAtPosition(t.getFirstPosition())); const o = this._createConversionApi(n); this._addConsumablesForSelection(o.consumable, t, i); this.fire("selection", { selection: t }, o); if (!t.isCollapsed) { return } for (const e of i) { const n = e.getRange(); if (!Tf(t.getFirstPosition(), e, o.mapper)) { continue } const i = { item: t, markerName: e.name, markerRange: n }; if (o.consumable.test(t, "addMarker:" + e.name)) { this.fire(`addMarker:${e.name}`, i, o) } } for (const e of t.getAttributeKeys()) { const n = { item: t, range: t.getFirstRange(), attributeKey: e, attributeOldValue: null, attributeNewValue: t.getAttribute(e) }; if (o.consumable.test(t, "attribute:" + n.attributeKey)) { this.fire(`attribute:${n.attributeKey}:$text`, n, o) } } } _convertInsert(t, e, n = {}) { if (!n.doNotAddConsumables) { this._addConsumablesForInsert(e.consumable, Array.from(t)) } for (const n of Array.from(t.getWalker({ shallow: true })).map(Mf)) { this._testAndFire("insert", n, e) } } _convertRemove(t, e, n, i) { this.fire(`remove:${n}`, { position: t, length: e }, i) } _convertAttribute(t, e, n, i, o) { this._addConsumablesForRange(o.consumable, t, `attribute:${e}`); for (const r of t) { const t = { item: r.item, range: yf._createFromPositionAndShift(r.previousPosition, r.length), attributeKey: e, attributeOldValue: n, attributeNewValue: i }; this._testAndFire(`attribute:${e}`, t, o) } } _convertReinsert(t, e) { const n = Array.from(t.getWalker({ shallow: true })); this._addConsumablesForInsert(e.consumable, n); for (const t of n.map(Mf)) { this._testAndFire("insert", { ...t, reconversion: true }, e) } } _convertMarkerAdd(t, e, n) { if (e.root.rootName == "$graveyard") { return } const i = `addMarker:${t}`; n.consumable.add(e, i); this.fire(i, { markerName: t, markerRange: e }, n); if (!n.consumable.consume(e, i)) { return } this._addConsumablesForRange(n.consumable, e, i); for (const o of e.getItems()) { if (!n.consumable.test(o, i)) { continue } const r = { item: o, range: yf._createOn(o), markerName: t, markerRange: e }; this.fire(i, r, n) } } _convertMarkerRemove(t, e, n) { if (e.root.rootName == "$graveyard") { return } this.fire(`removeMarker:${t}`, { markerName: t, markerRange: e }, n) } _reduceChanges(t) { const e = { changes: t }; this.fire("reduceChanges", e); return e.changes } _addConsumablesForInsert(t, e) { for (const n of e) { const e = n.item; if (t.test(e, "insert") === null) { t.add(e, "insert"); for (const n of e.getAttributeKeys()) { t.add(e, "attribute:" + n) } } } return t } _addConsumablesForRange(t, e, n) { for (const i of e.getItems()) { t.add(i, n) } return t } _addConsumablesForSelection(t, e, n) { t.add(e, "selection"); for (const i of n) { t.add(e, "addMarker:" + i.name) } for (const n of e.getAttributeKeys()) { t.add(e, "attribute:" + n) } return t } _testAndFire(t, e, n) { const i = If(t, e); const o = e.item.is("$textProxy") ? n.consumable._getSymbolForTextProxy(e.item) : e.item; const r = this._firedEventsMap.get(n); const s = r.get(o); if (!s) { r.set(o, new Set([i])) } else if (!s.has(i)) { s.add(i) } else { return } this.fire(i, e, n) } _testAndFireAddAttributes(t, e) { const n = { item: t, range: yf._createOn(t) }; for (const t of n.item.getAttributeKeys()) { n.attributeKey = t; n.attributeOldValue = null; n.attributeNewValue = n.item.getAttribute(t); this._testAndFire(`attribute:${t}`, n, e) } } _createConversionApi(t, e = new Set, n = {}) { const i = { ...this._conversionApi, consumable: new Ef, writer: t, options: n, convertItem: t => this._convertInsert(yf._createOn(t), i), convertChildren: t => this._convertInsert(yf._createIn(t), i, { doNotAddConsumables: true }), convertAttributes: t => this._testAndFireAddAttributes(t, i), canReuseView: t => !e.has(i.mapper.toModelElement(t)) }; this._firedEventsMap.set(i, new Map); return i } } function Tf(t, e, n) { const i = e.getRange(); const o = Array.from(t.getAncestors()); o.shift(); o.reverse(); const r = o.some((t => { if (i.containsItem(t)) { const e = n.toViewElement(t); return !!e.getCustomProperty("addHighlight") } })); return !r } function If(t, e) { const n = e.item.is("element") ? e.item.name : "$text"; return `${t}:${n}` } function Mf(t) { const e = t.item; const n = yf._createFromPositionAndShift(t.previousPosition, t.length); return { item: e, range: n } } class Bf extends (U(cf)) { constructor(...t) { super(); this._lastRangeBackward = false; this._attrs = new Map; this._ranges = []; if (t.length) { this.setTo(...t) } } get anchor() { if (this._ranges.length > 0) { const t = this._ranges[this._ranges.length - 1]; return this._lastRangeBackward ? t.end : t.start } return null } get focus() { if (this._ranges.length > 0) { const t = this._ranges[this._ranges.length - 1]; return this._lastRangeBackward ? t.start : t.end } return null } get isCollapsed() { const t = this._ranges.length; if (t === 1) { return this._ranges[0].isCollapsed } else { return false } } get rangeCount() { return this._ranges.length } get isBackward() { return !this.isCollapsed && this._lastRangeBackward } isEqual(t) { if (this.rangeCount != t.rangeCount) { return false } else if (this.rangeCount === 0) { return true } if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) { return false } for (const e of this._ranges) { let n = false; for (const i of t._ranges) { if (e.isEqual(i)) { n = true; break } } if (!n) { return false } } return true } *getRanges() { for (const t of this._ranges) { yield new yf(t.start, t.end) } } getFirstRange() { let t = null; for (const e of this._ranges) { if (!t || e.start.isBefore(t.start)) { t = e } } return t ? new yf(t.start, t.end) : null } getLastRange() { let t = null; for (const e of this._ranges) { if (!t || e.end.isAfter(t.end)) { t = e } } return t ? new yf(t.start, t.end) : null } getFirstPosition() { const t = this.getFirstRange(); return t ? t.start.clone() : null } getLastPosition() { const t = this.getLastRange(); return t ? t.end.clone() : null } setTo(...t) { let [e, n, i] = t; if (typeof n == "object") { i = n; n = undefined } if (e === null) { this._setRanges([]) } else if (e instanceof Bf) { this._setRanges(e.getRanges(), e.isBackward) } else if (e && typeof e.getRanges == "function") { this._setRanges(e.getRanges(), e.isBackward) } else if (e instanceof yf) { this._setRanges([e], !!i && !!i.backward) } else if (e instanceof bf) { this._setRanges([new yf(e)]) } else if (e instanceof lf) { const t = !!i && !!i.backward; let o; if (n == "in") { o = yf._createIn(e) } else if (n == "on") { o = yf._createOn(e) } else if (n !== undefined) { o = new yf(bf._createAt(e, n)) } else { throw new I("model-selection-setto-required-second-parameter", [this, e]) } this._setRanges([o], t) } else if (Ct(e)) { this._setRanges(e, i && !!i.backward) } else { throw new I("model-selection-setto-not-selectable", [this, e]) } } _setRanges(t, e = false) { const n = Array.from(t); const i = n.some((e => { if (!(e instanceof yf)) { throw new I("model-selection-set-ranges-not-range", [this, t]) } return this._ranges.every((t => !t.isEqual(e))) })); if (n.length === this._ranges.length && !i) { return } this._replaceAllRanges(n); this._lastRangeBackward = !!e; this.fire("change:range", { directChange: true }) } setFocus(t, e) { if (this.anchor === null) { throw new I("model-selection-setfocus-no-ranges", [this, t]) } const n = bf._createAt(t, e); if (n.compareWith(this.focus) == "same") { return } const i = this.anchor; if (this._ranges.length) { this._popRange() } if (n.compareWith(i) == "before") { this._pushRange(new yf(n, i)); this._lastRangeBackward = true } else { this._pushRange(new yf(i, n)); this._lastRangeBackward = false } this.fire("change:range", { directChange: true }) } getAttribute(t) { return this._attrs.get(t) } getAttributes() { return this._attrs.entries() } getAttributeKeys() { return this._attrs.keys() } hasAttribute(t) { return this._attrs.has(t) } removeAttribute(t) { if (this.hasAttribute(t)) { this._attrs.delete(t); this.fire("change:attribute", { attributeKeys: [t], directChange: true }) } } setAttribute(t, e) { if (this.getAttribute(t) !== e) { this._attrs.set(t, e); this.fire("change:attribute", { attributeKeys: [t], directChange: true }) } } getSelectedElement() { if (this.rangeCount !== 1) { return null } return this.getFirstRange().getContainedElement() } *getSelectedBlocks() { const t = new WeakSet; for (const e of this.getRanges()) { const n = zf(e.start, t); if (Of(n, e)) { yield n } for (const n of e.getWalker()) { const i = n.item; if (n.type == "elementEnd" && Nf(i, t, e)) { yield i } } const i = zf(e.end, t); if (Rf(i, e)) { yield i } } } containsEntireContent(t = this.anchor.root) { const e = bf._createAt(t, 0); const n = bf._createAt(t, "end"); return e.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition()) } _pushRange(t) { this._checkRange(t); this._ranges.push(new yf(t.start, t.end)) } _checkRange(t) { for (let e = 0; e < this._ranges.length; e++) { if (t.isIntersecting(this._ranges[e])) { throw new I("model-selection-range-intersects", [this, t], { addedRange: t, intersectingRange: this._ranges[e] }) } } } _replaceAllRanges(t) { this._removeAllRanges(); for (const e of t) { this._pushRange(e) } } _removeAllRanges() { while (this._ranges.length > 0) { this._popRange() } } _popRange() { this._ranges.pop() } } Bf.prototype.is = function (t) { return t === "selection" || t === "model:selection" }; function Lf(t, e) { if (e.has(t)) { return false } e.add(t); return t.root.document.model.schema.isBlock(t) && !!t.parent } function Nf(t, e, n) { return Lf(t, e) && Pf(t, n) } function zf(t, e) { const n = t.parent; const i = n.root.document.model.schema; const o = t.parent.getAncestors({ parentFirst: true, includeSelf: true }); let r = false; const s = o.find((t => { if (r) { return false } r = i.isLimit(t); return !r && Lf(t, e) })); o.forEach((t => e.add(t))); return s } function Pf(t, e) { const n = Vf(t); if (!n) { return true } const i = e.containsRange(yf._createOn(n), true); return !i } function Of(t, e) { if (!t) { return false } if (e.isCollapsed || t.isEmpty) { return true } if (e.start.isTouching(bf._createAt(t, t.maxOffset))) { return false } return Pf(t, e) } function Rf(t, e) { if (!t) { return false } if (e.isCollapsed || t.isEmpty) { return true } if (e.end.isTouching(bf._createAt(t, 0))) { return false } return Pf(t, e) } function Vf(t) { const e = t.root.document.model.schema; let n = t.parent; while (n) { if (e.isBlock(n)) { return n } n = n.parent } } class jf extends (U(yf)) { constructor(t, e) { super(t, e); Ff.call(this) } detach() { this.stopListening() } toRange() { return new yf(this.start, this.end) } static fromRange(t) { return new jf(t.start, t.end) } } jf.prototype.is = function (t) { return t === "liveRange" || t === "model:liveRange" || t == "range" || t === "model:range" }; function Ff() { this.listenTo(this.root.document.model, "applyOperation", ((t, e) => { const n = e[0]; if (!n.isDocumentOperation) { return } Hf.call(this, n) }), { priority: "low" }) } function Hf(t) { const e = this.getTransformedByOperation(t); const n = yf._createFromRanges(e); const i = !n.isEqual(this); const o = Uf(this, t); let r = null; if (i) { if (n.root.rootName == "$graveyard") { if (t.type == "remove") { r = t.sourcePosition } else { r = t.deletionPosition } } const e = this.toRange(); this.start = n.start; this.end = n.end; this.fire("change:range", e, { deletionPosition: r }) } else if (o) { this.fire("change:content", this.toRange(), { deletionPosition: r }) } } function Uf(t, e) { switch (e.type) { case "insert": return t.containsPosition(e.position); case "move": case "remove": case "reinsert": case "merge": return t.containsPosition(e.sourcePosition) || t.start.isEqual(e.sourcePosition) || t.containsPosition(e.targetPosition); case "split": return t.containsPosition(e.splitPosition) || t.containsPosition(e.insertionPosition) }return false } const Wf = "selection:"; class qf extends (U(cf)) { constructor(t) { super(); this._selection = new Gf(t); this._selection.delegate("change:range").to(this); this._selection.delegate("change:attribute").to(this); this._selection.delegate("change:marker").to(this) } get isCollapsed() { return this._selection.isCollapsed } get anchor() { return this._selection.anchor } get focus() { return this._selection.focus } get rangeCount() { return this._selection.rangeCount } get hasOwnRange() { return this._selection.hasOwnRange } get isBackward() { return this._selection.isBackward } get isGravityOverridden() { return this._selection.isGravityOverridden } get markers() { return this._selection.markers } get _ranges() { return this._selection._ranges } getRanges() { return this._selection.getRanges() } getFirstPosition() { return this._selection.getFirstPosition() } getLastPosition() { return this._selection.getLastPosition() } getFirstRange() { return this._selection.getFirstRange() } getLastRange() { return this._selection.getLastRange() } getSelectedBlocks() { return this._selection.getSelectedBlocks() } getSelectedElement() { return this._selection.getSelectedElement() } containsEntireContent(t) { return this._selection.containsEntireContent(t) } destroy() { this._selection.destroy() } getAttributeKeys() { return this._selection.getAttributeKeys() } getAttributes() { return this._selection.getAttributes() } getAttribute(t) { return this._selection.getAttribute(t) } hasAttribute(t) { return this._selection.hasAttribute(t) } refresh() { this._selection.updateMarkers(); this._selection._updateAttributes(false) } observeMarkers(t) { this._selection.observeMarkers(t) } _setFocus(t, e) { this._selection.setFocus(t, e) } _setTo(...t) { this._selection.setTo(...t) } _setAttribute(t, e) { this._selection.setAttribute(t, e) } _removeAttribute(t) { this._selection.removeAttribute(t) } _getStoredAttributes() { return this._selection.getStoredAttributes() } _overrideGravity() { return this._selection.overrideGravity() } _restoreGravity(t) { this._selection.restoreGravity(t) } static _getStoreAttributeKey(t) { return Wf + t } static _isStoreAttributeKey(t) { return t.startsWith(Wf) } } qf.prototype.is = function (t) { return t === "selection" || t == "model:selection" || t == "documentSelection" || t == "model:documentSelection" }; class Gf extends Bf { constructor(t) { super(); this.markers = new il({ idProperty: "name" }); this._attributePriority = new Map; this._selectionRestorePosition = null; this._hasChangedRange = false; this._overriddenGravityRegister = new Set; this._observedMarkers = new Set; this._model = t.model; this._document = t; this.listenTo(this._model, "applyOperation", ((t, e) => { const n = e[0]; if (!n.isDocumentOperation || n.type == "marker" || n.type == "rename" || n.type == "noop") { return } if (this._ranges.length == 0 && this._selectionRestorePosition) { this._fixGraveyardSelection(this._selectionRestorePosition) } this._selectionRestorePosition = null; if (this._hasChangedRange) { this._hasChangedRange = false; this.fire("change:range", { directChange: false }) } }), { priority: "lowest" }); this.on("change:range", (() => { this._validateSelectionRanges(this.getRanges()) })); this.listenTo(this._model.markers, "update", ((t, e, n, i) => { this._updateMarker(e, i) })); this.listenTo(this._document, "change", ((t, e) => { Kf(this._model, e) })) } get isCollapsed() { const t = this._ranges.length; return t === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed } get anchor() { return super.anchor || this._document._getDefaultRange().start } get focus() { return super.focus || this._document._getDefaultRange().end } get rangeCount() { return this._ranges.length ? this._ranges.length : 1 } get hasOwnRange() { return this._ranges.length > 0 } get isGravityOverridden() { return !!this._overriddenGravityRegister.size } destroy() { for (let t = 0; t < this._ranges.length; t++) { this._ranges[t].detach() } this.stopListening() } *getRanges() { if (this._ranges.length) { yield* super.getRanges() } else { yield this._document._getDefaultRange() } } getFirstRange() { return super.getFirstRange() || this._document._getDefaultRange() } getLastRange() { return super.getLastRange() || this._document._getDefaultRange() } setTo(...t) { super.setTo(...t); this._updateAttributes(true); this.updateMarkers() } setFocus(t, e) { super.setFocus(t, e); this._updateAttributes(true); this.updateMarkers() } setAttribute(t, e) { if (this._setAttribute(t, e)) { const e = [t]; this.fire("change:attribute", { attributeKeys: e, directChange: true }) } } removeAttribute(t) { if (this._removeAttribute(t)) { const e = [t]; this.fire("change:attribute", { attributeKeys: e, directChange: true }) } } overrideGravity() { const t = x(); this._overriddenGravityRegister.add(t); if (this._overriddenGravityRegister.size === 1) { this._updateAttributes(true) } return t } restoreGravity(t) { if (!this._overriddenGravityRegister.has(t)) { throw new I("document-selection-gravity-wrong-restore", this, { uid: t }) } this._overriddenGravityRegister.delete(t); if (!this.isGravityOverridden) { this._updateAttributes(true) } } observeMarkers(t) { this._observedMarkers.add(t); this.updateMarkers() } _replaceAllRanges(t) { this._validateSelectionRanges(t); super._replaceAllRanges(t) } _popRange() { this._ranges.pop().detach() } _pushRange(t) { const e = this._prepareRange(t); if (e) { this._ranges.push(e) } } _validateSelectionRanges(t) { for (const e of t) { if (!this._document._validateSelectionRange(e)) { throw new I("document-selection-wrong-position", this, { range: e }) } } } _prepareRange(t) { this._checkRange(t); if (t.root == this._document.graveyard) { return } const e = jf.fromRange(t); e.on("change:range", ((t, n, i) => { this._hasChangedRange = true; if (e.root == this._document.graveyard) { this._selectionRestorePosition = i.deletionPosition; const t = this._ranges.indexOf(e); this._ranges.splice(t, 1); e.detach() } })); return e } updateMarkers() { if (!this._observedMarkers.size) { return } const t = []; let e = false; for (const e of this._model.markers) { const n = e.name.split(":", 1)[0]; if (!this._observedMarkers.has(n)) { continue } const i = e.getRange(); for (const n of this.getRanges()) { if (i.containsRange(n, !n.isCollapsed)) { t.push(e) } } } const n = Array.from(this.markers); for (const n of t) { if (!this.markers.has(n)) { this.markers.add(n); e = true } } for (const n of Array.from(this.markers)) { if (!t.includes(n)) { this.markers.remove(n); e = true } } if (e) { this.fire("change:marker", { oldMarkers: n, directChange: false }) } } _updateMarker(t, e) { const n = t.name.split(":", 1)[0]; if (!this._observedMarkers.has(n)) { return } let i = false; const o = Array.from(this.markers); const r = this.markers.has(t); if (!e) { if (r) { this.markers.remove(t); i = true } } else { let n = false; for (const t of this.getRanges()) { if (e.containsRange(t, !t.isCollapsed)) { n = true; break } } if (n && !r) { this.markers.add(t); i = true } else if (!n && r) { this.markers.remove(t); i = true } } if (i) { this.fire("change:marker", { oldMarkers: o, directChange: false }) } } _updateAttributes(t) { const e = cl(this._getSurroundingAttributes()); const n = cl(this.getAttributes()); if (t) { this._attributePriority = new Map; this._attrs = new Map } else { for (const [t, e] of this._attributePriority) { if (e == "low") { this._attrs.delete(t); this._attributePriority.delete(t) } } } this._setAttributesTo(e); const i = []; for (const [t, e] of this.getAttributes()) { if (!n.has(t) || n.get(t) !== e) { i.push(t) } } for (const [t] of n) { if (!this.hasAttribute(t)) { i.push(t) } } if (i.length > 0) { this.fire("change:attribute", { attributeKeys: i, directChange: false }) } } _setAttribute(t, e, n = true) { const i = n ? "normal" : "low"; if (i == "low" && this._attributePriority.get(t) == "normal") { return false } const o = super.getAttribute(t); if (o === e) { return false } this._attrs.set(t, e); this._attributePriority.set(t, i); return true } _removeAttribute(t, e = true) { const n = e ? "normal" : "low"; if (n == "low" && this._attributePriority.get(t) == "normal") { return false } this._attributePriority.set(t, n); if (!super.hasAttribute(t)) { return false } this._attrs.delete(t); return true } _setAttributesTo(t) { const e = new Set; for (const [e, n] of this.getAttributes()) { if (t.get(e) === n) { continue } this._removeAttribute(e, false) } for (const [n, i] of t) { const t = this._setAttribute(n, i, false); if (t) { e.add(n) } } return e } *getStoredAttributes() { const t = this.getFirstPosition().parent; if (this.isCollapsed && t.isEmpty) { for (const e of t.getAttributeKeys()) { if (e.startsWith(Wf)) { const n = e.substr(Wf.length); yield [n, t.getAttribute(e)] } } } } _getSurroundingAttributes() { const t = this.getFirstPosition(); const e = this._model.schema; let n = null; if (!this.isCollapsed) { const t = this.getFirstRange(); for (const i of t) { if (i.item.is("element") && e.isObject(i.item)) { break } if (i.type == "text") { n = i.item.getAttributes(); break } } } else { const i = t.textNode ? t.textNode : t.nodeBefore; const o = t.textNode ? t.textNode : t.nodeAfter; if (!this.isGravityOverridden) { n = $f(i) } if (!n) { n = $f(o) } if (!this.isGravityOverridden && !n) { let t = i; while (t && !e.isInline(t) && !n) { t = t.previousSibling; n = $f(t) } } if (!n) { let t = o; while (t && !e.isInline(t) && !n) { t = t.nextSibling; n = $f(t) } } if (!n) { n = this.getStoredAttributes() } } return n } _fixGraveyardSelection(t) { const e = this._model.schema.getNearestSelectionRange(t); if (e) { this._pushRange(e) } } } function $f(t) { if (t instanceof hf || t instanceof uf) { return t.getAttributes() } return null } function Kf(t, e) { const n = t.document.differ; for (const i of n.getChanges()) { if (i.type != "insert") { continue } const n = i.position.parent; const o = i.length === n.maxOffset; if (o) { t.enqueueChange(e, (t => { const e = Array.from(n.getAttributeKeys()).filter((t => t.startsWith(Wf))); for (const i of e) { t.removeAttribute(i, n) } })) } } } class Yf { constructor(t) { this._dispatchers = t } add(t) { for (const e of this._dispatchers) { t(e) } return this } } var Qf = 1, Zf = 4; function Jf(t) { return La(t, Qf | Zf) } const Xf = Jf; class tp extends Yf { elementToElement(t) { return this.add(Cp(t)) } elementToStructure(t) { return this.add(vp(t)) } attributeToElement(t) { return this.add(yp(t)) } attributeToAttribute(t) { return this.add(xp(t)) } markerToElement(t) { return this.add(Ep(t)) } markerToHighlight(t) { return this.add(Sp(t)) } markerToData(t) { return this.add(Dp(t)) } } function ep() { return (t, e, n) => { if (!n.consumable.consume(e.item, t.name)) { return } const i = n.writer; const o = n.mapper.toViewPosition(e.range.start); const r = i.createText(e.item.data); i.insert(o, r) } } function np() { return (t, e, n) => { n.convertAttributes(e.item); if (!e.reconversion && e.item.is("element") && !e.item.isEmpty) { n.convertChildren(e.item) } } } function ip() { return (t, e, n) => { const i = n.mapper.toViewPosition(e.position); const o = e.position.getShiftedBy(e.length); const r = n.mapper.toViewPosition(o, { isPhantom: true }); const s = n.writer.createRange(i, r); const a = n.writer.remove(s.getTrimmed()); for (const t of n.writer.createRangeIn(a).getItems()) { n.mapper.unbindViewElement(t, { defer: true }) } } } function op(t, e) { const n = t.createAttributeElement("span", e.attributes); if (e.classes) { n._addClass(e.classes) } if (typeof e.priority === "number") { n._priority = e.priority } n._id = e.id; return n } function rp() { return (t, e, n) => { const i = e.selection; if (i.isCollapsed) { return } if (!n.consumable.consume(i, "selection")) { return } const o = []; for (const t of i.getRanges()) { o.push(n.mapper.toViewRange(t)) } n.writer.setSelection(o, { backward: i.isBackward }) } } function sp() { return (t, e, n) => { const i = e.selection; if (!i.isCollapsed) { return } if (!n.consumable.consume(i, "selection")) { return } const o = n.writer; const r = i.getFirstPosition(); const s = n.mapper.toViewPosition(r); const a = o.breakAttributes(s); o.setSelection(a) } } function ap() { return (t, e, n) => { const i = n.writer; const o = i.document.selection; for (const t of o.getRanges()) { if (t.isCollapsed) { if (t.end.parent.isAttached()) { n.writer.mergeAttributes(t.start) } } } i.setSelection(null) } } function cp(t) { return (e, n, i) => { if (!i.consumable.test(n.item, e.name)) { return } const o = t(n.attributeOldValue, i, n); const r = t(n.attributeNewValue, i, n); if (!o && !r) { return } i.consumable.consume(n.item, e.name); const s = i.writer; const a = s.document.selection; if (n.item instanceof Bf || n.item instanceof qf) { s.wrap(a.getFirstRange(), r) } else { let t = i.mapper.toViewRange(n.range); if (n.attributeOldValue !== null && o) { t = s.unwrap(t, o) } if (n.attributeNewValue !== null && r) { s.wrap(t, r) } } } } function lp(t, e = Up) { return (n, i, o) => { if (!e(i.item, o.consumable, { preflight: true })) { return } const r = t(i.item, o, i); if (!r) { return } e(i.item, o.consumable); const s = o.mapper.toViewPosition(i.range.start); o.mapper.bindElements(i.item, r); o.writer.insert(s, r); o.convertAttributes(i.item); Fp(r, i.item.getChildren(), o, { reconversion: i.reconversion }) } } function dp(t, e) { return (n, i, o) => { if (!e(i.item, o.consumable, { preflight: true })) { return } const r = new Map; o.writer._registerSlotFactory(Rp(i.item, r, o)); const s = t(i.item, o, i); o.writer._clearSlotFactory(); if (!s) { return } Vp(i.item, r, o); e(i.item, o.consumable); const a = o.mapper.toViewPosition(i.range.start); o.mapper.bindElements(i.item, s); o.writer.insert(a, s); o.convertAttributes(i.item); jp(s, r, o, { reconversion: i.reconversion }) } } function up(t) { return (e, n, i) => { n.isOpening = true; const o = t(n, i); n.isOpening = false; const r = t(n, i); if (!o || !r) { return } const s = n.markerRange; if (s.isCollapsed && !i.consumable.consume(s, e.name)) { return } for (const t of s) { if (!i.consumable.consume(t.item, e.name)) { return } } const a = i.mapper; const c = i.writer; c.insert(a.toViewPosition(s.start), o); i.mapper.bindElementToMarker(o, n.markerName); if (!s.isCollapsed) { c.insert(a.toViewPosition(s.end), r); i.mapper.bindElementToMarker(r, n.markerName) } e.stop() } } function hp() { return (t, e, n) => { const i = n.mapper.markerNameToElements(e.markerName); if (!i) { return } for (const t of i) { n.mapper.unbindElementFromMarkerName(t, e.markerName); n.writer.clear(n.writer.createRangeOn(t), t) } n.writer.clearClonedElementsGroup(e.markerName); t.stop() } } function gp(t) { return (e, n, i) => { const o = t(n.markerName, i); if (!o) { return } const r = n.markerRange; if (!i.consumable.consume(r, e.name)) { return } mp(r, false, i, n, o); mp(r, true, i, n, o); e.stop() } } function mp(t, e, n, i, o) { const r = e ? t.start : t.end; const s = r.nodeAfter && r.nodeAfter.is("element") ? r.nodeAfter : null; const a = r.nodeBefore && r.nodeBefore.is("element") ? r.nodeBefore : null; if (s || a) { let t; let r; if (e && s || !e && !a) { t = s; r = true } else { t = a; r = false } const c = n.mapper.toViewElement(t); if (c) { fp(c, e, r, n, i, o); return } } const c = n.mapper.toViewPosition(r); pp(c, e, n, i, o) } function fp(t, e, n, i, o, r) { const s = `data-${r.group}-${e ? "start" : "end"}-${n ? "before" : "after"}`; const a = t.hasAttribute(s) ? t.getAttribute(s).split(",") : []; a.unshift(r.name); i.writer.setAttribute(s, a.join(","), t); i.mapper.bindElementToMarker(t, o.markerName) } function pp(t, e, n, i, o) { const r = `${o.group}-${e ? "start" : "end"}`; const s = o.name ? { name: o.name } : null; const a = n.writer.createUIElement(r, s); n.writer.insert(t, a); n.mapper.bindElementToMarker(a, i.markerName) } function bp(t) { return (e, n, i) => { const o = t(n.markerName, i); if (!o) { return } const r = i.mapper.markerNameToElements(n.markerName); if (!r) { return } for (const t of r) { i.mapper.unbindElementFromMarkerName(t, n.markerName); if (t.is("containerElement")) { s(`data-${o.group}-start-before`, t); s(`data-${o.group}-start-after`, t); s(`data-${o.group}-end-before`, t); s(`data-${o.group}-end-after`, t) } else { i.writer.clear(i.writer.createRangeOn(t), t) } } i.writer.clearClonedElementsGroup(n.markerName); e.stop(); function s(t, e) { if (e.hasAttribute(t)) { const n = new Set(e.getAttribute(t).split(",")); n.delete(o.name); if (n.size == 0) { i.writer.removeAttribute(t, e) } else { i.writer.setAttribute(t, Array.from(n).join(","), e) } } } } } function kp(t) { return (e, n, i) => { if (!i.consumable.test(n.item, e.name)) { return } const o = t(n.attributeOldValue, i, n); const r = t(n.attributeNewValue, i, n); if (!o && !r) { return } i.consumable.consume(n.item, e.name); const s = i.mapper.toViewElement(n.item); const a = i.writer; if (!s) { throw new I("conversion-attribute-to-attribute-on-text", i.dispatcher, n) } if (n.attributeOldValue !== null && o) { if (o.key == "class") { const t = $c(o.value); for (const e of t) { a.removeClass(e, s) } } else if (o.key == "style") { const t = Object.keys(o.value); for (const e of t) { a.removeStyle(e, s) } } else { a.removeAttribute(o.key, s) } } if (n.attributeNewValue !== null && r) { if (r.key == "class") { const t = $c(r.value); for (const e of t) { a.addClass(e, s) } } else if (r.key == "style") { const t = Object.keys(r.value); for (const e of t) { a.setStyle(e, r.value[e], s) } } else { a.setAttribute(r.key, r.value, s) } } } } function wp(t) { return (e, n, i) => { if (!n.item) { return } if (!(n.item instanceof Bf || n.item instanceof qf) && !n.item.is("$textProxy")) { return } const o = Np(t, n, i); if (!o) { return } if (!i.consumable.consume(n.item, e.name)) { return } const r = i.writer; const s = op(r, o); const a = r.document.selection; if (n.item instanceof Bf || n.item instanceof qf) { r.wrap(a.getFirstRange(), s) } else { const t = i.mapper.toViewRange(n.range); const e = r.wrap(t, s); for (const t of e.getItems()) { if (t.is("attributeElement") && t.isSimilar(s)) { i.mapper.bindElementToMarker(t, n.markerName); break } } } } } function Ap(t) { return (e, n, i) => { if (!n.item) { return } if (!(n.item instanceof gf)) { return } const o = Np(t, n, i); if (!o) { return } if (!i.consumable.test(n.item, e.name)) { return } const r = i.mapper.toViewElement(n.item); if (r && r.getCustomProperty("addHighlight")) { i.consumable.consume(n.item, e.name); for (const t of yf._createIn(n.item)) { i.consumable.consume(t.item, e.name) } const t = r.getCustomProperty("addHighlight"); t(r, o, i.writer); i.mapper.bindElementToMarker(r, n.markerName) } } } function _p(t) { return (e, n, i) => { if (n.markerRange.isCollapsed) { return } const o = Np(t, n, i); if (!o) { return } const r = op(i.writer, o); const s = i.mapper.markerNameToElements(n.markerName); if (!s) { return } for (const t of s) { i.mapper.unbindElementFromMarkerName(t, n.markerName); if (t.is("attributeElement")) { i.writer.unwrap(i.writer.createRangeOn(t), r) } else { const e = t.getCustomProperty("removeHighlight"); e(t, o.id, i.writer) } } i.writer.clearClonedElementsGroup(n.markerName); e.stop() } } function Cp(t) { const e = Tp(t.model); const n = Ip(t.view, "container"); if (e.attributes.length) { e.children = true } return i => { i.on(`insert:${e.name}`, lp(n, Op(e)), { priority: t.converterPriority || "normal" }); if (e.children || e.attributes.length) { i.on("reduceChanges", Pp(e), { priority: "low" }) } } } function vp(t) { const e = Tp(t.model); const n = Ip(t.view, "container"); e.children = true; return i => { if (i._conversionApi.schema.checkChild(e.name, "$text")) { throw new I("conversion-element-to-structure-disallowed-text", i, { elementName: e.name }) } i.on(`insert:${e.name}`, dp(n, Op(e)), { priority: t.converterPriority || "normal" }); i.on("reduceChanges", Pp(e), { priority: "low" }) } } function yp(t) { t = Xf(t); let e = t.model; if (typeof e == "string") { e = { key: e } } let n = `attribute:${e.key}`; if (e.name) { n += ":" + e.name } if (e.values) { for (const n of e.values) { t.view[n] = Ip(t.view[n], "attribute") } } else { t.view = Ip(t.view, "attribute") } const i = Bp(t); return e => { e.on(n, cp(i), { priority: t.converterPriority || "normal" }) } } function xp(t) { t = Xf(t); let e = t.model; if (typeof e == "string") { e = { key: e } } let n = `attribute:${e.key}`; if (e.name) { n += ":" + e.name } if (e.values) { for (const n of e.values) { t.view[n] = Lp(t.view[n]) } } else { t.view = Lp(t.view) } const i = Bp(t); return e => { e.on(n, kp(i), { priority: t.converterPriority || "normal" }) } } function Ep(t) { const e = Ip(t.view, "ui"); return n => { n.on(`addMarker:${t.model}`, up(e), { priority: t.converterPriority || "normal" }); n.on(`removeMarker:${t.model}`, hp(), { priority: t.converterPriority || "normal" }) } } function Dp(t) { t = Xf(t); const e = t.model; let n = t.view; if (!n) { n = n => ({ group: e, name: n.substr(t.model.length + 1) }) } return i => { i.on(`addMarker:${e}`, gp(n), { priority: t.converterPriority || "normal" }); i.on(`removeMarker:${e}`, bp(n), { priority: t.converterPriority || "normal" }) } } function Sp(t) { return e => { e.on(`addMarker:${t.model}`, wp(t.view), { priority: t.converterPriority || "normal" }); e.on(`addMarker:${t.model}`, Ap(t.view), { priority: t.converterPriority || "normal" }); e.on(`removeMarker:${t.model}`, _p(t.view), { priority: t.converterPriority || "normal" }) } } function Tp(t) { if (typeof t == "string") { t = { name: t } } if (!t.attributes) { t.attributes = [] } else if (!Array.isArray(t.attributes)) { t.attributes = [t.attributes] } t.children = !!t.children; return t } function Ip(t, e) { if (typeof t == "function") { return t } return (n, i) => Mp(t, i, e) } function Mp(t, e, n) { if (typeof t == "string") { t = { name: t } } let i; const o = e.writer; const r = Object.assign({}, t.attributes); if (n == "container") { i = o.createContainerElement(t.name, r) } else if (n == "attribute") { const e = { priority: t.priority || kh.DEFAULT_PRIORITY }; i = o.createAttributeElement(t.name, r, e) } else { i = o.createUIElement(t.name, r) } if (t.styles) { const e = Object.keys(t.styles); for (const n of e) { o.setStyle(n, t.styles[n], i) } } if (t.classes) { const e = t.classes; if (typeof e == "string") { o.addClass(e, i) } else { for (const t of e) { o.addClass(t, i) } } } return i } function Bp(t) { if (t.model.values) { return (e, n, i) => { const o = t.view[e]; if (o) { return o(e, n, i) } return null } } else { return t.view } } function Lp(t) { if (typeof t == "string") { return e => ({ key: t, value: e }) } else if (typeof t == "object") { if (t.value) { return () => t } else { return e => ({ key: t.key, value: e }) } } else { return t } } function Np(t, e, n) { const i = typeof t == "function" ? t(e, n) : t; if (!i) { return null } if (!i.priority) { i.priority = 10 } if (!i.id) { i.id = e.markerName } return i } function zp(t) { return (e, n) => { if (!e.is("element", t.name)) { return false } if (n.type == "attribute") { if (t.attributes.includes(n.attributeKey)) { return true } } else { if (t.children) { return true } } return false } } function Pp(t) { const e = zp(t); return (t, n) => { const i = []; if (!n.reconvertedElements) { n.reconvertedElements = new Set } for (const t of n.changes) { const o = t.type == "attribute" ? t.range.start.nodeAfter : t.position.parent; if (!o || !e(o, t)) { i.push(t); continue } if (!n.reconvertedElements.has(o)) { n.reconvertedElements.add(o); const t = bf._createBefore(o); let e = i.length; for (let n = i.length - 1; n >= 0; n--) { const o = i[n]; const r = o.type == "attribute" ? o.range.start : o.position; const s = r.compareWith(t); if (s == "before" || o.type == "remove" && s == "same") { break } e = n } i.splice(e, 0, { type: "remove", name: o.name, position: t, length: 1 }, { type: "reinsert", name: o.name, position: t, length: 1 }) } } n.changes = i } } function Op(t) { return (e, n, i = {}) => { const o = ["insert"]; for (const n of t.attributes) { if (e.hasAttribute(n)) { o.push(`attribute:${n}`) } } if (!o.every((t => n.test(e, t)))) { return false } if (!i.preflight) { o.forEach((t => n.consume(e, t))) } return true } } function Rp(t, e, n) { return (i, o) => { const r = i.createContainerElement("$slot"); let s = null; if (o === "children") { s = Array.from(t.getChildren()) } else if (typeof o == "function") { s = Array.from(t.getChildren()).filter((t => o(t))) } else { throw new I("conversion-slot-mode-unknown", n.dispatcher, { modeOrFilter: o }) } e.set(r, s); return r } } function Vp(t, e, n) { const i = Array.from(e.values()).flat(); const o = new Set(i); if (o.size != i.length) { throw new I("conversion-slot-filter-overlap", n.dispatcher, { element: t }) } if (o.size != t.childCount) { throw new I("conversion-slot-filter-incomplete", n.dispatcher, { element: t }) } } function jp(t, e, n, i) { n.mapper.on("modelToViewPosition", s, { priority: "highest" }); let o = null; let r = null; for ([o, r] of e) { Fp(t, r, n, i); n.writer.move(n.writer.createRangeIn(o), n.writer.createPositionBefore(o)); n.writer.remove(o) } n.mapper.off("modelToViewPosition", s); function s(t, e) { const n = e.modelPosition.nodeAfter; const i = r.indexOf(n); if (i < 0) { return } e.viewPosition = e.mapper.findPositionIn(o, i) } } function Fp(t, e, n, i) { for (const o of e) { if (!Hp(t.root, o, n, i)) { n.convertItem(o) } } } function Hp(t, e, n, i) { const { writer: o, mapper: r } = n; if (!i.reconversion) { return false } const s = r.toViewElement(e); if (!s || s.root == t) { return false } if (!n.canReuseView(s)) { return false } o.move(o.createRangeOn(s), r.toViewPosition(bf._createBefore(e))); return true } function Up(t, e, { preflight: n } = {}) { if (n) { return e.test(t, "insert") } else { return e.consume(t, "insert") } } function Wp(t) { const { schema: e, document: n } = t.model; for (const i of n.getRootNames()) { const o = n.getRoot(i); if (o.isEmpty && !e.checkChild(o, "$text")) { if (e.checkChild(o, "paragraph")) { t.insertElement("paragraph", o); return true } } } return false } function qp(t, e, n) { const i = n.createContext(t); if (!n.checkChild(i, "paragraph")) { return false } if (!n.checkChild(i.push("paragraph"), e)) { return false } return true } function Gp(t, e) { const n = e.createElement("paragraph"); e.insert(n, t); return e.createPositionAt(n, 0) } class $p extends Yf { elementToElement(t) { return this.add(Zp(t)) } elementToAttribute(t) { return this.add(Jp(t)) } attributeToAttribute(t) { return this.add(Xp(t)) } elementToMarker(t) { return this.add(tb(t)) } dataToMarker(t) { return this.add(eb(t)) } } function Kp() { return (t, e, n) => { if (!e.modelRange && n.consumable.consume(e.viewItem, { name: true })) { const { modelRange: t, modelCursor: i } = n.convertChildren(e.viewItem, e.modelCursor); e.modelRange = t; e.modelCursor = i } } } function Yp() { return (t, e, { schema: n, consumable: i, writer: o }) => { let r = e.modelCursor; if (!i.test(e.viewItem)) { return } if (!n.checkChild(r, "$text")) { if (!qp(r, "$text", n)) { return } if (e.viewItem.data.trim().length == 0) { return } const t = r.nodeBefore; r = Gp(r, o); if (t && t.is("element", "$marker")) { o.move(o.createRangeOn(t), r); r = o.createPositionAfter(t) } } i.consume(e.viewItem); const s = o.createText(e.viewItem.data); o.insert(s, r); e.modelRange = o.createRange(r, r.getShiftedBy(s.offsetSize)); e.modelCursor = e.modelRange.end } } function Qp(t, e) { return (n, i) => { const o = i.newSelection; const r = []; for (const t of o.getRanges()) { r.push(e.toModelRange(t)) } const s = t.createSelection(r, { backward: o.isBackward }); if (!s.isEqual(t.document.selection)) { t.change((t => { t.setSelection(s) })) } } } function Zp(t) { t = Xf(t); const e = ob(t); const n = ib(t.view); const i = n ? `element:${n}` : "element"; return n => { n.on(i, e, { priority: t.converterPriority || "normal" }) } } function Jp(t) { t = Xf(t); ab(t); const e = cb(t, false); const n = ib(t.view); const i = n ? `element:${n}` : "element"; return n => { n.on(i, e, { priority: t.converterPriority || "low" }) } } function Xp(t) { t = Xf(t); let e = null; if (typeof t.view == "string" || t.view.key) { e = sb(t) } ab(t, e); const n = cb(t, true); return e => { e.on("element", n, { priority: t.converterPriority || "low" }) } } function tb(t) { const e = ub(t.model); return Zp({ ...t, model: e }) } function eb(t) { t = Xf(t); if (!t.model) { t.model = e => e ? t.view + ":" + e : t.view } const e = { view: t.view, model: t.model }; const n = ob(hb(e, "start")); const i = ob(hb(e, "end")); return o => { o.on(`element:${t.view}-start`, n, { priority: t.converterPriority || "normal" }); o.on(`element:${t.view}-end`, i, { priority: t.converterPriority || "normal" }); const r = D.get("low"); const s = D.get("highest"); const a = D.get(t.converterPriority) / s; o.on("element", nb(e), { priority: r + a }) } } function nb(t) { return (e, n, i) => { const o = `data-${t.view}`; if (!i.consumable.test(n.viewItem, { attributes: o + "-end-after" }) && !i.consumable.test(n.viewItem, { attributes: o + "-start-after" }) && !i.consumable.test(n.viewItem, { attributes: o + "-end-before" }) && !i.consumable.test(n.viewItem, { attributes: o + "-start-before" })) { return } if (!n.modelRange) { Object.assign(n, i.convertChildren(n.viewItem, n.modelCursor)) } if (i.consumable.consume(n.viewItem, { attributes: o + "-end-after" })) { r(n.modelRange.end, n.viewItem.getAttribute(o + "-end-after").split(",")) } if (i.consumable.consume(n.viewItem, { attributes: o + "-start-after" })) { r(n.modelRange.end, n.viewItem.getAttribute(o + "-start-after").split(",")) } if (i.consumable.consume(n.viewItem, { attributes: o + "-end-before" })) { r(n.modelRange.start, n.viewItem.getAttribute(o + "-end-before").split(",")) } if (i.consumable.consume(n.viewItem, { attributes: o + "-start-before" })) { r(n.modelRange.start, n.viewItem.getAttribute(o + "-start-before").split(",")) } function r(e, o) { for (const r of o) { const o = t.model(r, i); const s = i.writer.createElement("$marker", { "data-name": o }); i.writer.insert(s, e); if (n.modelCursor.isEqual(e)) { n.modelCursor = n.modelCursor.getShiftedBy(1) } else { n.modelCursor = n.modelCursor._getTransformedByInsertion(e, 1) } n.modelRange = n.modelRange._getTransformedByInsertion(e, 1)[0] } } } } function ib(t) { if (typeof t == "string") { return t } if (typeof t == "object" && typeof t.name == "string") { return t.name } return null } function ob(t) { const e = new Yl(t.view); return (n, i, o) => { const r = e.match(i.viewItem); if (!r) { return } const s = r.match; s.name = true; if (!o.consumable.test(i.viewItem, s)) { return } const a = rb(t.model, i.viewItem, o); if (!a) { return } if (!o.safeInsert(a, i.modelCursor)) { return } o.consumable.consume(i.viewItem, s); o.convertChildren(i.viewItem, a); o.updateConversionResult(a, i) } } function rb(t, e, n) { if (t instanceof Function) { return t(e, n) } else { return n.writer.createElement(t) } } function sb(t) { if (typeof t.view == "string") { t.view = { key: t.view } } const e = t.view.key; let n; if (e == "class" || e == "style") { const i = e == "class" ? "classes" : "styles"; n = { [i]: t.view.value } } else { const i = typeof t.view.value == "undefined" ? /[\s\S]*/ : t.view.value; n = { attributes: { [e]: i } } } if (t.view.name) { n.name = t.view.name } t.view = n; return e } function ab(t, e = null) { const n = e === null ? true : t => t.getAttribute(e); const i = typeof t.model != "object" ? t.model : t.model.key; const o = typeof t.model != "object" || typeof t.model.value == "undefined" ? n : t.model.value; t.model = { key: i, value: o } } function cb(t, e) { const n = new Yl(t.view); return (i, o, r) => { if (!o.modelRange && e) { return } const s = n.match(o.viewItem); if (!s) { return } if (lb(t.view, o.viewItem)) { s.match.name = true } else { delete s.match.name } if (!r.consumable.test(o.viewItem, s.match)) { return } const a = t.model.key; const c = typeof t.model.value == "function" ? t.model.value(o.viewItem, r) : t.model.value; if (c === null) { return } if (!o.modelRange) { Object.assign(o, r.convertChildren(o.viewItem, o.modelCursor)) } const l = db(o.modelRange, { key: a, value: c }, e, r); if (l) { if (r.consumable.test(o.viewItem, { name: true })) { s.match.name = true } r.consumable.consume(o.viewItem, s.match) } } } function lb(t, e) { const n = typeof t == "function" ? t(e) : t; if (typeof n == "object" && !ib(n)) { return false } return !n.classes && !n.attributes && !n.styles } function db(t, e, n, i) { let o = false; for (const r of Array.from(t.getItems({ shallow: n }))) { if (!i.schema.checkAttribute(r, e.key)) { continue } o = true; if (r.hasAttribute(e.key)) { continue } i.writer.setAttribute(e.key, e.value, r) } return o } function ub(t) { return (e, n) => { const i = typeof t == "string" ? t : t(e, n); return n.writer.createElement("$marker", { "data-name": i }) } } function hb(t, e) { const n = (e, n) => { const i = e.getAttribute("name"); const o = t.model(i, n); return n.writer.createElement("$marker", { "data-name": o }) }; return { view: `${t.view}-${e}`, model: n } } function gb(t) { t.document.registerPostFixer((e => mb(e, t))) } function mb(t, e) { const n = e.document.selection; const i = e.schema; const o = []; let r = false; for (const t of n.getRanges()) { const e = fb(t, i); if (e && !e.isEqual(t)) { o.push(e); r = true } else { o.push(t) } } if (r) { t.setSelection(Ab(o), { backward: n.isBackward }) } return false } function fb(t, e) { if (t.isCollapsed) { return pb(t, e) } return bb(t, e) } function pb(t, e) { const n = t.start; const i = e.getNearestSelectionRange(n); if (!i) { const t = n.getAncestors().reverse().find((t => e.isObject(t))); if (t) { return yf._createOn(t) } return null } if (!i.isCollapsed) { return i } const o = i.start; if (n.isEqual(o)) { return null } return new yf(o) } function bb(t, e) { const { start: n, end: i } = t; const o = e.checkChild(n, "$text"); const r = e.checkChild(i, "$text"); const s = e.getLimitElement(n); const a = e.getLimitElement(i); if (s === a) { if (o && r) { return null } if (wb(n, i, e)) { const t = n.nodeAfter && e.isSelectable(n.nodeAfter); const o = t ? null : e.getNearestSelectionRange(n, "forward"); const r = i.nodeBefore && e.isSelectable(i.nodeBefore); const s = r ? null : e.getNearestSelectionRange(i, "backward"); const a = o ? o.start : n; const c = s ? s.end : i; return new yf(a, c) } } const c = s && !s.is("rootElement"); const l = a && !a.is("rootElement"); if (c || l) { const t = n.nodeAfter && i.nodeBefore && n.nodeAfter.parent === i.nodeBefore.parent; const o = c && (!t || !_b(n.nodeAfter, e)); const r = l && (!t || !_b(i.nodeBefore, e)); let d = n; let u = i; if (o) { d = bf._createBefore(kb(s, e)) } if (r) { u = bf._createAfter(kb(a, e)) } return new yf(d, u) } return null } function kb(t, e) { let n = t; let i = n; while (e.isLimit(i) && i.parent) { n = i; i = i.parent } return n } function wb(t, e, n) { const i = t.nodeAfter && !n.isLimit(t.nodeAfter) || n.checkChild(t, "$text"); const o = e.nodeBefore && !n.isLimit(e.nodeBefore) || n.checkChild(e, "$text"); return i || o } function Ab(t) { const e = [...t]; const n = new Set; let i = 1; while (i < e.length) { const t = e[i]; const o = e.slice(0, i); for (const [r, s] of o.entries()) { if (n.has(r)) { continue } if (t.isEqual(s)) { n.add(r) } else if (t.isIntersecting(s)) { n.add(r); n.add(i); const o = t.getJoined(s); e.push(o) } } i++ } const o = e.filter(((t, e) => !n.has(e))); return o } function _b(t, e) { return t && e.isSelectable(t) } class Cb extends (lt()) { constructor(t, e) { super(); this.model = t; this.view = new af(e); this.mapper = new xf; this.downcastDispatcher = new Sf({ mapper: this.mapper, schema: t.schema }); const n = this.model.document; const i = n.selection; const o = this.model.markers; this.listenTo(this.model, "_beforeChanges", (() => { this.view._disableRendering(true) }), { priority: "highest" }); this.listenTo(this.model, "_afterChanges", (() => { this.view._disableRendering(false) }), { priority: "lowest" }); this.listenTo(n, "change", (() => { this.view.change((t => { this.downcastDispatcher.convertChanges(n.differ, o, t); this.downcastDispatcher.convertSelection(i, o, t) })) }), { priority: "low" }); this.listenTo(this.view.document, "selectionChange", Qp(this.model, this.mapper)); this.listenTo(this.view.document, "beforeinput", vb(this.mapper, this.model.schema, this.view), { priority: "high" }); this.downcastDispatcher.on("insert:$text", ep(), { priority: "lowest" }); this.downcastDispatcher.on("insert", np(), { priority: "lowest" }); this.downcastDispatcher.on("remove", ip(), { priority: "low" }); this.downcastDispatcher.on("selection", ap(), { priority: "high" }); this.downcastDispatcher.on("selection", rp(), { priority: "low" }); this.downcastDispatcher.on("selection", sp(), { priority: "low" }); this.view.document.roots.bindTo(this.model.document.roots).using((t => { if (t.rootName == "$graveyard") { return null } const e = new eh(this.view.document, t.name); e.rootName = t.rootName; this.mapper.bindElements(t, e); return e })) } destroy() { this.view.destroy(); this.stopListening() } reconvertMarker(t) { const e = typeof t == "string" ? t : t.name; const n = this.model.markers.get(e); if (!n) { throw new I("editingcontroller-reconvertmarker-marker-not-exist", this, { markerName: e }) } this.model.change((() => { this.model.markers._refresh(n) })) } reconvertItem(t) { this.model.change((() => { this.model.document.differ._refreshItem(t) })) } } function vb(t, e, n) { return (i, o) => { if (n.document.isComposing && !r.isAndroid) { return } for (let n = 0; n < o.targetRanges.length; n++) { const i = o.targetRanges[n]; const r = t.toModelRange(i); const s = fb(r, e); if (!s || s.isEqual(r)) { continue } o.targetRanges[n] = t.toViewRange(s) } } } class yb { constructor() { this._consumables = new Map } add(t, e) { let n; if (t.is("$text") || t.is("documentFragment")) { this._consumables.set(t, true); return } if (!this._consumables.has(t)) { n = new Eb(t); this._consumables.set(t, n) } else { n = this._consumables.get(t) } n.add(e) } test(t, e) { const n = this._consumables.get(t); if (n === undefined) { return null } if (t.is("$text") || t.is("documentFragment")) { return n } return n.test(e) } consume(t, e) { if (this.test(t, e)) { if (t.is("$text") || t.is("documentFragment")) { this._consumables.set(t, false) } else { this._consumables.get(t).consume(e) } return true } return false } revert(t, e) { const n = this._consumables.get(t); if (n !== undefined) { if (t.is("$text") || t.is("documentFragment")) { this._consumables.set(t, true) } else { n.revert(e) } } } static consumablesFromElement(t) { const e = { element: t, name: true, attributes: [], classes: [], styles: [] }; const n = t.getAttributeKeys(); for (const t of n) { if (t == "style" || t == "class") { continue } e.attributes.push(t) } const i = t.getClassNames(); for (const t of i) { e.classes.push(t) } const o = t.getStyleNames(); for (const t of o) { e.styles.push(t) } return e } static createFrom(t, e) { if (!e) { e = new yb } if (t.is("$text")) { e.add(t); return e } if (t.is("element")) { e.add(t, yb.consumablesFromElement(t)) } if (t.is("documentFragment")) { e.add(t) } for (const n of t.getChildren()) { e = yb.createFrom(n, e) } return e } } const xb = ["attributes", "classes", "styles"]; class Eb { constructor(t) { this.element = t; this._canConsumeName = null; this._consumables = { attributes: new Map, styles: new Map, classes: new Map } } add(t) { if (t.name) { this._canConsumeName = true } for (const e of xb) { if (e in t) { this._add(e, t[e]) } } } test(t) { if (t.name && !this._canConsumeName) { return this._canConsumeName } for (const e of xb) { if (e in t) { const n = this._test(e, t[e]); if (n !== true) { return n } } } return true } consume(t) { if (t.name) { this._canConsumeName = false } for (const e of xb) { if (e in t) { this._consume(e, t[e]) } } } revert(t) { if (t.name) { this._canConsumeName = true } for (const e of xb) { if (e in t) { this._revert(e, t[e]) } } } _add(t, e) { const n = Gt(e) ? e : [e]; const i = this._consumables[t]; for (const e of n) { if (t === "attributes" && (e === "class" || e === "style")) { throw new I("viewconsumable-invalid-attribute", this) } i.set(e, true); if (t === "styles") { for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) { i.set(t, true) } } } } _test(t, e) { const n = Gt(e) ? e : [e]; const i = this._consumables[t]; for (const e of n) { if (t === "attributes" && (e === "class" || e === "style")) { const t = e == "class" ? "classes" : "styles"; const n = this._test(t, [...this._consumables[t].keys()]); if (n !== true) { return n } } else { const t = i.get(e); if (t === undefined) { return null } if (!t) { return false } } } return true } _consume(t, e) { const n = Gt(e) ? e : [e]; const i = this._consumables[t]; for (const e of n) { if (t === "attributes" && (e === "class" || e === "style")) { const t = e == "class" ? "classes" : "styles"; this._consume(t, [...this._consumables[t].keys()]) } else { i.set(e, false); if (t == "styles") { for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) { i.set(t, false) } } } } } _revert(t, e) { const n = Gt(e) ? e : [e]; const i = this._consumables[t]; for (const e of n) { if (t === "attributes" && (e === "class" || e === "style")) { const t = e == "class" ? "classes" : "styles"; this._revert(t, [...this._consumables[t].keys()]) } else { const t = i.get(e); if (t === false) { i.set(e, true) } } } } } class Db extends (lt()) { constructor() { super(); this._sourceDefinitions = {}; this._attributeProperties = {}; this.decorate("checkChild"); this.decorate("checkAttribute"); this.on("checkAttribute", ((t, e) => { e[0] = new Sb(e[0]) }), { priority: "highest" }); this.on("checkChild", ((t, e) => { e[0] = new Sb(e[0]); e[1] = this.getDefinition(e[1]) }), { priority: "highest" }) } register(t, e) { if (this._sourceDefinitions[t]) { throw new I("schema-cannot-register-item-twice", this, { itemName: t }) } this._sourceDefinitions[t] = [Object.assign({}, e)]; this._clearCache() } extend(t, e) { if (!this._sourceDefinitions[t]) { throw new I("schema-cannot-extend-missing-item", this, { itemName: t }) } this._sourceDefinitions[t].push(Object.assign({}, e)); this._clearCache() } getDefinitions() { if (!this._compiledDefinitions) { this._compile() } return this._compiledDefinitions } getDefinition(t) { let e; if (typeof t == "string") { e = t } else if ("is" in t && (t.is("$text") || t.is("$textProxy"))) { e = "$text" } else { e = t.name } return this.getDefinitions()[e] } isRegistered(t) { return !!this.getDefinition(t) } isBlock(t) { const e = this.getDefinition(t); return !!(e && e.isBlock) } isLimit(t) { const e = this.getDefinition(t); if (!e) { return false } return !!(e.isLimit || e.isObject) } isObject(t) { const e = this.getDefinition(t); if (!e) { return false } return !!(e.isObject || e.isLimit && e.isSelectable && e.isContent) } isInline(t) { const e = this.getDefinition(t); return !!(e && e.isInline) } isSelectable(t) { const e = this.getDefinition(t); if (!e) { return false } return !!(e.isSelectable || e.isObject) } isContent(t) { const e = this.getDefinition(t); if (!e) { return false } return !!(e.isContent || e.isObject) } checkChild(t, e) { if (!e) { return false } return this._checkContextMatch(e, t) } checkAttribute(t, e) { const n = this.getDefinition(t.last); if (!n) { return false } return n.allowAttributes.includes(e) } checkMerge(t, e) { if (t instanceof bf) { const e = t.nodeBefore; const n = t.nodeAfter; if (!(e instanceof gf)) { throw new I("schema-check-merge-no-element-before", this) } if (!(n instanceof gf)) { throw new I("schema-check-merge-no-element-after", this) } return this.checkMerge(e, n) } for (const n of e.getChildren()) { if (!this.checkChild(t, n)) { return false } } return true } addChildCheck(t) { this.on("checkChild", ((e, [n, i]) => { if (!i) { return } const o = t(n, i); if (typeof o == "boolean") { e.stop(); e.return = o } }), { priority: "high" }) } addAttributeCheck(t) { this.on("checkAttribute", ((e, [n, i]) => { const o = t(n, i); if (typeof o == "boolean") { e.stop(); e.return = o } }), { priority: "high" }) } setAttributeProperties(t, e) { this._attributeProperties[t] = Object.assign(this.getAttributeProperties(t), e) } getAttributeProperties(t) { return this._attributeProperties[t] || {} } getLimitElement(t) { let e; if (t instanceof bf) { e = t.parent } else { const n = t instanceof yf ? [t] : Array.from(t.getRanges()); e = n.reduce(((t, e) => { const n = e.getCommonAncestor(); if (!t) { return n } return t.getCommonAncestor(n, { includeSelf: true }) }), null) } while (!this.isLimit(e)) { if (e.parent) { e = e.parent } else { break } } return e } checkAttributeInSelection(t, e) { if (t.isCollapsed) { const n = t.getFirstPosition(); const i = [...n.getAncestors(), new uf("", t.getAttributes())]; return this.checkAttribute(i, e) } else { const n = t.getRanges(); for (const t of n) { for (const n of t) { if (this.checkAttribute(n.item, e)) { return true } } } } return false } *getValidRanges(t, e) { t = qb(t); for (const n of t) { yield* this._getValidRangesForRange(n, e) } } getNearestSelectionRange(t, e = "both") { if (this.checkChild(t, "$text")) { return new yf(t) } let n, i; const o = t.getAncestors().reverse().find((t => this.isLimit(t))) || t.root; if (e == "both" || e == "backward") { n = new ff({ boundaries: yf._createIn(o), startPosition: t, direction: "backward" }) } if (e == "both" || e == "forward") { i = new ff({ boundaries: yf._createIn(o), startPosition: t }) } for (const t of Wb(n, i)) { const e = t.walker == n ? "elementEnd" : "elementStart"; const i = t.value; if (i.type == e && this.isObject(i.item)) { return yf._createOn(i.item) } if (this.checkChild(i.nextPosition, "$text")) { return new yf(i.nextPosition) } } return null } findAllowedParent(t, e) { let n = t.parent; while (n) { if (this.checkChild(n, e)) { return n } if (this.isLimit(n)) { return null } n = n.parent } return null } setAllowedAttributes(t, e, n) { const i = n.model; for (const [o, r] of Object.entries(e)) { if (i.schema.checkAttribute(t, o)) { n.setAttribute(o, r, t) } } } removeDisallowedAttributes(t, e) { for (const n of t) { if (n.is("$text")) { Gb(this, n, e) } else { const t = yf._createIn(n); const i = t.getPositions(); for (const t of i) { const n = t.nodeBefore || t.parent; Gb(this, n, e) } } } } getAttributesWithProperty(t, e, n) { const i = {}; for (const [o, r] of t.getAttributes()) { const t = this.getAttributeProperties(o); if (t[e] === undefined) { continue } if (n === undefined || n === t[e]) { i[o] = r } } return i } createContext(t) { return new Sb(t) } _clearCache() { this._compiledDefinitions = null } _compile() { const t = {}; const e = this._sourceDefinitions; const n = Object.keys(e); for (const i of n) { t[i] = Tb(e[i], i) } for (const e of n) { Ib(t, e) } for (const e of n) { Mb(t, e) } for (const e of n) { Bb(t, e) } for (const e of n) { Lb(t, e); Nb(t, e) } for (const e of n) { zb(t, e); Pb(t, e); Ob(t, e) } this._compiledDefinitions = t } _checkContextMatch(t, e, n = e.length - 1) { const i = e.getItem(n); if (t.allowIn.includes(i.name)) { if (n == 0) { return true } else { const t = this.getDefinition(i); return this._checkContextMatch(t, e, n - 1) } } else { return false } } *_getValidRangesForRange(t, e) { let n = t.start; let i = t.start; for (const o of t.getItems({ shallow: true })) { if (o.is("element")) { yield* this._getValidRangesForRange(yf._createIn(o), e) } if (!this.checkAttribute(o, e)) { if (!n.isEqual(i)) { yield new yf(n, i) } n = bf._createAfter(o) } i = bf._createAfter(o) } if (!n.isEqual(i)) { yield new yf(n, i) } } } class Sb { constructor(t) { if (t instanceof Sb) { return t } let e; if (typeof t == "string") { e = [t] } else if (!Array.isArray(t)) { e = t.getAncestors({ includeSelf: true }) } else { e = t } this._items = e.map(Ub) } get length() { return this._items.length } get last() { return this._items[this._items.length - 1] } [Symbol.iterator]() { return this._items[Symbol.iterator]() } push(t) { const e = new Sb([t]); e._items = [...this._items, ...e._items]; return e } getItem(t) { return this._items[t] } *getNames() { yield* this._items.map((t => t.name)) } endsWith(t) { return Array.from(this.getNames()).join(" ").endsWith(t) } startsWith(t) { return Array.from(this.getNames()).join(" ").startsWith(t) } } function Tb(t, e) { const n = { name: e, allowIn: [], allowContentOf: [], allowWhere: [], allowAttributes: [], allowAttributesOf: [], allowChildren: [], inheritTypesFrom: [] }; Rb(t, n); Vb(t, n, "allowIn"); Vb(t, n, "allowContentOf"); Vb(t, n, "allowWhere"); Vb(t, n, "allowAttributes"); Vb(t, n, "allowAttributesOf"); Vb(t, n, "allowChildren"); Vb(t, n, "inheritTypesFrom"); jb(t, n); return n } function Ib(t, e) { const n = t[e]; for (const i of n.allowChildren) { const n = t[i]; if (!n) { continue } n.allowIn.push(e) } n.allowChildren.length = 0 } function Mb(t, e) { for (const n of t[e].allowContentOf) { if (t[n]) { const i = Fb(t, n); i.forEach((t => { t.allowIn.push(e) })) } } delete t[e].allowContentOf } function Bb(t, e) { for (const n of t[e].allowWhere) { const i = t[n]; if (i) { const n = i.allowIn; t[e].allowIn.push(...n) } } delete t[e].allowWhere } function Lb(t, e) { for (const n of t[e].allowAttributesOf) { const i = t[n]; if (i) { const n = i.allowAttributes; t[e].allowAttributes.push(...n) } } delete t[e].allowAttributesOf } function Nb(t, e) { const n = t[e]; for (const e of n.inheritTypesFrom) { const i = t[e]; if (i) { const t = Object.keys(i).filter((t => t.startsWith("is"))); for (const e of t) { if (!(e in n)) { n[e] = i[e] } } } } delete n.inheritTypesFrom } function zb(t, e) { const n = t[e]; const i = n.allowIn.filter((e => t[e])); n.allowIn = Array.from(new Set(i)) } function Pb(t, e) { const n = t[e]; for (const i of n.allowIn) { const n = t[i]; n.allowChildren.push(e) } } function Ob(t, e) { const n = t[e]; n.allowAttributes = Array.from(new Set(n.allowAttributes)) } function Rb(t, e) { for (const n of t) { const t = Object.keys(n).filter((t => t.startsWith("is"))); for (const i of t) { e[i] = !!n[i] } } } function Vb(t, e, n) { for (const i of t) { const t = i[n]; if (typeof t == "string") { e[n].push(t) } else if (Array.isArray(t)) { e[n].push(...t) } } } function jb(t, e) { for (const n of t) { const t = n.inheritAllFrom; if (t) { e.allowContentOf.push(t); e.allowWhere.push(t); e.allowAttributesOf.push(t); e.inheritTypesFrom.push(t) } } } function Fb(t, e) { const n = t[e]; return Hb(t).filter((t => t.allowIn.includes(n.name))) } function Hb(t) { return Object.keys(t).map((e => t[e])) } function Ub(t) { if (typeof t == "string" || t.is("documentFragment")) { return { name: typeof t == "string" ? t : "$documentFragment", *getAttributeKeys() { }, getAttribute() { } } } else { return { name: t.is("element") ? t.name : "$text", *getAttributeKeys() { yield* t.getAttributeKeys() }, getAttribute(e) { return t.getAttribute(e) } } } } function* Wb(t, e) { let n = false; while (!n) { n = true; if (t) { const e = t.next(); if (!e.done) { n = false; yield { walker: t, value: e.value } } } if (e) { const t = e.next(); if (!t.done) { n = false; yield { walker: e, value: t.value } } } } } function* qb(t) { for (const e of t) { yield* e.getMinimalFlatRanges() } } function Gb(t, e, n) { for (const i of e.getAttributeKeys()) { if (!t.checkAttribute(e, i)) { n.removeAttribute(i, e) } } } class $b extends (U()) { constructor(t) { super(); this._splitParts = new Map; this._cursorParents = new Map; this._modelCursor = null; this._emptyElementsToKeep = new Set; this.conversionApi = { ...t, consumable: null, writer: null, store: null, convertItem: (t, e) => this._convertItem(t, e), convertChildren: (t, e) => this._convertChildren(t, e), safeInsert: (t, e) => this._safeInsert(t, e), updateConversionResult: (t, e) => this._updateConversionResult(t, e), splitToAllowedParent: (t, e) => this._splitToAllowedParent(t, e), getSplitParts: t => this._getSplitParts(t), keepEmptyElement: t => this._keepEmptyElement(t) } } convert(t, e, n = ["$root"]) { this.fire("viewCleanup", t); this._modelCursor = Yb(n, e); this.conversionApi.writer = e; this.conversionApi.consumable = yb.createFrom(t); this.conversionApi.store = {}; const { modelRange: i } = this._convertItem(t, this._modelCursor); const o = e.createDocumentFragment(); if (i) { this._removeEmptyElements(); for (const t of Array.from(this._modelCursor.parent.getChildren())) { e.append(t, o) } o.markers = Kb(o, e) } this._modelCursor = null; this._splitParts.clear(); this._cursorParents.clear(); this._emptyElementsToKeep.clear(); this.conversionApi.writer = null; this.conversionApi.store = null; return o } _convertItem(t, e) { const n = { viewItem: t, modelCursor: e, modelRange: null }; if (t.is("element")) { this.fire(`element:${t.name}`, n, this.conversionApi) } else if (t.is("$text")) { this.fire("text", n, this.conversionApi) } else { this.fire("documentFragment", n, this.conversionApi) } if (n.modelRange && !(n.modelRange instanceof yf)) { throw new I("view-conversion-dispatcher-incorrect-result", this) } return { modelRange: n.modelRange, modelCursor: n.modelCursor } } _convertChildren(t, e) { let n = e.is("position") ? e : bf._createAt(e, 0); const i = new yf(n); for (const e of Array.from(t.getChildren())) { const t = this._convertItem(e, n); if (t.modelRange instanceof yf) { i.end = t.modelRange.end; n = t.modelCursor } } return { modelRange: i, modelCursor: n } } _safeInsert(t, e) { const n = this._splitToAllowedParent(t, e); if (!n) { return false } this.conversionApi.writer.insert(t, n.position); return true } _updateConversionResult(t, e) { const n = this._getSplitParts(t); const i = this.conversionApi.writer; if (!e.modelRange) { e.modelRange = i.createRange(i.createPositionBefore(t), i.createPositionAfter(n[n.length - 1])) } const o = this._cursorParents.get(t); if (o) { e.modelCursor = i.createPositionAt(o, 0) } else { e.modelCursor = e.modelRange.end } } _splitToAllowedParent(t, e) { const { schema: n, writer: i } = this.conversionApi; let o = n.findAllowedParent(e, t); if (o) { if (o === e.parent) { return { position: e } } if (this._modelCursor.parent.getAncestors().includes(o)) { o = null } } if (!o) { if (!qp(e, t, n)) { return null } return { position: Gp(e, i) } } const r = this.conversionApi.writer.split(e, o); const s = []; for (const t of r.range.getWalker()) { if (t.type == "elementEnd") { s.push(t.item) } else { const e = s.pop(); const n = t.item; this._registerSplitPair(e, n) } } const a = r.range.end.parent; this._cursorParents.set(t, a); return { position: r.position, cursorParent: a } } _registerSplitPair(t, e) { if (!this._splitParts.has(t)) { this._splitParts.set(t, [t]) } const n = this._splitParts.get(t); this._splitParts.set(e, n); n.push(e) } _getSplitParts(t) { let e; if (!this._splitParts.has(t)) { e = [t] } else { e = this._splitParts.get(t) } return e } _keepEmptyElement(t) { this._emptyElementsToKeep.add(t) } _removeEmptyElements() { let t = false; for (const e of this._splitParts.keys()) { if (e.isEmpty && !this._emptyElementsToKeep.has(e)) { this.conversionApi.writer.remove(e); this._splitParts.delete(e); t = true } } if (t) { this._removeEmptyElements() } } } function Kb(t, e) { const n = new Set; const i = new Map; const o = yf._createIn(t).getItems(); for (const t of o) { if (t.is("element", "$marker")) { n.add(t) } } for (const t of n) { const n = t.getAttribute("data-name"); const o = e.createPositionBefore(t); if (!i.has(n)) { i.set(n, new yf(o.clone())) } else { i.get(n).end = o.clone() } e.remove(t) } return i } function Yb(t, e) { let n; for (const i of new Sb(t)) { const t = {}; for (const e of i.getAttributeKeys()) { t[e] = i.getAttribute(e) } const o = e.createElement(i.name, t); if (n) { e.insert(o, n) } n = bf._createAt(o, 0) } return n } class Qb { getHtml(t) { const e = document.implementation.createHTMLDocument(""); const n = e.createElement("div"); n.appendChild(t); return n.innerHTML } } class Zb { constructor(t) { this.skipComments = true; this.domParser = new DOMParser; this.domConverter = new kg(t, { renderingMode: "data" }); this.htmlWriter = new Qb } toData(t) { const e = this.domConverter.viewToDom(t); return this.htmlWriter.getHtml(e) } toView(t) { const e = this._toDom(t); return this.domConverter.domToView(e, { skipComments: this.skipComments }) } registerRawContentMatcher(t) { this.domConverter.registerRawContentMatcher(t) } useFillerType(t) { this.domConverter.blockFillerMode = t == "marked" ? "markedNbsp" : "nbsp" } _toDom(t) { if (!t.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i)) { t = `<body>${t}</body>` } const e = this.domParser.parseFromString(t, "text/html"); const n = e.createDocumentFragment(); const i = e.body.childNodes; while (i.length > 0) { n.appendChild(i[0]) } return n } } class Jb extends (U()) { constructor(t, e) { super(); this.model = t; this.mapper = new xf; this.downcastDispatcher = new Sf({ mapper: this.mapper, schema: t.schema }); this.downcastDispatcher.on("insert:$text", ep(), { priority: "lowest" }); this.downcastDispatcher.on("insert", np(), { priority: "lowest" }); this.upcastDispatcher = new $b({ schema: t.schema }); this.viewDocument = new ph(e); this.stylesProcessor = e; this.htmlProcessor = new Zb(this.viewDocument); this.processor = this.htmlProcessor; this._viewWriter = new Mh(this.viewDocument); this.upcastDispatcher.on("text", Yp(), { priority: "lowest" }); this.upcastDispatcher.on("element", Kp(), { priority: "lowest" }); this.upcastDispatcher.on("documentFragment", Kp(), { priority: "lowest" }); lt().prototype.decorate.call(this, "init"); lt().prototype.decorate.call(this, "set"); lt().prototype.decorate.call(this, "get"); lt().prototype.decorate.call(this, "toView"); lt().prototype.decorate.call(this, "toModel"); this.on("init", (() => { this.fire("ready") }), { priority: "lowest" }); this.on("ready", (() => { this.model.enqueueChange({ isUndoable: false }, Wp) }), { priority: "lowest" }) } get(t = {}) { const { rootName: e = "main", trim: n = "empty" } = t; if (!this._checkIfRootsExists([e])) { throw new I("datacontroller-get-non-existent-root", this) } const i = this.model.document.getRoot(e); if (!i.isAttached()) { M("datacontroller-get-detached-root", this) } if (n === "empty" && !this.model.hasContent(i, { ignoreWhitespaces: true })) { return "" } return this.stringify(i, t) } stringify(t, e = {}) { const n = this.toView(t, e); return this.processor.toData(n) } toView(t, e = {}) { const n = this.viewDocument; const i = this._viewWriter; this.mapper.clearBindings(); const o = yf._createIn(t); const r = new Th(n); this.mapper.bindElements(t, r); const s = t.is("documentFragment") ? t.markers : Xb(t); this.downcastDispatcher.convert(o, s, i, e); return r } init(t) { if (this.model.document.version) { throw new I("datacontroller-init-document-not-empty", this) } let e = {}; if (typeof t === "string") { e.main = t } else { e = t } if (!this._checkIfRootsExists(Object.keys(e))) { throw new I("datacontroller-init-non-existent-root", this) } this.model.enqueueChange({ isUndoable: false }, (t => { for (const n of Object.keys(e)) { const i = this.model.document.getRoot(n); t.insert(this.parse(e[n], i), i, 0) } })); return Promise.resolve() } set(t, e = {}) { let n = {}; if (typeof t === "string") { n.main = t } else { n = t } if (!this._checkIfRootsExists(Object.keys(n))) { throw new I("datacontroller-set-non-existent-root", this) } this.model.enqueueChange(e.batchType || {}, (t => { t.setSelection(null); t.removeSelectionAttribute(this.model.document.selection.getAttributeKeys()); for (const e of Object.keys(n)) { const i = this.model.document.getRoot(e); t.remove(t.createRangeIn(i)); t.insert(this.parse(n[e], i), i, 0) } })) } parse(t, e = "$root") { const n = this.processor.toView(t); return this.toModel(n, e) } toModel(t, e = "$root") { return this.model.change((n => this.upcastDispatcher.convert(t, n, e))) } addStyleProcessorRules(t) { t(this.stylesProcessor) } registerRawContentMatcher(t) { if (this.processor && this.processor !== this.htmlProcessor) { this.processor.registerRawContentMatcher(t) } this.htmlProcessor.registerRawContentMatcher(t) } destroy() { this.stopListening() } _checkIfRootsExists(t) { for (const e of t) { if (!this.model.document.getRoot(e)) { return false } } return true } } function Xb(t) { const e = []; const n = t.root.document; if (!n) { return new Map } const i = yf._createIn(t); for (const t of n.model.markers) { const n = t.getRange(); const o = n.isCollapsed; const r = n.start.isEqual(i.start) || n.end.isEqual(i.end); if (o && r) { e.push([t.name, n]) } else { const o = i.getIntersection(n); if (o) { e.push([t.name, o]) } } } e.sort((([t, e], [n, i]) => { if (e.end.compareWith(i.start) !== "after") { return 1 } else if (e.start.compareWith(i.end) !== "before") { return -1 } else { switch (e.start.compareWith(i.start)) { case "before": return 1; case "after": return -1; default: switch (e.end.compareWith(i.end)) { case "before": return 1; case "after": return -1; default: return n.localeCompare(t) } } } })); return new Map(e) } class tk { constructor(t, e) { this._helpers = new Map; this._downcast = $c(t); this._createConversionHelpers({ name: "downcast", dispatchers: this._downcast, isDowncast: true }); this._upcast = $c(e); this._createConversionHelpers({ name: "upcast", dispatchers: this._upcast, isDowncast: false }) } addAlias(t, e) { const n = this._downcast.includes(e); const i = this._upcast.includes(e); if (!i && !n) { throw new I("conversion-add-alias-dispatcher-not-registered", this) } this._createConversionHelpers({ name: t, dispatchers: [e], isDowncast: n }) } for(t) { if (!this._helpers.has(t)) { throw new I("conversion-for-unknown-group", this) } return this._helpers.get(t) } elementToElement(t) { this.for("downcast").elementToElement(t); for (const { model: e, view: n } of ek(t)) { this.for("upcast").elementToElement({ model: e, view: n, converterPriority: t.converterPriority }) } } attributeToElement(t) { this.for("downcast").attributeToElement(t); for (const { model: e, view: n } of ek(t)) { this.for("upcast").elementToAttribute({ view: n, model: e, converterPriority: t.converterPriority }) } } attributeToAttribute(t) { this.for("downcast").attributeToAttribute(t); for (const { model: e, view: n } of ek(t)) { this.for("upcast").attributeToAttribute({ view: n, model: e }) } } _createConversionHelpers({ name: t, dispatchers: e, isDowncast: n }) { if (this._helpers.has(t)) { throw new I("conversion-group-exists", this) } const i = n ? new tp(e) : new $p(e); this._helpers.set(t, i) } } function* ek(t) { if (t.model.values) { for (const e of t.model.values) { const n = { key: t.model.key, value: e }; const i = t.view[e]; const o = t.upcastAlso ? t.upcastAlso[e] : undefined; yield* nk(n, i, o) } } else { yield* nk(t.model, t.view, t.upcastAlso) } } function* nk(t, e, n) { yield { model: t, view: e }; if (n) { for (const e of $c(n)) { yield { model: t, view: e } } } } class ik { constructor(t) { this.baseVersion = t; this.isDocumentOperation = this.baseVersion !== null; this.batch = null } _validate() { } toJSON() { const t = Object.assign({}, this); t.__className = this.constructor.className; delete t.batch; delete t.isDocumentOperation; return t } static get className() { return "Operation" } static fromJSON(t, e) { return new this(t.baseVersion) } } function ok(t, e) { const n = ck(e); const i = n.reduce(((t, e) => t + e.offsetSize), 0); const o = t.parent; dk(t); const r = t.index; o._insertChild(r, n); lk(o, r + n.length); lk(o, r); return new yf(t, t.getShiftedBy(i)) } function rk(t) { if (!t.isFlat) { throw new I("operation-utils-remove-range-not-flat", this) } const e = t.start.parent; dk(t.start); dk(t.end); const n = e._removeChildren(t.start.index, t.end.index - t.start.index); lk(e, t.start.index); return n } function sk(t, e) { if (!t.isFlat) { throw new I("operation-utils-move-range-not-flat", this) } const n = rk(t); e = e._getTransformedByDeletion(t.start, t.end.offset - t.start.offset); return ok(e, n) } function ak(t, e, n) { dk(t.start); dk(t.end); for (const i of t.getItems({ shallow: true })) { const t = i.is("$textProxy") ? i.textNode : i; if (n !== null) { t._setAttribute(e, n) } else { t._removeAttribute(e) } lk(t.parent, t.index) } lk(t.end.parent, t.end.index) } function ck(t) { const e = []; function n(t) { if (typeof t == "string") { e.push(new uf(t)) } else if (t instanceof hf) { e.push(new uf(t.data, t.getAttributes())) } else if (t instanceof lf) { e.push(t) } else if (Ct(t)) { for (const e of t) { n(e) } } } n(t); for (let t = 1; t < e.length; t++) { const n = e[t]; const i = e[t - 1]; if (n instanceof uf && i instanceof uf && uk(n, i)) { e.splice(t - 1, 2, new uf(i.data + n.data, i.getAttributes())); t-- } } return e } function lk(t, e) { const n = t.getChild(e - 1); const i = t.getChild(e); if (n && i && n.is("$text") && i.is("$text") && uk(n, i)) { const o = new uf(n.data + i.data, n.getAttributes()); t._removeChildren(e - 1, 2); t._insertChild(e - 1, o) } } function dk(t) { const e = t.textNode; const n = t.parent; if (e) { const i = t.offset - e.startOffset; const o = e.index; n._removeChildren(o, 1); const r = new uf(e.data.substr(0, i), e.getAttributes()); const s = new uf(e.data.substr(i), e.getAttributes()); n._insertChild(o, [r, s]) } } function uk(t, e) { const n = t.getAttributes(); const i = e.getAttributes(); for (const t of n) { if (t[1] !== e.getAttribute(t[0])) { return false } i.next() } return i.next().done } class hk extends ik { constructor(t, e, n, i) { super(i); this.sourcePosition = t.clone(); this.sourcePosition.stickiness = "toNext"; this.howMany = e; this.targetPosition = n.clone(); this.targetPosition.stickiness = "toNone" } get type() { if (this.targetPosition.root.rootName == "$graveyard") { return "remove" } else if (this.sourcePosition.root.rootName == "$graveyard") { return "reinsert" } return "move" } clone() { return new hk(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion) } getMovedRangeStart() { return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany) } getReversed() { const t = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany); return new hk(this.getMovedRangeStart(), this.howMany, t, this.baseVersion + 1) } _validate() { const t = this.sourcePosition.parent; const e = this.targetPosition.parent; const n = this.sourcePosition.offset; const i = this.targetPosition.offset; if (n + this.howMany > t.maxOffset) { throw new I("move-operation-nodes-do-not-exist", this) } else if (t === e && n < i && i < n + this.howMany) { throw new I("move-operation-range-into-itself", this) } else if (this.sourcePosition.root == this.targetPosition.root) { if (_t(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") { const t = this.sourcePosition.path.length - 1; if (this.targetPosition.path[t] >= n && this.targetPosition.path[t] < n + this.howMany) { throw new I("move-operation-node-into-itself", this) } } } } _execute() { sk(yf._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition) } toJSON() { const t = super.toJSON(); t.sourcePosition = this.sourcePosition.toJSON(); t.targetPosition = this.targetPosition.toJSON(); return t } static get className() { return "MoveOperation" } static fromJSON(t, e) { const n = bf.fromJSON(t.sourcePosition, e); const i = bf.fromJSON(t.targetPosition, e); return new this(n, t.howMany, i, t.baseVersion) } } class gk extends ik { constructor(t, e, n) { super(n); this.position = t.clone(); this.position.stickiness = "toNone"; this.nodes = new df(ck(e)); this.shouldReceiveAttributes = false } get type() { return "insert" } get howMany() { return this.nodes.maxOffset } clone() { const t = new df([...this.nodes].map((t => t._clone(true)))); const e = new gk(this.position, t, this.baseVersion); e.shouldReceiveAttributes = this.shouldReceiveAttributes; return e } getReversed() { const t = this.position.root.document.graveyard; const e = new bf(t, [0]); return new hk(this.position, this.nodes.maxOffset, e, this.baseVersion + 1) } _validate() { const t = this.position.parent; if (!t || t.maxOffset < this.position.offset) { throw new I("insert-operation-position-invalid", this) } } _execute() { const t = this.nodes; this.nodes = new df([...t].map((t => t._clone(true)))); ok(this.position, t) } toJSON() { const t = super.toJSON(); t.position = this.position.toJSON(); t.nodes = this.nodes.toJSON(); return t } static get className() { return "InsertOperation" } static fromJSON(t, e) { const n = []; for (const e of t.nodes) { if (e.name) { n.push(gf.fromJSON(e)) } else { n.push(uf.fromJSON(e)) } } const i = new gk(bf.fromJSON(t.position, e), n, t.baseVersion); i.shouldReceiveAttributes = t.shouldReceiveAttributes; return i } } class mk extends ik { constructor(t, e, n, i, o) { super(o); this.splitPosition = t.clone(); this.splitPosition.stickiness = "toNext"; this.howMany = e; this.insertionPosition = n; this.graveyardPosition = i ? i.clone() : null; if (this.graveyardPosition) { this.graveyardPosition.stickiness = "toNext" } } get type() { return "split" } get moveTargetPosition() { const t = this.insertionPosition.path.slice(); t.push(0); return new bf(this.insertionPosition.root, t) } get movedRange() { const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY); return new yf(this.splitPosition, t) } clone() { return new mk(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion) } getReversed() { const t = this.splitPosition.root.document.graveyard; const e = new bf(t, [0]); return new fk(this.moveTargetPosition, this.howMany, this.splitPosition, e, this.baseVersion + 1) } _validate() { const t = this.splitPosition.parent; const e = this.splitPosition.offset; if (!t || t.maxOffset < e) { throw new I("split-operation-position-invalid", this) } else if (!t.parent) { throw new I("split-operation-split-in-root", this) } else if (this.howMany != t.maxOffset - this.splitPosition.offset) { throw new I("split-operation-how-many-invalid", this) } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) { throw new I("split-operation-graveyard-position-invalid", this) } } _execute() { const t = this.splitPosition.parent; if (this.graveyardPosition) { sk(yf._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition) } else { const e = t._clone(); ok(this.insertionPosition, e) } const e = new yf(bf._createAt(t, this.splitPosition.offset), bf._createAt(t, t.maxOffset)); sk(e, this.moveTargetPosition) } toJSON() { const t = super.toJSON(); t.splitPosition = this.splitPosition.toJSON(); t.insertionPosition = this.insertionPosition.toJSON(); if (this.graveyardPosition) { t.graveyardPosition = this.graveyardPosition.toJSON() } return t } static get className() { return "SplitOperation" } static getInsertionPosition(t) { const e = t.path.slice(0, -1); e[e.length - 1]++; return new bf(t.root, e, "toPrevious") } static fromJSON(t, e) { const n = bf.fromJSON(t.splitPosition, e); const i = bf.fromJSON(t.insertionPosition, e); const o = t.graveyardPosition ? bf.fromJSON(t.graveyardPosition, e) : null; return new this(n, t.howMany, i, o, t.baseVersion) } } class fk extends ik { constructor(t, e, n, i, o) { super(o); this.sourcePosition = t.clone(); this.sourcePosition.stickiness = "toPrevious"; this.howMany = e; this.targetPosition = n.clone(); this.targetPosition.stickiness = "toNext"; this.graveyardPosition = i.clone() } get type() { return "merge" } get deletionPosition() { return new bf(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1)) } get movedRange() { const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY); return new yf(this.sourcePosition, t) } clone() { return new fk(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion) } getReversed() { const t = this.targetPosition._getTransformedByMergeOperation(this); const e = this.sourcePosition.path.slice(0, -1); const n = new bf(this.sourcePosition.root, e)._getTransformedByMergeOperation(this); return new mk(t, this.howMany, n, this.graveyardPosition, this.baseVersion + 1) } _validate() { const t = this.sourcePosition.parent; const e = this.targetPosition.parent; if (!t.parent) { throw new I("merge-operation-source-position-invalid", this) } else if (!e.parent) { throw new I("merge-operation-target-position-invalid", this) } else if (this.howMany != t.maxOffset) { throw new I("merge-operation-how-many-invalid", this) } } _execute() { const t = this.sourcePosition.parent; const e = yf._createIn(t); sk(e, this.targetPosition); sk(yf._createOn(t), this.graveyardPosition) } toJSON() { const t = super.toJSON(); t.sourcePosition = t.sourcePosition.toJSON(); t.targetPosition = t.targetPosition.toJSON(); t.graveyardPosition = t.graveyardPosition.toJSON(); return t } static get className() { return "MergeOperation" } static fromJSON(t, e) { const n = bf.fromJSON(t.sourcePosition, e); const i = bf.fromJSON(t.targetPosition, e); const o = bf.fromJSON(t.graveyardPosition, e); return new this(n, t.howMany, i, o, t.baseVersion) } } class pk extends ik { constructor(t, e, n, i, o, r) { super(r); this.name = t; this.oldRange = e ? e.clone() : null; this.newRange = n ? n.clone() : null; this.affectsData = o; this._markers = i } get type() { return "marker" } clone() { return new pk(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion) } getReversed() { return new pk(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1) } _execute() { if (this.newRange) { this._markers._set(this.name, this.newRange, true, this.affectsData) } else { this._markers._remove(this.name) } } toJSON() { const t = super.toJSON(); if (this.oldRange) { t.oldRange = this.oldRange.toJSON() } if (this.newRange) { t.newRange = this.newRange.toJSON() } delete t._markers; return t } static get className() { return "MarkerOperation" } static fromJSON(t, e) { return new pk(t.name, t.oldRange ? yf.fromJSON(t.oldRange, e) : null, t.newRange ? yf.fromJSON(t.newRange, e) : null, e.model.markers, t.affectsData, t.baseVersion) } } function bk(t, e) { return $m(t, e) } const kk = bk; class wk extends ik { constructor(t, e, n, i, o) { super(o); this.range = t.clone(); this.key = e; this.oldValue = n === undefined ? null : n; this.newValue = i === undefined ? null : i } get type() { if (this.oldValue === null) { return "addAttribute" } else if (this.newValue === null) { return "removeAttribute" } else { return "changeAttribute" } } clone() { return new wk(this.range, this.key, this.oldValue, this.newValue, this.baseVersion) } getReversed() { return new wk(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1) } toJSON() { const t = super.toJSON(); t.range = this.range.toJSON(); return t } _validate() { if (!this.range.isFlat) { throw new I("attribute-operation-range-not-flat", this) } for (const t of this.range.getItems({ shallow: true })) { if (this.oldValue !== null && !kk(t.getAttribute(this.key), this.oldValue)) { throw new I("attribute-operation-wrong-old-value", this, { item: t, key: this.key, value: this.oldValue }) } if (this.oldValue === null && this.newValue !== null && t.hasAttribute(this.key)) { throw new I("attribute-operation-attribute-exists", this, { node: t, key: this.key }) } } } _execute() { if (!kk(this.oldValue, this.newValue)) { ak(this.range, this.key, this.newValue) } } static get className() { return "AttributeOperation" } static fromJSON(t, e) { return new wk(yf.fromJSON(t.range, e), t.key, t.oldValue, t.newValue, t.baseVersion) } } class Ak extends ik { get type() { return "noop" } clone() { return new Ak(this.baseVersion) } getReversed() { return new Ak(this.baseVersion + 1) } _execute() { } static get className() { return "NoOperation" } } class _k extends ik { constructor(t, e, n, i) { super(i); this.position = t; this.position.stickiness = "toNext"; this.oldName = e; this.newName = n } get type() { return "rename" } clone() { return new _k(this.position.clone(), this.oldName, this.newName, this.baseVersion) } getReversed() { return new _k(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1) } _validate() { const t = this.position.nodeAfter; if (!(t instanceof gf)) { throw new I("rename-operation-wrong-position", this) } else if (t.name !== this.oldName) { throw new I("rename-operation-wrong-name", this) } } _execute() { const t = this.position.nodeAfter; t.name = this.newName } toJSON() { const t = super.toJSON(); t.position = this.position.toJSON(); return t } static get className() { return "RenameOperation" } static fromJSON(t, e) { return new _k(bf.fromJSON(t.position, e), t.oldName, t.newName, t.baseVersion) } } class Ck extends ik { constructor(t, e, n, i, o) { super(o); this.root = t; this.key = e; this.oldValue = n === undefined ? null : n; this.newValue = i === undefined ? null : i } get type() { if (this.oldValue === null) { return "addRootAttribute" } else if (this.newValue === null) { return "removeRootAttribute" } else { return "changeRootAttribute" } } clone() { return new Ck(this.root, this.key, this.oldValue, this.newValue, this.baseVersion) } getReversed() { return new Ck(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1) } _validate() { if (this.root != this.root.root || this.root.is("documentFragment")) { throw new I("rootattribute-operation-not-a-root", this, { root: this.root, key: this.key }) } if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) { throw new I("rootattribute-operation-wrong-old-value", this, { root: this.root, key: this.key }) } if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) { throw new I("rootattribute-operation-attribute-exists", this, { root: this.root, key: this.key }) } } _execute() { if (this.newValue !== null) { this.root._setAttribute(this.key, this.newValue) } else { this.root._removeAttribute(this.key) } } toJSON() { const t = super.toJSON(); t.root = this.root.toJSON(); return t } static get className() { return "RootAttributeOperation" } static fromJSON(t, e) { if (!e.getRoot(t.root)) { throw new I("rootattribute-operation-fromjson-no-root", this, { rootName: t.root }) } return new Ck(e.getRoot(t.root), t.key, t.oldValue, t.newValue, t.baseVersion) } } class vk extends ik { constructor(t, e, n, i, o) { super(o); this.rootName = t; this.elementName = e; this.isAdd = n; this._document = i; if (!this._document.getRoot(this.rootName)) { const t = this._document.createRoot(this.elementName, this.rootName); t._isAttached = false } } get type() { return this.isAdd ? "addRoot" : "detachRoot" } clone() { return new vk(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion) } getReversed() { return new vk(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1) } _validate() { const t = this._document.getRoot(this.rootName); if (t.isAttached() && this.isAdd) { throw new I("root-operation-root-attached", this) } else if (!t.isAttached() && !this.isAdd) { throw new I("root-operation-root-detached", this) } } _execute() { this._document.getRoot(this.rootName)._isAttached = this.isAdd } toJSON() { const t = super.toJSON(); delete t._document; return t } static get className() { return "RootOperation" } static fromJSON(t, e) { return new vk(t.rootName, t.elementName, t.isAdd, e, t.baseVersion) } } const yk = {}; yk[wk.className] = wk; yk[gk.className] = gk; yk[pk.className] = pk; yk[hk.className] = hk; yk[Ak.className] = Ak; yk[ik.className] = ik; yk[_k.className] = _k; yk[Ck.className] = Ck; yk[vk.className] = vk; yk[mk.className] = mk; yk[fk.className] = fk; class xk { static fromJSON(t, e) { return yk[t.__className].fromJSON(t, e) } } const Ek = new Map; function Dk(t, e, n) { let i = Ek.get(t); if (!i) { i = new Map; Ek.set(t, i) } i.set(e, n) } function Sk(t, e) { const n = Ek.get(t); if (n && n.has(e)) { return n.get(e) } return Tk } function Tk(t) { return [t] } function Ik(t, e, n = {}) { const i = Sk(t.constructor, e.constructor); try { t = t.clone(); return i(t, e, n) } catch (t) { throw t } } function Mk(t, e, n) { t = t.slice(); e = e.slice(); const i = new Bk(n.document, n.useRelations, n.forceWeakRemove); i.setOriginalOperations(t); i.setOriginalOperations(e); const o = i.originalOperations; if (t.length == 0 || e.length == 0) { return { operationsA: t, operationsB: e, originalOperations: o } } const r = new WeakMap; for (const e of t) { r.set(e, 0) } const s = { nextBaseVersionA: t[t.length - 1].baseVersion + 1, nextBaseVersionB: e[e.length - 1].baseVersion + 1, originalOperationsACount: t.length, originalOperationsBCount: e.length }; let a = 0; while (a < t.length) { const n = t[a]; const o = r.get(n); if (o == e.length) { a++; continue } const s = e[o]; const c = Ik(n, s, i.getContext(n, s, true)); const l = Ik(s, n, i.getContext(s, n, false)); i.updateRelation(n, s); i.setOriginalOperations(c, n); i.setOriginalOperations(l, s); for (const t of c) { r.set(t, o + l.length) } t.splice(a, 1, ...c); e.splice(o, 1, ...l) } if (n.padWithNoOps) { const n = t.length - s.originalOperationsACount; const i = e.length - s.originalOperationsBCount; Nk(t, i - n); Nk(e, n - i) } Lk(t, s.nextBaseVersionB); Lk(e, s.nextBaseVersionA); return { operationsA: t, operationsB: e, originalOperations: o } } class Bk { constructor(t, e, n = false) { this.originalOperations = new Map; this._history = t.history; this._useRelations = e; this._forceWeakRemove = !!n; this._relations = new Map } setOriginalOperations(t, e = null) { const n = e ? this.originalOperations.get(e) : null; for (const e of t) { this.originalOperations.set(e, n || e) } } updateRelation(t, e) { if (t instanceof hk) { if (e instanceof fk) { if (t.targetPosition.isEqual(e.sourcePosition) || e.movedRange.containsPosition(t.targetPosition)) { this._setRelation(t, e, "insertAtSource") } else if (t.targetPosition.isEqual(e.deletionPosition)) { this._setRelation(t, e, "insertBetween") } else if (t.targetPosition.isAfter(e.sourcePosition)) { this._setRelation(t, e, "moveTargetAfter") } } else if (e instanceof hk) { if (t.targetPosition.isEqual(e.sourcePosition) || t.targetPosition.isBefore(e.sourcePosition)) { this._setRelation(t, e, "insertBefore") } else { this._setRelation(t, e, "insertAfter") } } } else if (t instanceof mk) { if (e instanceof fk) { if (t.splitPosition.isBefore(e.sourcePosition)) { this._setRelation(t, e, "splitBefore") } } else if (e instanceof hk) { if (t.splitPosition.isEqual(e.sourcePosition) || t.splitPosition.isBefore(e.sourcePosition)) { this._setRelation(t, e, "splitBefore") } else { const n = yf._createFromPositionAndShift(e.sourcePosition, e.howMany); if (t.splitPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(t.splitPosition)) { const i = n.end.offset - t.splitPosition.offset; const o = t.splitPosition.offset - n.start.offset; this._setRelation(t, e, { howMany: i, offset: o }) } } } } else if (t instanceof fk) { if (e instanceof fk) { if (!t.targetPosition.isEqual(e.sourcePosition)) { this._setRelation(t, e, "mergeTargetNotMoved") } if (t.sourcePosition.isEqual(e.targetPosition)) { this._setRelation(t, e, "mergeSourceNotMoved") } if (t.sourcePosition.isEqual(e.sourcePosition)) { this._setRelation(t, e, "mergeSameElement") } } else if (e instanceof mk) { if (t.sourcePosition.isEqual(e.splitPosition)) { this._setRelation(t, e, "splitAtSource") } } } else if (t instanceof pk) { const n = t.newRange; if (!n) { return } if (e instanceof hk) { const i = yf._createFromPositionAndShift(e.sourcePosition, e.howMany); const o = i.containsPosition(n.start) || i.start.isEqual(n.start); const r = i.containsPosition(n.end) || i.end.isEqual(n.end); if ((o || r) && !i.containsRange(n)) { this._setRelation(t, e, { side: o ? "left" : "right", path: o ? n.start.path.slice() : n.end.path.slice() }) } } else if (e instanceof fk) { const i = n.start.isEqual(e.targetPosition); const o = n.start.isEqual(e.deletionPosition); const r = n.end.isEqual(e.deletionPosition); const s = n.end.isEqual(e.sourcePosition); if (i || o || r || s) { this._setRelation(t, e, { wasInLeftElement: i, wasStartBeforeMergedElement: o, wasEndBeforeMergedElement: r, wasInRightElement: s }) } } } } getContext(t, e, n) { return { aIsStrong: n, aWasUndone: this._wasUndone(t), bWasUndone: this._wasUndone(e), abRelation: this._useRelations ? this._getRelation(t, e) : null, baRelation: this._useRelations ? this._getRelation(e, t) : null, forceWeakRemove: this._forceWeakRemove } } _wasUndone(t) { const e = this.originalOperations.get(t); return e.wasUndone || this._history.isUndoneOperation(e) } _getRelation(t, e) { const n = this.originalOperations.get(e); const i = this._history.getUndoneOperation(n); if (!i) { return null } const o = this.originalOperations.get(t); const r = this._relations.get(o); if (r) { return r.get(i) || null } return null } _setRelation(t, e, n) { const i = this.originalOperations.get(t); const o = this.originalOperations.get(e); let r = this._relations.get(i); if (!r) { r = new Map; this._relations.set(i, r) } r.set(o, n) } } function Lk(t, e) { for (const n of t) { n.baseVersion = e++ } } function Nk(t, e) { for (let n = 0; n < e; n++) { t.push(new Ak(0)) } } Dk(wk, wk, ((t, e, n) => { if (t.key === e.key && t.range.start.hasSameParentAs(e.range.start)) { const i = t.range.getDifference(e.range).map((e => new wk(e, t.key, t.oldValue, t.newValue, 0))); const o = t.range.getIntersection(e.range); if (o) { if (n.aIsStrong) { i.push(new wk(o, e.key, e.newValue, t.newValue, 0)) } } if (i.length == 0) { return [new Ak(0)] } return i } else { return [t] } })); Dk(wk, gk, ((t, e) => { if (t.range.start.hasSameParentAs(e.position) && t.range.containsPosition(e.position)) { const n = t.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes); const i = n.map((e => new wk(e, t.key, t.oldValue, t.newValue, t.baseVersion))); if (e.shouldReceiveAttributes) { const n = zk(e, t.key, t.oldValue); if (n) { i.unshift(n) } } return i } t.range = t.range._getTransformedByInsertion(e.position, e.howMany, false)[0]; return [t] })); function zk(t, e, n) { const i = t.nodes; const o = i.getNode(0).getAttribute(e); if (o == n) { return null } const r = new yf(t.position, t.position.getShiftedBy(t.howMany)); return new wk(r, e, o, n, 0) } Dk(wk, fk, ((t, e) => { const n = []; if (t.range.start.hasSameParentAs(e.deletionPosition)) { if (t.range.containsPosition(e.deletionPosition) || t.range.start.isEqual(e.deletionPosition)) { n.push(yf._createFromPositionAndShift(e.graveyardPosition, 1)) } } const i = t.range._getTransformedByMergeOperation(e); if (!i.isCollapsed) { n.push(i) } return n.map((e => new wk(e, t.key, t.oldValue, t.newValue, t.baseVersion))) })); Dk(wk, hk, ((t, e) => { const n = Pk(t.range, e); return n.map((e => new wk(e, t.key, t.oldValue, t.newValue, t.baseVersion))) })); function Pk(t, e) { const n = yf._createFromPositionAndShift(e.sourcePosition, e.howMany); let i = null; let o = []; if (n.containsRange(t, true)) { i = t } else if (t.start.hasSameParentAs(n.start)) { o = t.getDifference(n); i = t.getIntersection(n) } else { o = [t] } const r = []; for (let t of o) { t = t._getTransformedByDeletion(e.sourcePosition, e.howMany); const n = e.getMovedRangeStart(); const i = t.start.hasSameParentAs(n); const o = t._getTransformedByInsertion(n, e.howMany, i); r.push(...o) } if (i) { r.push(i._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany, false)[0]) } return r } Dk(wk, mk, ((t, e) => { if (t.range.end.isEqual(e.insertionPosition)) { if (!e.graveyardPosition) { t.range.end.offset++ } return [t] } if (t.range.start.hasSameParentAs(e.splitPosition) && t.range.containsPosition(e.splitPosition)) { const n = t.clone(); n.range = new yf(e.moveTargetPosition.clone(), t.range.end._getCombined(e.splitPosition, e.moveTargetPosition)); t.range.end = e.splitPosition.clone(); t.range.end.stickiness = "toPrevious"; return [t, n] } t.range = t.range._getTransformedBySplitOperation(e); return [t] })); Dk(gk, wk, ((t, e) => { const n = [t]; if (t.shouldReceiveAttributes && t.position.hasSameParentAs(e.range.start) && e.range.containsPosition(t.position)) { const i = zk(t, e.key, e.newValue); if (i) { n.push(i) } } return n })); Dk(gk, gk, ((t, e, n) => { if (t.position.isEqual(e.position) && n.aIsStrong) { return [t] } t.position = t.position._getTransformedByInsertOperation(e); return [t] })); Dk(gk, hk, ((t, e) => { t.position = t.position._getTransformedByMoveOperation(e); return [t] })); Dk(gk, mk, ((t, e) => { t.position = t.position._getTransformedBySplitOperation(e); return [t] })); Dk(gk, fk, ((t, e) => { t.position = t.position._getTransformedByMergeOperation(e); return [t] })); Dk(pk, gk, ((t, e) => { if (t.oldRange) { t.oldRange = t.oldRange._getTransformedByInsertOperation(e)[0] } if (t.newRange) { t.newRange = t.newRange._getTransformedByInsertOperation(e)[0] } return [t] })); Dk(pk, pk, ((t, e, n) => { if (t.name == e.name) { if (n.aIsStrong) { t.oldRange = e.newRange ? e.newRange.clone() : null } else { return [new Ak(0)] } } return [t] })); Dk(pk, fk, ((t, e) => { if (t.oldRange) { t.oldRange = t.oldRange._getTransformedByMergeOperation(e) } if (t.newRange) { t.newRange = t.newRange._getTransformedByMergeOperation(e) } return [t] })); Dk(pk, hk, ((t, e, n) => { if (t.oldRange) { t.oldRange = yf._createFromRanges(t.oldRange._getTransformedByMoveOperation(e)) } if (t.newRange) { if (n.abRelation) { const i = yf._createFromRanges(t.newRange._getTransformedByMoveOperation(e)); if (n.abRelation.side == "left" && e.targetPosition.isEqual(t.newRange.start)) { t.newRange.end = i.end; t.newRange.start.path = n.abRelation.path; return [t] } else if (n.abRelation.side == "right" && e.targetPosition.isEqual(t.newRange.end)) { t.newRange.start = i.start; t.newRange.end.path = n.abRelation.path; return [t] } } t.newRange = yf._createFromRanges(t.newRange._getTransformedByMoveOperation(e)) } return [t] })); Dk(pk, mk, ((t, e, n) => { if (t.oldRange) { t.oldRange = t.oldRange._getTransformedBySplitOperation(e) } if (t.newRange) { if (n.abRelation) { const i = t.newRange._getTransformedBySplitOperation(e); if (t.newRange.start.isEqual(e.splitPosition) && n.abRelation.wasStartBeforeMergedElement) { t.newRange.start = bf._createAt(e.insertionPosition) } else if (t.newRange.start.isEqual(e.splitPosition) && !n.abRelation.wasInLeftElement) { t.newRange.start = bf._createAt(e.moveTargetPosition) } if (t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasInRightElement) { t.newRange.end = bf._createAt(e.moveTargetPosition) } else if (t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasEndBeforeMergedElement) { t.newRange.end = bf._createAt(e.insertionPosition) } else { t.newRange.end = i.end } return [t] } t.newRange = t.newRange._getTransformedBySplitOperation(e) } return [t] })); Dk(fk, gk, ((t, e) => { if (t.sourcePosition.hasSameParentAs(e.position)) { t.howMany += e.howMany } t.sourcePosition = t.sourcePosition._getTransformedByInsertOperation(e); t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e); return [t] })); Dk(fk, fk, ((t, e, n) => { if (t.sourcePosition.isEqual(e.sourcePosition) && t.targetPosition.isEqual(e.targetPosition)) { if (!n.bWasUndone) { return [new Ak(0)] } else { const n = e.graveyardPosition.path.slice(); n.push(0); t.sourcePosition = new bf(e.graveyardPosition.root, n); t.howMany = 0; return [t] } } if (t.sourcePosition.isEqual(e.sourcePosition) && !t.targetPosition.isEqual(e.targetPosition) && !n.bWasUndone && n.abRelation != "splitAtSource") { const i = t.targetPosition.root.rootName == "$graveyard"; const o = e.targetPosition.root.rootName == "$graveyard"; const r = i && !o; const s = o && !i; const a = s || !r && n.aIsStrong; if (a) { const n = e.targetPosition._getTransformedByMergeOperation(e); const i = t.targetPosition._getTransformedByMergeOperation(e); return [new hk(n, t.howMany, i, 0)] } else { return [new Ak(0)] } } if (t.sourcePosition.hasSameParentAs(e.targetPosition)) { t.howMany += e.howMany } t.sourcePosition = t.sourcePosition._getTransformedByMergeOperation(e); t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e); if (!t.graveyardPosition.isEqual(e.graveyardPosition) || !n.aIsStrong) { t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e) } return [t] })); Dk(fk, hk, ((t, e, n) => { const i = yf._createFromPositionAndShift(e.sourcePosition, e.howMany); if (e.type == "remove" && !n.bWasUndone && !n.forceWeakRemove) { if (t.deletionPosition.hasSameParentAs(e.sourcePosition) && i.containsPosition(t.sourcePosition)) { return [new Ak(0)] } } if (t.sourcePosition.hasSameParentAs(e.targetPosition)) { t.howMany += e.howMany } if (t.sourcePosition.hasSameParentAs(e.sourcePosition)) { t.howMany -= e.howMany } t.sourcePosition = t.sourcePosition._getTransformedByMoveOperation(e); t.targetPosition = t.targetPosition._getTransformedByMoveOperation(e); if (!t.graveyardPosition.isEqual(e.targetPosition)) { t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e) } return [t] })); Dk(fk, mk, ((t, e, n) => { if (e.graveyardPosition) { t.graveyardPosition = t.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1); if (t.deletionPosition.isEqual(e.graveyardPosition)) { t.howMany = e.howMany } } if (t.targetPosition.isEqual(e.splitPosition)) { const i = e.howMany != 0; const o = e.graveyardPosition && t.deletionPosition.isEqual(e.graveyardPosition); if (i || o || n.abRelation == "mergeTargetNotMoved") { t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e); return [t] } } if (t.sourcePosition.isEqual(e.splitPosition)) { if (n.abRelation == "mergeSourceNotMoved") { t.howMany = 0; t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e); return [t] } if (n.abRelation == "mergeSameElement" || t.sourcePosition.offset > 0) { t.sourcePosition = e.moveTargetPosition.clone(); t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e); return [t] } } if (t.sourcePosition.hasSameParentAs(e.splitPosition)) { t.howMany = e.splitPosition.offset } t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e); t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e); return [t] })); Dk(hk, gk, ((t, e) => { const n = yf._createFromPositionAndShift(t.sourcePosition, t.howMany); const i = n._getTransformedByInsertOperation(e, false)[0]; t.sourcePosition = i.start; t.howMany = i.end.offset - i.start.offset; if (!t.targetPosition.isEqual(e.position)) { t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e) } return [t] })); Dk(hk, hk, ((t, e, n) => { const i = yf._createFromPositionAndShift(t.sourcePosition, t.howMany); const o = yf._createFromPositionAndShift(e.sourcePosition, e.howMany); let r = n.aIsStrong; let s = !n.aIsStrong; if (n.abRelation == "insertBefore" || n.baRelation == "insertAfter") { s = true } else if (n.abRelation == "insertAfter" || n.baRelation == "insertBefore") { s = false } let a; if (t.targetPosition.isEqual(e.targetPosition) && s) { a = t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) } else { a = t.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany) } if (Ok(t, e) && Ok(e, t)) { return [e.getReversed()] } const c = i.containsPosition(e.targetPosition); if (c && i.containsRange(o, true)) { i.start = i.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany); i.end = i.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany); return Rk([i], a) } const l = o.containsPosition(t.targetPosition); if (l && o.containsRange(i, true)) { i.start = i.start._getCombined(e.sourcePosition, e.getMovedRangeStart()); i.end = i.end._getCombined(e.sourcePosition, e.getMovedRangeStart()); return Rk([i], a) } const d = _t(t.sourcePosition.getParentPath(), e.sourcePosition.getParentPath()); if (d == "prefix" || d == "extension") { i.start = i.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany); i.end = i.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany); return Rk([i], a) } if (t.type == "remove" && e.type != "remove" && !n.aWasUndone && !n.forceWeakRemove) { r = true } else if (t.type != "remove" && e.type == "remove" && !n.bWasUndone && !n.forceWeakRemove) { r = false } const u = []; const h = i.getDifference(o); for (const t of h) { t.start = t.start._getTransformedByDeletion(e.sourcePosition, e.howMany); t.end = t.end._getTransformedByDeletion(e.sourcePosition, e.howMany); const n = _t(t.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == "same"; const i = t._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, n); u.push(...i) } const g = i.getIntersection(o); if (g !== null && r) { g.start = g.start._getCombined(e.sourcePosition, e.getMovedRangeStart()); g.end = g.end._getCombined(e.sourcePosition, e.getMovedRangeStart()); if (u.length === 0) { u.push(g) } else if (u.length == 1) { if (o.start.isBefore(i.start) || o.start.isEqual(i.start)) { u.unshift(g) } else { u.push(g) } } else { u.splice(1, 0, g) } } if (u.length === 0) { return [new Ak(t.baseVersion)] } return Rk(u, a) })); Dk(hk, mk, ((t, e, n) => { let i = t.targetPosition.clone(); if (!t.targetPosition.isEqual(e.insertionPosition) || !e.graveyardPosition || n.abRelation == "moveTargetAfter") { i = t.targetPosition._getTransformedBySplitOperation(e) } const o = yf._createFromPositionAndShift(t.sourcePosition, t.howMany); if (o.end.isEqual(e.insertionPosition)) { if (!e.graveyardPosition) { t.howMany++ } t.targetPosition = i; return [t] } if (o.start.hasSameParentAs(e.splitPosition) && o.containsPosition(e.splitPosition)) { let t = new yf(e.splitPosition, o.end); t = t._getTransformedBySplitOperation(e); const n = [new yf(o.start, e.splitPosition), t]; return Rk(n, i) } if (t.targetPosition.isEqual(e.splitPosition) && n.abRelation == "insertAtSource") { i = e.moveTargetPosition } if (t.targetPosition.isEqual(e.insertionPosition) && n.abRelation == "insertBetween") { i = t.targetPosition } const r = o._getTransformedBySplitOperation(e); const s = [r]; if (e.graveyardPosition) { const i = o.start.isEqual(e.graveyardPosition) || o.containsPosition(e.graveyardPosition); if (t.howMany > 1 && i && !n.aWasUndone) { s.push(yf._createFromPositionAndShift(e.insertionPosition, 1)) } } return Rk(s, i) })); Dk(hk, fk, ((t, e, n) => { const i = yf._createFromPositionAndShift(t.sourcePosition, t.howMany); if (e.deletionPosition.hasSameParentAs(t.sourcePosition) && i.containsPosition(e.sourcePosition)) { if (t.type == "remove" && !n.forceWeakRemove) { if (!n.aWasUndone) { const n = []; let i = e.graveyardPosition.clone(); let o = e.targetPosition._getTransformedByMergeOperation(e); if (t.howMany > 1) { n.push(new hk(t.sourcePosition, t.howMany - 1, t.targetPosition, 0)); i = i._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1); o = o._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1) } const r = e.deletionPosition._getCombined(t.sourcePosition, t.targetPosition); const s = new hk(i, 1, r, 0); const a = s.getMovedRangeStart().path.slice(); a.push(0); const c = new bf(s.targetPosition.root, a); o = o._getTransformedByMove(i, r, 1); const l = new hk(o, e.howMany, c, 0); n.push(s); n.push(l); return n } } else { if (t.howMany == 1) { if (!n.bWasUndone) { return [new Ak(0)] } else { t.sourcePosition = e.graveyardPosition.clone(); t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e); return [t] } } } } const o = yf._createFromPositionAndShift(t.sourcePosition, t.howMany); const r = o._getTransformedByMergeOperation(e); t.sourcePosition = r.start; t.howMany = r.end.offset - r.start.offset; t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e); return [t] })); Dk(_k, gk, ((t, e) => { t.position = t.position._getTransformedByInsertOperation(e); return [t] })); Dk(_k, fk, ((t, e) => { if (t.position.isEqual(e.deletionPosition)) { t.position = e.graveyardPosition.clone(); t.position.stickiness = "toNext"; return [t] } t.position = t.position._getTransformedByMergeOperation(e); return [t] })); Dk(_k, hk, ((t, e) => { t.position = t.position._getTransformedByMoveOperation(e); return [t] })); Dk(_k, _k, ((t, e, n) => { if (t.position.isEqual(e.position)) { if (n.aIsStrong) { t.oldName = e.newName } else { return [new Ak(0)] } } return [t] })); Dk(_k, mk, ((t, e) => { const n = t.position.path; const i = e.splitPosition.getParentPath(); if (_t(n, i) == "same" && !e.graveyardPosition) { const e = new _k(t.position.getShiftedBy(1), t.oldName, t.newName, 0); return [t, e] } t.position = t.position._getTransformedBySplitOperation(e); return [t] })); Dk(Ck, Ck, ((t, e, n) => { if (t.root === e.root && t.key === e.key) { if (!n.aIsStrong || t.newValue === e.newValue) { return [new Ak(0)] } else { t.oldValue = e.newValue } } return [t] })); Dk(vk, vk, ((t, e, n) => { if (t.rootName === e.rootName && t.isAdd === e.isAdd && !n.bWasUndone) { return [new Ak(0)] } return [t] })); Dk(mk, gk, ((t, e) => { if (t.splitPosition.hasSameParentAs(e.position) && t.splitPosition.offset < e.position.offset) { t.howMany += e.howMany } t.splitPosition = t.splitPosition._getTransformedByInsertOperation(e); t.insertionPosition = t.insertionPosition._getTransformedByInsertOperation(e); return [t] })); Dk(mk, fk, ((t, e, n) => { if (!t.graveyardPosition && !n.bWasUndone && t.splitPosition.hasSameParentAs(e.sourcePosition)) { const n = e.graveyardPosition.path.slice(); n.push(0); const i = new bf(e.graveyardPosition.root, n); const o = mk.getInsertionPosition(new bf(e.graveyardPosition.root, n)); const r = new mk(i, 0, o, null, 0); t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e); t.insertionPosition = mk.getInsertionPosition(t.splitPosition); t.graveyardPosition = r.insertionPosition.clone(); t.graveyardPosition.stickiness = "toNext"; return [r, t] } if (t.splitPosition.hasSameParentAs(e.deletionPosition) && !t.splitPosition.isAfter(e.deletionPosition)) { t.howMany-- } if (t.splitPosition.hasSameParentAs(e.targetPosition)) { t.howMany += e.howMany } t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e); t.insertionPosition = mk.getInsertionPosition(t.splitPosition); if (t.graveyardPosition) { t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e) } return [t] })); Dk(mk, hk, ((t, e, n) => { const i = yf._createFromPositionAndShift(e.sourcePosition, e.howMany); if (t.graveyardPosition) { const o = i.start.isEqual(t.graveyardPosition) || i.containsPosition(t.graveyardPosition); if (!n.bWasUndone && o) { const n = t.splitPosition._getTransformedByMoveOperation(e); const i = t.graveyardPosition._getTransformedByMoveOperation(e); const o = i.path.slice(); o.push(0); const r = new bf(i.root, o); const s = new hk(n, t.howMany, r, 0); return [s] } t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e) } const o = t.splitPosition.isEqual(e.targetPosition); if (o && (n.baRelation == "insertAtSource" || n.abRelation == "splitBefore")) { t.howMany += e.howMany; t.splitPosition = t.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany); t.insertionPosition = mk.getInsertionPosition(t.splitPosition); return [t] } if (o && n.abRelation && n.abRelation.howMany) { const { howMany: e, offset: i } = n.abRelation; t.howMany += e; t.splitPosition = t.splitPosition.getShiftedBy(i); return [t] } if (t.splitPosition.hasSameParentAs(e.sourcePosition) && i.containsPosition(t.splitPosition)) { const n = e.howMany - (t.splitPosition.offset - e.sourcePosition.offset); t.howMany -= n; if (t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset) { t.howMany += e.howMany } t.splitPosition = e.sourcePosition.clone(); t.insertionPosition = mk.getInsertionPosition(t.splitPosition); return [t] } if (!e.sourcePosition.isEqual(e.targetPosition)) { if (t.splitPosition.hasSameParentAs(e.sourcePosition) && t.splitPosition.offset <= e.sourcePosition.offset) { t.howMany -= e.howMany } if (t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset) { t.howMany += e.howMany } } t.splitPosition.stickiness = "toNone"; t.splitPosition = t.splitPosition._getTransformedByMoveOperation(e); t.splitPosition.stickiness = "toNext"; if (t.graveyardPosition) { t.insertionPosition = t.insertionPosition._getTransformedByMoveOperation(e) } else { t.insertionPosition = mk.getInsertionPosition(t.splitPosition) } return [t] })); Dk(mk, mk, ((t, e, n) => { if (t.splitPosition.isEqual(e.splitPosition)) { if (!t.graveyardPosition && !e.graveyardPosition) { return [new Ak(0)] } if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) { return [new Ak(0)] } if (n.abRelation == "splitBefore") { t.howMany = 0; t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e); return [t] } } if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) { const i = t.splitPosition.root.rootName == "$graveyard"; const o = e.splitPosition.root.rootName == "$graveyard"; const r = i && !o; const s = o && !i; const a = s || !r && n.aIsStrong; if (a) { const n = []; if (e.howMany) { n.push(new hk(e.moveTargetPosition, e.howMany, e.splitPosition, 0)) } if (t.howMany) { n.push(new hk(t.splitPosition, t.howMany, t.moveTargetPosition, 0)) } return n } else { return [new Ak(0)] } } if (t.graveyardPosition) { t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e) } if (t.splitPosition.isEqual(e.insertionPosition) && n.abRelation == "splitBefore") { t.howMany++; return [t] } if (e.splitPosition.isEqual(t.insertionPosition) && n.baRelation == "splitBefore") { const n = e.insertionPosition.path.slice(); n.push(0); const i = new bf(e.insertionPosition.root, n); const o = new hk(t.insertionPosition, 1, i, 0); return [t, o] } if (t.splitPosition.hasSameParentAs(e.splitPosition) && t.splitPosition.offset < e.splitPosition.offset) { t.howMany -= e.howMany } t.splitPosition = t.splitPosition._getTransformedBySplitOperation(e); t.insertionPosition = mk.getInsertionPosition(t.splitPosition); return [t] })); function Ok(t, e) { return t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null } function Rk(t, e) { const n = []; for (let i = 0; i < t.length; i++) { const o = t[i]; const r = new hk(o.start, o.end.offset - o.start.offset, e, 0); n.push(r); for (let e = i + 1; e < t.length; e++) { t[e] = t[e]._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)[0] } e = e._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany) } return n } class Vk extends (U(bf)) { constructor(t, e, n = "toNone") { super(t, e, n); if (!this.root.is("rootElement")) { throw new I("model-liveposition-root-not-rootelement", t) } jk.call(this) } detach() { this.stopListening() } toPosition() { return new bf(this.root, this.path.slice(), this.stickiness) } static fromPosition(t, e) { return new this(t.root, t.path.slice(), e ? e : t.stickiness) } } Vk.prototype.is = function (t) { return t === "livePosition" || t === "model:livePosition" || t == "position" || t === "model:position" }; function jk() { this.listenTo(this.root.document.model, "applyOperation", ((t, e) => { const n = e[0]; if (!n.isDocumentOperation) { return } Fk.call(this, n) }), { priority: "low" }) } function Fk(t) { const e = this.getTransformedByOperation(t); if (!this.isEqual(e)) { const t = this.toPosition(); this.path = e.path; this.root = e.root; this.fire("change", t) } } class Hk { constructor(t = {}) { if (typeof t === "string") { t = t === "transparent" ? { isUndoable: false } : {}; M("batch-constructor-deprecated-string-type") } const { isUndoable: e = true, isLocal: n = true, isUndo: i = false, isTyping: o = false } = t; this.operations = []; this.isUndoable = e; this.isLocal = n; this.isUndo = i; this.isTyping = o } get type() { M("batch-type-deprecated"); return "default" } get baseVersion() { for (const t of this.operations) { if (t.baseVersion !== null) { return t.baseVersion } } return null } addOperation(t) { t.batch = this; this.operations.push(t); return t } } class Uk { constructor(t) { this._changesInElement = new Map; this._elementSnapshots = new Map; this._changedMarkers = new Map; this._changedRoots = new Map; this._changeCount = 0; this._cachedChanges = null; this._cachedChangesWithGraveyard = null; this._refreshedItems = new Set; this._markerCollection = t } get isEmpty() { return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0 } bufferOperation(t) { const e = t; switch (e.type) { case "insert": { if (this._isInInsertedElement(e.position.parent)) { return } this._markInsert(e.position.parent, e.position.offset, e.nodes.maxOffset); break } case "addAttribute": case "removeAttribute": case "changeAttribute": { for (const t of e.range.getItems({ shallow: true })) { if (this._isInInsertedElement(t.parent)) { continue } this._markAttribute(t) } break } case "remove": case "move": case "reinsert": { if (e.sourcePosition.isEqual(e.targetPosition) || e.sourcePosition.getShiftedBy(e.howMany).isEqual(e.targetPosition)) { return } const t = this._isInInsertedElement(e.sourcePosition.parent); const n = this._isInInsertedElement(e.targetPosition.parent); if (!t) { this._markRemove(e.sourcePosition.parent, e.sourcePosition.offset, e.howMany) } if (!n) { this._markInsert(e.targetPosition.parent, e.getMovedRangeStart().offset, e.howMany) } break } case "rename": { if (this._isInInsertedElement(e.position.parent)) { return } this._markRemove(e.position.parent, e.position.offset, 1); this._markInsert(e.position.parent, e.position.offset, 1); const t = yf._createFromPositionAndShift(e.position, 1); for (const e of this._markerCollection.getMarkersIntersectingRange(t)) { const t = e.getData(); this.bufferMarkerChange(e.name, t, t) } break } case "split": { const t = e.splitPosition.parent; if (!this._isInInsertedElement(t)) { this._markRemove(t, e.splitPosition.offset, e.howMany) } if (!this._isInInsertedElement(e.insertionPosition.parent)) { this._markInsert(e.insertionPosition.parent, e.insertionPosition.offset, 1) } if (e.graveyardPosition) { this._markRemove(e.graveyardPosition.parent, e.graveyardPosition.offset, 1) } break } case "merge": { const t = e.sourcePosition.parent; if (!this._isInInsertedElement(t.parent)) { this._markRemove(t.parent, t.startOffset, 1) } const n = e.graveyardPosition.parent; this._markInsert(n, e.graveyardPosition.offset, 1); const i = e.targetPosition.parent; if (!this._isInInsertedElement(i)) { this._markInsert(i, e.targetPosition.offset, t.maxOffset) } break } case "detachRoot": case "addRoot": { this._bufferRootStateChange(e.rootName, e.isAdd); break } case "addRootAttribute": case "removeRootAttribute": case "changeRootAttribute": { const t = e.root.rootName; this._bufferRootAttributeChange(t, e.key, e.oldValue, e.newValue); break } }this._cachedChanges = null } bufferMarkerChange(t, e, n) { const i = this._changedMarkers.get(t); if (!i) { this._changedMarkers.set(t, { newMarkerData: n, oldMarkerData: e }) } else { i.newMarkerData = n; if (i.oldMarkerData.range == null && n.range == null) { this._changedMarkers.delete(t) } } } getMarkersToRemove() { const t = []; for (const [e, n] of this._changedMarkers) { if (n.oldMarkerData.range != null) { t.push({ name: e, range: n.oldMarkerData.range }) } } return t } getMarkersToAdd() { const t = []; for (const [e, n] of this._changedMarkers) { if (n.newMarkerData.range != null) { t.push({ name: e, range: n.newMarkerData.range }) } } return t } getChangedMarkers() { return Array.from(this._changedMarkers).map((([t, e]) => ({ name: t, data: { oldRange: e.oldMarkerData.range, newRange: e.newMarkerData.range } }))) } hasDataChanges() { if (this._changesInElement.size > 0) { return true } if (this._changedRoots.size > 0) { return true } for (const { newMarkerData: t, oldMarkerData: e } of this._changedMarkers.values()) { if (t.affectsData !== e.affectsData) { return true } if (t.affectsData) { const n = t.range && !e.range; const i = !t.range && e.range; const o = t.range && e.range && !t.range.isEqual(e.range); if (n || i || o) { return true } } } return false } getChanges(t = {}) { if (this._cachedChanges) { if (t.includeChangesInGraveyard) { return this._cachedChangesWithGraveyard.slice() } else { return this._cachedChanges.slice() } } let e = []; for (const t of this._changesInElement.keys()) { const n = this._changesInElement.get(t).sort(((t, e) => { if (t.offset === e.offset) { if (t.type != e.type) { return t.type == "remove" ? -1 : 1 } return 0 } return t.offset < e.offset ? -1 : 1 })); const i = this._elementSnapshots.get(t); const o = Wk(t.getChildren()); const r = qk(i.length, n); let s = 0; let a = 0; for (const n of r) { if (n === "i") { e.push(this._getInsertDiff(t, s, o[s])); s++ } else if (n === "r") { e.push(this._getRemoveDiff(t, s, i[a])); a++ } else if (n === "a") { const n = o[s].attributes; const r = i[a].attributes; let c; if (o[s].name == "$text") { c = new yf(bf._createAt(t, s), bf._createAt(t, s + 1)) } else { const e = t.offsetToIndex(s); c = new yf(bf._createAt(t, s), bf._createAt(t.getChild(e), 0)) } e.push(...this._getAttributesDiff(c, r, n)); s++; a++ } else { s++; a++ } } } e.sort(((t, e) => { if (t.position.root != e.position.root) { return t.position.root.rootName < e.position.root.rootName ? -1 : 1 } if (t.position.isEqual(e.position)) { return t.changeCount - e.changeCount } return t.position.isBefore(e.position) ? -1 : 1 })); for (let t = 1, n = 0; t < e.length; t++) { const i = e[n]; const o = e[t]; const r = i.type == "remove" && o.type == "remove" && i.name == "$text" && o.name == "$text" && i.position.isEqual(o.position); const s = i.type == "insert" && o.type == "insert" && i.name == "$text" && o.name == "$text" && i.position.parent == o.position.parent && i.position.offset + i.length == o.position.offset; const a = i.type == "attribute" && o.type == "attribute" && i.position.parent == o.position.parent && i.range.isFlat && o.range.isFlat && i.position.offset + i.length == o.position.offset && i.attributeKey == o.attributeKey && i.attributeOldValue == o.attributeOldValue && i.attributeNewValue == o.attributeNewValue; if (r || s || a) { i.length++; if (a) { i.range.end = i.range.end.getShiftedBy(1) } e[t] = null } else { n = t } } e = e.filter((t => t)); for (const t of e) { delete t.changeCount; if (t.type == "attribute") { delete t.position; delete t.length } } this._changeCount = 0; this._cachedChangesWithGraveyard = e; this._cachedChanges = e.filter(Gk); if (t.includeChangesInGraveyard) { return this._cachedChangesWithGraveyard.slice() } else { return this._cachedChanges.slice() } } getChangedRoots() { return Array.from(this._changedRoots.values()).map((t => { const e = { ...t }; if (e.state !== undefined) { delete e.attributes } return e })) } getRefreshedItems() { return new Set(this._refreshedItems) } reset() { this._changesInElement.clear(); this._elementSnapshots.clear(); this._changedMarkers.clear(); this._changedRoots.clear(); this._refreshedItems = new Set; this._cachedChanges = null } _bufferRootStateChange(t, e) { if (!this._changedRoots.has(t)) { this._changedRoots.set(t, { name: t, state: e ? "attached" : "detached" }); return } const n = this._changedRoots.get(t); if (n.state !== undefined) { delete n.state; if (n.attributes === undefined) { this._changedRoots.delete(t) } } else { n.state = e ? "attached" : "detached" } } _bufferRootAttributeChange(t, e, n, i) { const o = this._changedRoots.get(t) || { name: t }; const r = o.attributes || {}; if (r[e]) { const t = r[e]; if (i === t.oldValue) { delete r[e] } else { t.newValue = i } } else { r[e] = { oldValue: n, newValue: i } } if (Object.entries(r).length === 0) { delete o.attributes; if (o.state === undefined) { this._changedRoots.delete(t) } } else { o.attributes = r; this._changedRoots.set(t, o) } } _refreshItem(t) { if (this._isInInsertedElement(t.parent)) { return } this._markRemove(t.parent, t.startOffset, t.offsetSize); this._markInsert(t.parent, t.startOffset, t.offsetSize); this._refreshedItems.add(t); const e = yf._createOn(t); for (const t of this._markerCollection.getMarkersIntersectingRange(e)) { const e = t.getData(); this.bufferMarkerChange(t.name, e, e) } this._cachedChanges = null } _markInsert(t, e, n) { const i = { type: "insert", offset: e, howMany: n, count: this._changeCount++ }; this._markChange(t, i) } _markRemove(t, e, n) { const i = { type: "remove", offset: e, howMany: n, count: this._changeCount++ }; this._markChange(t, i); this._removeAllNestedChanges(t, e, n) } _markAttribute(t) { const e = { type: "attribute", offset: t.startOffset, howMany: t.offsetSize, count: this._changeCount++ }; this._markChange(t.parent, e) } _markChange(t, e) { this._makeSnapshot(t); const n = this._getChangesForElement(t); this._handleChange(e, n); n.push(e); for (let t = 0; t < n.length; t++) { if (n[t].howMany < 1) { n.splice(t, 1); t-- } } } _getChangesForElement(t) { let e; if (this._changesInElement.has(t)) { e = this._changesInElement.get(t) } else { e = []; this._changesInElement.set(t, e) } return e } _makeSnapshot(t) { if (!this._elementSnapshots.has(t)) { this._elementSnapshots.set(t, Wk(t.getChildren())) } } _handleChange(t, e) { t.nodesToHandle = t.howMany; for (const n of e) { const i = t.offset + t.howMany; const o = n.offset + n.howMany; if (t.type == "insert") { if (n.type == "insert") { if (t.offset <= n.offset) { n.offset += t.howMany } else if (t.offset < o) { n.howMany += t.nodesToHandle; t.nodesToHandle = 0 } } if (n.type == "remove") { if (t.offset < n.offset) { n.offset += t.howMany } } if (n.type == "attribute") { if (t.offset <= n.offset) { n.offset += t.howMany } else if (t.offset < o) { const o = n.howMany; n.howMany = t.offset - n.offset; e.unshift({ type: "attribute", offset: i, howMany: o - n.howMany, count: this._changeCount++ }) } } } if (t.type == "remove") { if (n.type == "insert") { if (i <= n.offset) { n.offset -= t.howMany } else if (i <= o) { if (t.offset < n.offset) { const e = i - n.offset; n.offset = t.offset; n.howMany -= e; t.nodesToHandle -= e } else { n.howMany -= t.nodesToHandle; t.nodesToHandle = 0 } } else { if (t.offset <= n.offset) { t.nodesToHandle -= n.howMany; n.howMany = 0 } else if (t.offset < o) { const e = o - t.offset; n.howMany -= e; t.nodesToHandle -= e } } } if (n.type == "remove") { if (i <= n.offset) { n.offset -= t.howMany } else if (t.offset < n.offset) { t.nodesToHandle += n.howMany; n.howMany = 0 } } if (n.type == "attribute") { if (i <= n.offset) { n.offset -= t.howMany } else if (t.offset < n.offset) { const e = i - n.offset; n.offset = t.offset; n.howMany -= e } else if (t.offset < o) { if (i <= o) { const i = n.howMany; n.howMany = t.offset - n.offset; const o = i - n.howMany - t.nodesToHandle; e.unshift({ type: "attribute", offset: t.offset, howMany: o, count: this._changeCount++ }) } else { n.howMany -= o - t.offset } } } } if (t.type == "attribute") { if (n.type == "insert") { if (t.offset < n.offset && i > n.offset) { if (i > o) { const t = { type: "attribute", offset: o, howMany: i - o, count: this._changeCount++ }; this._handleChange(t, e); e.push(t) } t.nodesToHandle = n.offset - t.offset; t.howMany = t.nodesToHandle } else if (t.offset >= n.offset && t.offset < o) { if (i > o) { t.nodesToHandle = i - o; t.offset = o } else { t.nodesToHandle = 0 } } } if (n.type == "remove") { if (t.offset < n.offset && i > n.offset) { const o = { type: "attribute", offset: n.offset, howMany: i - n.offset, count: this._changeCount++ }; this._handleChange(o, e); e.push(o); t.nodesToHandle = n.offset - t.offset; t.howMany = t.nodesToHandle } } if (n.type == "attribute") { if (t.offset >= n.offset && i <= o) { t.nodesToHandle = 0; t.howMany = 0; t.offset = 0 } else if (t.offset <= n.offset && i >= o) { n.howMany = 0 } } } } t.howMany = t.nodesToHandle; delete t.nodesToHandle } _getInsertDiff(t, e, n) { return { type: "insert", position: bf._createAt(t, e), name: n.name, attributes: new Map(n.attributes), length: 1, changeCount: this._changeCount++ } } _getRemoveDiff(t, e, n) { return { type: "remove", position: bf._createAt(t, e), name: n.name, attributes: new Map(n.attributes), length: 1, changeCount: this._changeCount++ } } _getAttributesDiff(t, e, n) { const i = []; n = new Map(n); for (const [o, r] of e) { const e = n.has(o) ? n.get(o) : null; if (e !== r) { i.push({ type: "attribute", position: t.start, range: t.clone(), length: 1, attributeKey: o, attributeOldValue: r, attributeNewValue: e, changeCount: this._changeCount++ }) } n.delete(o) } for (const [e, o] of n) { i.push({ type: "attribute", position: t.start, range: t.clone(), length: 1, attributeKey: e, attributeOldValue: null, attributeNewValue: o, changeCount: this._changeCount++ }) } return i } _isInInsertedElement(t) { const e = t.parent; if (!e) { return false } const n = this._changesInElement.get(e); const i = t.startOffset; if (n) { for (const t of n) { if (t.type == "insert" && i >= t.offset && i < t.offset + t.howMany) { return true } } } return this._isInInsertedElement(e) } _removeAllNestedChanges(t, e, n) { const i = new yf(bf._createAt(t, e), bf._createAt(t, e + n)); for (const t of i.getItems({ shallow: true })) { if (t.is("element")) { this._elementSnapshots.delete(t); this._changesInElement.delete(t); this._removeAllNestedChanges(t, 0, t.maxOffset) } } } } function Wk(t) { const e = []; for (const n of t) { if (n.is("$text")) { for (let t = 0; t < n.data.length; t++) { e.push({ name: "$text", attributes: new Map(n.getAttributes()) }) } } else { e.push({ name: n.name, attributes: new Map(n.getAttributes()) }) } } return e } function qk(t, e) { const n = []; let i = 0; let o = 0; for (const t of e) { if (t.offset > i) { for (let e = 0; e < t.offset - i; e++) { n.push("e") } o += t.offset - i } if (t.type == "insert") { for (let e = 0; e < t.howMany; e++) { n.push("i") } i = t.offset + t.howMany } else if (t.type == "remove") { for (let e = 0; e < t.howMany; e++) { n.push("r") } i = t.offset; o += t.howMany } else { n.push(..."a".repeat(t.howMany).split("")); i = t.offset + t.howMany; o += t.howMany } } if (o < t) { for (let e = 0; e < t - o - i; e++) { n.push("e") } } return n } function Gk(t) { const e = "position" in t && t.position.root.rootName == "$graveyard"; const n = "range" in t && t.range.root.rootName == "$graveyard"; return !e && !n } class $k { constructor() { this._operations = []; this._undoPairs = new Map; this._undoneOperations = new Set; this._baseVersionToOperationIndex = new Map; this._version = 0; this._gaps = new Map } get version() { return this._version } set version(t) { if (this._operations.length && t > this._version + 1) { this._gaps.set(this._version, t) } this._version = t } get lastOperation() { return this._operations[this._operations.length - 1] } addOperation(t) { if (t.baseVersion !== this.version) { throw new I("model-document-history-addoperation-incorrect-version", this, { operation: t, historyVersion: this.version }) } this._operations.push(t); this._version++; this._baseVersionToOperationIndex.set(t.baseVersion, this._operations.length - 1) } getOperations(t, e = this.version) { if (!this._operations.length) { return [] } const n = this._operations[0]; if (t === undefined) { t = n.baseVersion } let i = e - 1; for (const [e, n] of this._gaps) { if (t > e && t < n) { t = n } if (i > e && i < n) { i = e - 1 } } if (i < n.baseVersion || t > this.lastOperation.baseVersion) { return [] } let o = this._baseVersionToOperationIndex.get(t); if (o === undefined) { o = 0 } let r = this._baseVersionToOperationIndex.get(i); if (r === undefined) { r = this._operations.length - 1 } return this._operations.slice(o, r + 1) } getOperation(t) { const e = this._baseVersionToOperationIndex.get(t); if (e === undefined) { return } return this._operations[e] } setOperationAsUndone(t, e) { this._undoPairs.set(e, t); this._undoneOperations.add(t) } isUndoingOperation(t) { return this._undoPairs.has(t) } isUndoneOperation(t) { return this._undoneOperations.has(t) } getUndoneOperation(t) { return this._undoPairs.get(t) } reset() { this._version = 0; this._undoPairs = new Map; this._operations = []; this._undoneOperations = new Set; this._gaps = new Map; this._baseVersionToOperationIndex = new Map } } class Kk extends gf { constructor(t, e, n = "main") { super(e); this._isAttached = true; this._document = t; this.rootName = n } get document() { return this._document } isAttached() { return this._isAttached } toJSON() { return this.rootName } } Kk.prototype.is = function (t, e) { if (!e) { return t === "rootElement" || t === "model:rootElement" || t === "element" || t === "model:element" || t === "node" || t === "model:node" } return e === this.name && (t === "rootElement" || t === "model:rootElement" || t === "element" || t === "model:element") }; const Yk = "$graveyard"; class Qk extends (U()) { constructor(t) { super(); this.model = t; this.history = new $k; this.selection = new qf(this); this.roots = new il({ idProperty: "rootName" }); this.differ = new Uk(t.markers); this._postFixers = new Set; this._hasSelectionChangedFromTheLastChangeBlock = false; this.createRoot("$root", Yk); this.listenTo(t, "applyOperation", ((t, e) => { const n = e[0]; if (n.isDocumentOperation) { this.differ.bufferOperation(n) } }), { priority: "high" }); this.listenTo(t, "applyOperation", ((t, e) => { const n = e[0]; if (n.isDocumentOperation) { this.history.addOperation(n) } }), { priority: "low" }); this.listenTo(this.selection, "change", (() => { this._hasSelectionChangedFromTheLastChangeBlock = true })); this.listenTo(t.markers, "update", ((t, e, n, i, o) => { const r = { ...e.getData(), range: i }; this.differ.bufferMarkerChange(e.name, o, r); if (n === null) { e.on("change", ((t, n) => { const i = e.getData(); this.differ.bufferMarkerChange(e.name, { ...i, range: n }, i) })) } })); this.registerPostFixer((t => { let e = false; for (const n of this.roots) { if (!n.isAttached() && !n.isEmpty) { t.remove(t.createRangeIn(n)); e = true } } for (const n of this.model.markers) { if (!n.getRange().root.isAttached()) { t.removeMarker(n); e = true } } return e })) } get version() { return this.history.version } set version(t) { this.history.version = t } get graveyard() { return this.getRoot(Yk) } createRoot(t = "$root", e = "main") { if (this.roots.get(e)) { throw new I("model-document-createroot-name-exists", this, { name: e }) } const n = new Kk(this, t, e); this.roots.add(n); return n } destroy() { this.selection.destroy(); this.stopListening() } getRoot(t = "main") { return this.roots.get(t) } getRootNames(t = false) { return Array.from(this.roots).filter((e => e.rootName != Yk && (t || e.isAttached()))).map((t => t.rootName)) } registerPostFixer(t) { this._postFixers.add(t) } toJSON() { const t = ql(this); t.selection = "[engine.model.DocumentSelection]"; t.model = "[engine.model.Model]"; return t } _handleChangeBlock(t) { if (this._hasDocumentChangedFromTheLastChangeBlock()) { this._callPostFixers(t); this.selection.refresh(); if (this.differ.hasDataChanges()) { this.fire("change:data", t.batch) } else { this.fire("change", t.batch) } this.selection.refresh(); this.differ.reset() } this._hasSelectionChangedFromTheLastChangeBlock = false } _hasDocumentChangedFromTheLastChangeBlock() { return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock } _getDefaultRoot() { for (const t of this.roots) { if (t !== this.graveyard) { return t } } return this.graveyard } _getDefaultRange() { const t = this._getDefaultRoot(); const e = this.model; const n = e.schema; const i = e.createPositionFromPath(t, [0]); const o = n.getNearestSelectionRange(i); return o || e.createRange(i) } _validateSelectionRange(t) { return Zk(t.start) && Zk(t.end) } _callPostFixers(t) { let e = false; do { for (const n of this._postFixers) { this.selection.refresh(); e = n(t); if (e) { break } } } while (e) } } function Zk(t) { const e = t.textNode; if (e) { const n = e.data; const i = t.offset - e.startOffset; return !ml(n, i) && !fl(n, i) } return true } class Jk extends (U()) { constructor() { super(...arguments); this._markers = new Map } [Symbol.iterator]() { return this._markers.values() } has(t) { const e = t instanceof Xk ? t.name : t; return this._markers.has(e) } get(t) { return this._markers.get(t) || null } _set(t, e, n = false, i = false) { const o = t instanceof Xk ? t.name : t; if (o.includes(",")) { throw new I("markercollection-incorrect-marker-name", this) } const r = this._markers.get(o); if (r) { const t = r.getData(); const s = r.getRange(); let a = false; if (!s.isEqual(e)) { r._attachLiveRange(jf.fromRange(e)); a = true } if (n != r.managedUsingOperations) { r._managedUsingOperations = n; a = true } if (typeof i === "boolean" && i != r.affectsData) { r._affectsData = i; a = true } if (a) { this.fire(`update:${o}`, r, s, e, t) } return r } const s = jf.fromRange(e); const a = new Xk(o, s, n, i); this._markers.set(o, a); this.fire(`update:${o}`, a, null, e, { ...a.getData(), range: null }); return a } _remove(t) { const e = t instanceof Xk ? t.name : t; const n = this._markers.get(e); if (n) { this._markers.delete(e); this.fire(`update:${e}`, n, n.getRange(), null, n.getData()); this._destroyMarker(n); return true } return false } _refresh(t) { const e = t instanceof Xk ? t.name : t; const n = this._markers.get(e); if (!n) { throw new I("markercollection-refresh-marker-not-exists", this) } const i = n.getRange(); this.fire(`update:${e}`, n, i, i, n.getData()) } *getMarkersAtPosition(t) { for (const e of this) { if (e.getRange().containsPosition(t)) { yield e } } } *getMarkersIntersectingRange(t) { for (const e of this) { if (e.getRange().getIntersection(t) !== null) { yield e } } } destroy() { for (const t of this._markers.values()) { this._destroyMarker(t) } this._markers = null; this.stopListening() } *getMarkersGroup(t) { for (const e of this._markers.values()) { if (e.name.startsWith(t + ":")) { yield e } } } _destroyMarker(t) { t.stopListening(); t._detachLiveRange() } } class Xk extends (U(cf)) { constructor(t, e, n, i) { super(); this.name = t; this._liveRange = this._attachLiveRange(e); this._managedUsingOperations = n; this._affectsData = i } get managedUsingOperations() { if (!this._liveRange) { throw new I("marker-destroyed", this) } return this._managedUsingOperations } get affectsData() { if (!this._liveRange) { throw new I("marker-destroyed", this) } return this._affectsData } getData() { return { range: this.getRange(), affectsData: this.affectsData, managedUsingOperations: this.managedUsingOperations } } getStart() { if (!this._liveRange) { throw new I("marker-destroyed", this) } return this._liveRange.start.clone() } getEnd() { if (!this._liveRange) { throw new I("marker-destroyed", this) } return this._liveRange.end.clone() } getRange() { if (!this._liveRange) { throw new I("marker-destroyed", this) } return this._liveRange.toRange() } _attachLiveRange(t) { if (this._liveRange) { this._detachLiveRange() } t.delegate("change:range").to(this); t.delegate("change:content").to(this); this._liveRange = t; return t } _detachLiveRange() { this._liveRange.stopDelegating("change:range", this); this._liveRange.stopDelegating("change:content", this); this._liveRange.detach(); this._liveRange = null } } Xk.prototype.is = function (t) { return t === "marker" || t === "model:marker" }; class tw extends ik { constructor(t, e) { super(null); this.sourcePosition = t.clone(); this.howMany = e } get type() { return "detach" } toJSON() { const t = super.toJSON(); t.sourcePosition = this.sourcePosition.toJSON(); return t } _validate() { if (this.sourcePosition.root.document) { throw new I("detach-operation-on-document-node", this) } } _execute() { rk(yf._createFromPositionAndShift(this.sourcePosition, this.howMany)) } static get className() { return "DetachOperation" } } class ew extends cf { constructor(t) { super(); this.markers = new Map; this._children = new df; if (t) { this._insertChild(0, t) } } [Symbol.iterator]() { return this.getChildren() } get childCount() { return this._children.length } get maxOffset() { return this._children.maxOffset } get isEmpty() { return this.childCount === 0 } get nextSibling() { return null } get previousSibling() { return null } get root() { return this } get parent() { return null } get document() { return null } isAttached() { return false } getAncestors() { return [] } getChild(t) { return this._children.getNode(t) } getChildren() { return this._children[Symbol.iterator]() } getChildIndex(t) { return this._children.getNodeIndex(t) } getChildStartOffset(t) { return this._children.getNodeStartOffset(t) } getPath() { return [] } getNodeByPath(t) { let e = this; for (const n of t) { e = e.getChild(e.offsetToIndex(n)) } return e } offsetToIndex(t) { return this._children.offsetToIndex(t) } toJSON() { const t = []; for (const e of this._children) { t.push(e.toJSON()) } return t } static fromJSON(t) { const e = []; for (const n of t) { if (n.name) { e.push(gf.fromJSON(n)) } else { e.push(uf.fromJSON(n)) } } return new ew(e) } _appendChild(t) { this._insertChild(this.childCount, t) } _insertChild(t, e) { const n = nw(e); for (const t of n) { if (t.parent !== null) { t._remove() } t.parent = this } this._children._insertNodes(t, n) } _removeChildren(t, e = 1) { const n = this._children._removeNodes(t, e); for (const t of n) { t.parent = null } return n } } ew.prototype.is = function (t) { return t === "documentFragment" || t === "model:documentFragment" }; function nw(t) { if (typeof t == "string") { return [new uf(t)] } if (!Ct(t)) { t = [t] } return Array.from(t).map((t => { if (typeof t == "string") { return new uf(t) } if (t instanceof hf) { return new uf(t.data, t.getAttributes()) } return t })) } class iw { constructor(t, e) { this.model = t; this.batch = e } createText(t, e) { return new uf(t, e) } createElement(t, e) { return new gf(t, e) } createDocumentFragment() { return new ew } cloneElement(t, e = true) { return t._clone(e) } insert(t, e, n = 0) { this._assertWriterUsedCorrectly(); if (t instanceof uf && t.data == "") { return } const i = bf._createAt(e, n); if (t.parent) { if (cw(t.root, i.root)) { this.move(yf._createOn(t), i); return } else { if (t.root.document) { throw new I("model-writer-insert-forbidden-move", this) } else { this.remove(t) } } } const o = i.root.document ? i.root.document.version : null; const r = new gk(i, t, o); if (t instanceof uf) { r.shouldReceiveAttributes = true } this.batch.addOperation(r); this.model.applyOperation(r); if (t instanceof ew) { for (const [e, n] of t.markers) { const t = bf._createAt(n.root, 0); const o = new yf(n.start._getCombined(t, i), n.end._getCombined(t, i)); const r = { range: o, usingOperation: true, affectsData: true }; if (this.model.markers.has(e)) { this.updateMarker(e, r) } else { this.addMarker(e, r) } } } } insertText(t, e, n, i) { if (e instanceof ew || e instanceof gf || e instanceof bf) { this.insert(this.createText(t), e, n) } else { this.insert(this.createText(t, e), n, i) } } insertElement(t, e, n, i) { if (e instanceof ew || e instanceof gf || e instanceof bf) { this.insert(this.createElement(t), e, n) } else { this.insert(this.createElement(t, e), n, i) } } append(t, e) { this.insert(t, e, "end") } appendText(t, e, n) { if (e instanceof ew || e instanceof gf) { this.insert(this.createText(t), e, "end") } else { this.insert(this.createText(t, e), n, "end") } } appendElement(t, e, n) { if (e instanceof ew || e instanceof gf) { this.insert(this.createElement(t), e, "end") } else { this.insert(this.createElement(t, e), n, "end") } } setAttribute(t, e, n) { this._assertWriterUsedCorrectly(); if (n instanceof yf) { const i = n.getMinimalFlatRanges(); for (const n of i) { ow(this, t, e, n) } } else { rw(this, t, e, n) } } setAttributes(t, e) { for (const [n, i] of cl(t)) { this.setAttribute(n, i, e) } } removeAttribute(t, e) { this._assertWriterUsedCorrectly(); if (e instanceof yf) { const n = e.getMinimalFlatRanges(); for (const e of n) { ow(this, t, null, e) } } else { rw(this, t, null, e) } } clearAttributes(t) { this._assertWriterUsedCorrectly(); const e = t => { for (const e of t.getAttributeKeys()) { this.removeAttribute(e, t) } }; if (!(t instanceof yf)) { e(t) } else { for (const n of t.getItems()) { e(n) } } } move(t, e, n) { this._assertWriterUsedCorrectly(); if (!(t instanceof yf)) { throw new I("writer-move-invalid-range", this) } if (!t.isFlat) { throw new I("writer-move-range-not-flat", this) } const i = bf._createAt(e, n); if (i.isEqual(t.start)) { return } this._addOperationForAffectedMarkers("move", t); if (!cw(t.root, i.root)) { throw new I("writer-move-different-document", this) } const o = t.root.document ? t.root.document.version : null; const r = new hk(t.start, t.end.offset - t.start.offset, i, o); this.batch.addOperation(r); this.model.applyOperation(r) } remove(t) { this._assertWriterUsedCorrectly(); const e = t instanceof yf ? t : yf._createOn(t); const n = e.getMinimalFlatRanges().reverse(); for (const t of n) { this._addOperationForAffectedMarkers("move", t); aw(t.start, t.end.offset - t.start.offset, this.batch, this.model) } } merge(t) { this._assertWriterUsedCorrectly(); const e = t.nodeBefore; const n = t.nodeAfter; this._addOperationForAffectedMarkers("merge", t); if (!(e instanceof gf)) { throw new I("writer-merge-no-element-before", this) } if (!(n instanceof gf)) { throw new I("writer-merge-no-element-after", this) } if (!t.root.document) { this._mergeDetached(t) } else { this._merge(t) } } createPositionFromPath(t, e, n) { return this.model.createPositionFromPath(t, e, n) } createPositionAt(t, e) { return this.model.createPositionAt(t, e) } createPositionAfter(t) { return this.model.createPositionAfter(t) } createPositionBefore(t) { return this.model.createPositionBefore(t) } createRange(t, e) { return this.model.createRange(t, e) } createRangeIn(t) { return this.model.createRangeIn(t) } createRangeOn(t) { return this.model.createRangeOn(t) } createSelection(...t) { return this.model.createSelection(...t) } _mergeDetached(t) { const e = t.nodeBefore; const n = t.nodeAfter; this.move(yf._createIn(n), bf._createAt(e, "end")); this.remove(n) } _merge(t) { const e = bf._createAt(t.nodeBefore, "end"); const n = bf._createAt(t.nodeAfter, 0); const i = t.root.document.graveyard; const o = new bf(i, [0]); const r = t.root.document.version; const s = new fk(n, t.nodeAfter.maxOffset, e, o, r); this.batch.addOperation(s); this.model.applyOperation(s) } rename(t, e) { this._assertWriterUsedCorrectly(); if (!(t instanceof gf)) { throw new I("writer-rename-not-element-instance", this) } const n = t.root.document ? t.root.document.version : null; const i = new _k(bf._createBefore(t), t.name, e, n); this.batch.addOperation(i); this.model.applyOperation(i) } split(t, e) { this._assertWriterUsedCorrectly(); let n = t.parent; if (!n.parent) { throw new I("writer-split-element-no-parent", this) } if (!e) { e = n.parent } if (!t.parent.getAncestors({ includeSelf: true }).includes(e)) { throw new I("writer-split-invalid-limit-element", this) } let i; let o; do { const e = n.root.document ? n.root.document.version : null; const r = n.maxOffset - t.offset; const s = mk.getInsertionPosition(t); const a = new mk(t, r, s, null, e); this.batch.addOperation(a); this.model.applyOperation(a); if (!i && !o) { i = n; o = t.parent.nextSibling } t = this.createPositionAfter(t.parent); n = t.parent } while (n !== e); return { position: t, range: new yf(bf._createAt(i, "end"), bf._createAt(o, 0)) } } wrap(t, e) { this._assertWriterUsedCorrectly(); if (!t.isFlat) { throw new I("writer-wrap-range-not-flat", this) } const n = e instanceof gf ? e : new gf(e); if (n.childCount > 0) { throw new I("writer-wrap-element-not-empty", this) } if (n.parent !== null) { throw new I("writer-wrap-element-attached", this) } this.insert(n, t.start); const i = new yf(t.start.getShiftedBy(1), t.end.getShiftedBy(1)); this.move(i, bf._createAt(n, 0)) } unwrap(t) { this._assertWriterUsedCorrectly(); if (t.parent === null) { throw new I("writer-unwrap-element-no-parent", this) } this.move(yf._createIn(t), this.createPositionAfter(t)); this.remove(t) } addMarker(t, e) { this._assertWriterUsedCorrectly(); if (!e || typeof e.usingOperation != "boolean") { throw new I("writer-addmarker-no-usingoperation", this) } const n = e.usingOperation; const i = e.range; const o = e.affectsData === undefined ? false : e.affectsData; if (this.model.markers.has(t)) { throw new I("writer-addmarker-marker-exists", this) } if (!i) { throw new I("writer-addmarker-no-range", this) } if (!n) { return this.model.markers._set(t, i, n, o) } sw(this, t, null, i, o); return this.model.markers.get(t) } updateMarker(t, e) { this._assertWriterUsedCorrectly(); const n = typeof t == "string" ? t : t.name; const i = this.model.markers.get(n); if (!i) { throw new I("writer-updatemarker-marker-not-exists", this) } if (!e) { M("writer-updatemarker-reconvert-using-editingcontroller", { markerName: n }); this.model.markers._refresh(i); return } const o = typeof e.usingOperation == "boolean"; const r = typeof e.affectsData == "boolean"; const s = r ? e.affectsData : i.affectsData; if (!o && !e.range && !r) { throw new I("writer-updatemarker-wrong-options", this) } const a = i.getRange(); const c = e.range ? e.range : a; if (o && e.usingOperation !== i.managedUsingOperations) { if (e.usingOperation) { sw(this, n, null, c, s) } else { sw(this, n, a, null, s); this.model.markers._set(n, c, undefined, s) } return } if (i.managedUsingOperations) { sw(this, n, a, c, s) } else { this.model.markers._set(n, c, undefined, s) } } removeMarker(t) { this._assertWriterUsedCorrectly(); const e = typeof t == "string" ? t : t.name; if (!this.model.markers.has(e)) { throw new I("writer-removemarker-no-marker", this) } const n = this.model.markers.get(e); if (!n.managedUsingOperations) { this.model.markers._remove(e); return } const i = n.getRange(); sw(this, e, i, null, n.affectsData) } addRoot(t, e = "$root") { this._assertWriterUsedCorrectly(); const n = this.model.document.getRoot(t); if (n && n.isAttached()) { throw new I("writer-addroot-root-exists", this) } const i = this.model.document; const o = new vk(t, e, true, i, i.version); this.batch.addOperation(o); this.model.applyOperation(o); return this.model.document.getRoot(t) } detachRoot(t) { this._assertWriterUsedCorrectly(); const e = typeof t == "string" ? this.model.document.getRoot(t) : t; if (!e || !e.isAttached()) { throw new I("writer-detachroot-no-root", this) } for (const t of this.model.markers) { if (t.getRange().root === e) { this.removeMarker(t) } } for (const t of e.getAttributeKeys()) { this.removeAttribute(t, e) } this.remove(this.createRangeIn(e)); const n = this.model.document; const i = new vk(e.rootName, e.name, false, n, n.version); this.batch.addOperation(i); this.model.applyOperation(i) } setSelection(...t) { this._assertWriterUsedCorrectly(); this.model.document.selection._setTo(...t) } setSelectionFocus(t, e) { this._assertWriterUsedCorrectly(); this.model.document.selection._setFocus(t, e) } setSelectionAttribute(t, e) { this._assertWriterUsedCorrectly(); if (typeof t === "string") { this._setSelectionAttribute(t, e) } else { for (const [e, n] of cl(t)) { this._setSelectionAttribute(e, n) } } } removeSelectionAttribute(t) { this._assertWriterUsedCorrectly(); if (typeof t === "string") { this._removeSelectionAttribute(t) } else { for (const e of t) { this._removeSelectionAttribute(e) } } } overrideSelectionGravity() { return this.model.document.selection._overrideGravity() } restoreSelectionGravity(t) { this.model.document.selection._restoreGravity(t) } _setSelectionAttribute(t, e) { const n = this.model.document.selection; if (n.isCollapsed && n.anchor.parent.isEmpty) { const i = qf._getStoreAttributeKey(t); this.setAttribute(i, e, n.anchor.parent) } n._setAttribute(t, e) } _removeSelectionAttribute(t) { const e = this.model.document.selection; if (e.isCollapsed && e.anchor.parent.isEmpty) { const n = qf._getStoreAttributeKey(t); this.removeAttribute(n, e.anchor.parent) } e._removeAttribute(t) } _assertWriterUsedCorrectly() { if (this.model._currentWriter !== this) { throw new I("writer-incorrect-use", this) } } _addOperationForAffectedMarkers(t, e) { for (const n of this.model.markers) { if (!n.managedUsingOperations) { continue } const i = n.getRange(); let o = false; if (t === "move") { const t = e; o = t.containsPosition(i.start) || t.start.isEqual(i.start) || t.containsPosition(i.end) || t.end.isEqual(i.end) } else { const t = e; const n = t.nodeBefore; const r = t.nodeAfter; const s = i.start.parent == n && i.start.isAtEnd; const a = i.end.parent == r && i.end.offset == 0; const c = i.end.nodeAfter == r; const l = i.start.nodeAfter == r; o = s || a || c || l } if (o) { this.updateMarker(n.name, { range: i }) } } } } function ow(t, e, n, i) { const o = t.model; const r = o.document; let s = i.start; let a; let c; let l; for (const t of i.getWalker({ shallow: true })) { l = t.item.getAttribute(e); if (a && c != l) { if (c != n) { d() } s = a } a = t.nextPosition; c = l } if (a instanceof bf && a != s && c != n) { d() } function d() { const i = new yf(s, a); const l = i.root.document ? r.version : null; const d = new wk(i, e, c, n, l); t.batch.addOperation(d); o.applyOperation(d) } } function rw(t, e, n, i) { const o = t.model; const r = o.document; const s = i.getAttribute(e); let a, c; if (s != n) { const l = i.root === i; if (l) { const t = i.document ? r.version : null; c = new Ck(i, e, s, n, t) } else { a = new yf(bf._createBefore(i), t.createPositionAfter(i)); const o = a.root.document ? r.version : null; c = new wk(a, e, s, n, o) } t.batch.addOperation(c); o.applyOperation(c) } } function sw(t, e, n, i, o) { const r = t.model; const s = r.document; const a = new pk(e, n, i, r.markers, !!o, s.version); t.batch.addOperation(a); r.applyOperation(a) } function aw(t, e, n, i) { let o; if (t.root.document) { const n = i.document; const r = new bf(n.graveyard, [0]); o = new hk(t, e, r, n.version) } else { o = new tw(t, e) } n.addOperation(o); i.applyOperation(o) } function cw(t, e) { if (t === e) { return true } if (t instanceof Kk && e instanceof Kk) { return true } return false } function lw(t, e, n = {}) { if (e.isCollapsed) { return } const i = e.getFirstRange(); if (i.root.rootName == "$graveyard") { return } const o = t.schema; t.change((t => { if (!n.doNotResetEntireContent && Cw(o, e)) { _w(t, e); return } const r = {}; if (!n.doNotAutoparagraph) { const t = e.getSelectedElement(); if (t) { Object.assign(r, o.getAttributesWithProperty(t, "copyOnReplace", true)) } } const [s, a] = dw(i); if (!s.isTouching(a)) { t.remove(t.createRange(s, a)) } if (!n.leaveUnmerged) { hw(t, s, a); o.removeDisallowedAttributes(s.parent.getChildren(), t) } vw(t, e, s); if (!n.doNotAutoparagraph && kw(o, s)) { Aw(t, s, e, r) } s.detach(); a.detach() })) } function dw(t) { const e = t.root.document.model; const n = t.start; let i = t.end; if (e.hasContent(t, { ignoreMarkers: true })) { const n = uw(i); if (n && i.isTouching(e.createPositionAt(n, 0))) { const n = e.createSelection(t); e.modifySelection(n, { direction: "backward" }); const o = n.getLastPosition(); const r = e.createRange(o, i); if (!e.hasContent(r, { ignoreMarkers: true })) { i = o } } } return [Vk.fromPosition(n, "toPrevious"), Vk.fromPosition(i, "toNext")] } function uw(t) { const e = t.parent; const n = e.root.document.model.schema; const i = e.getAncestors({ parentFirst: true, includeSelf: true }); for (const t of i) { if (n.isLimit(t)) { return null } if (n.isBlock(t)) { return t } } } function hw(t, e, n) { const i = t.model; if (!pw(t.model.schema, e, n)) { return } const [o, r] = bw(e, n); if (!o || !r) { return } if (!i.hasContent(o, { ignoreMarkers: true }) && i.hasContent(r, { ignoreMarkers: true })) { mw(t, e, n, o.parent) } else { gw(t, e, n, o.parent) } } function gw(t, e, n, i) { const o = e.parent; const r = n.parent; if (o == i || r == i) { return } e = t.createPositionAfter(o); n = t.createPositionBefore(r); if (!n.isEqual(e)) { t.insert(r, e) } t.merge(e); while (n.parent.isEmpty) { const e = n.parent; n = t.createPositionBefore(e); t.remove(e) } if (!pw(t.model.schema, e, n)) { return } gw(t, e, n, i) } function mw(t, e, n, i) { const o = e.parent; const r = n.parent; if (o == i || r == i) { return } e = t.createPositionAfter(o); n = t.createPositionBefore(r); if (!n.isEqual(e)) { t.insert(o, n) } while (e.parent.isEmpty) { const n = e.parent; e = t.createPositionBefore(n); t.remove(n) } n = t.createPositionBefore(r); fw(t, n); if (!pw(t.model.schema, e, n)) { return } mw(t, e, n, i) } function fw(t, e) { const n = e.nodeBefore; const i = e.nodeAfter; if (n.name != i.name) { t.rename(n, i.name) } t.clearAttributes(n); t.setAttributes(Object.fromEntries(i.getAttributes()), n); t.merge(e) } function pw(t, e, n) { const i = e.parent; const o = n.parent; if (i == o) { return false } if (t.isLimit(i) || t.isLimit(o)) { return false } return ww(e, n, t) } function bw(t, e) { const n = t.getAncestors(); const i = e.getAncestors(); let o = 0; while (n[o] && n[o] == i[o]) { o++ } return [n[o], i[o]] } function kw(t, e) { const n = t.checkChild(e, "$text"); const i = t.checkChild(e, "paragraph"); return !n && i } function ww(t, e, n) { const i = new yf(t, e); for (const t of i.getWalker()) { if (n.isLimit(t.item)) { return false } } return true } function Aw(t, e, n, i = {}) { const o = t.createElement("paragraph"); t.model.schema.setAllowedAttributes(o, i, t); t.insert(o, e); vw(t, n, t.createPositionAt(o, 0)) } function _w(t, e) { const n = t.model.schema.getLimitElement(e); t.remove(t.createRangeIn(n)); Aw(t, t.createPositionAt(n, 0), e) } function Cw(t, e) { const n = t.getLimitElement(e); if (!e.containsEntireContent(n)) { return false } const i = e.getFirstRange(); if (i.start.parent == i.end.parent) { return false } return t.checkChild(n, "paragraph") } function vw(t, e, n) { if (e instanceof qf) { t.setSelection(n) } else { e.setTo(n) } } function yw(t, e) { return t.change((t => { const n = t.createDocumentFragment(); const i = e.getFirstRange(); if (!i || i.isCollapsed) { return n } const o = i.start.root; const r = i.start.getCommonPath(i.end); const s = o.getNodeByPath(r); let a; if (i.start.parent == i.end.parent) { a = i } else { a = t.createRange(t.createPositionAt(s, i.start.path[r.length]), t.createPositionAt(s, i.end.path[r.length] + 1)) } const c = a.end.offset - a.start.offset; for (const e of a.getItems({ shallow: true })) { if (e.is("$textProxy")) { t.appendText(e.data, e.getAttributes(), n) } else { t.append(t.cloneElement(e, true), n) } } if (a != i) { const e = i._getTransformedByMove(a.start, t.createPositionAt(n, 0), c)[0]; const o = t.createRange(t.createPositionAt(n, 0), e.start); const r = t.createRange(e.end, t.createPositionAt(n, "end")); xw(r, t); xw(o, t) } return n })) } function xw(t, e) { const n = []; Array.from(t.getItems({ direction: "backward" })).map((t => e.createRangeOn(t))).filter((e => { const n = (e.start.isAfter(t.start) || e.start.isEqual(t.start)) && (e.end.isBefore(t.end) || e.end.isEqual(t.end)); return n })).forEach((t => { n.push(t.start.parent); e.remove(t) })); n.forEach((t => { let n = t; while (n.parent && n.isEmpty) { const t = e.createRangeOn(n); n = n.parent; e.remove(t) } })) } function Ew(t, e, n) { return t.change((i => { const o = n ? n : t.document.selection; if (!o.isCollapsed) { t.deleteContent(o, { doNotAutoparagraph: true }) } const r = new Dw(t, i, o.anchor); const s = []; let a; if (e.is("documentFragment")) { if (e.markers.size) { const t = []; for (const [n, i] of e.markers) { const { start: e, end: o } = i; const r = e.isEqual(o); t.push({ position: e, name: n, isCollapsed: r }, { position: o, name: n, isCollapsed: r }) } t.sort((({ position: t }, { position: e }) => t.isBefore(e) ? 1 : -1)); for (const { position: n, name: o, isCollapsed: r } of t) { let t = null; let a = null; const c = n.parent === e && n.isAtStart; const l = n.parent === e && n.isAtEnd; if (!c && !l) { t = i.createElement("$marker"); i.insert(t, n) } else if (r) { a = c ? "start" : "end" } s.push({ name: o, element: t, collapsed: a }) } } a = e.getChildren() } else { a = [e] } r.handleNodes(a); let c = r.getSelectionRange(); if (e.is("documentFragment") && s.length) { const t = c ? jf.fromRange(c) : null; const e = {}; for (let t = s.length - 1; t >= 0; t--) { const { name: n, element: o, collapsed: a } = s[t]; const c = !e[n]; if (c) { e[n] = [] } if (o) { const t = i.createPositionAt(o, "before"); e[n].push(t); i.remove(o) } else { const t = r.getAffectedRange(); if (!t) { if (a) { e[n].push(r.position) } continue } if (a) { e[n].push(t[a]) } else { e[n].push(c ? t.start : t.end) } } } for (const [t, [n, o]] of Object.entries(e)) { if (n && o && n.root === o.root) { i.addMarker(t, { usingOperation: true, affectsData: true, range: new yf(n, o) }) } } if (t) { c = t.toRange(); t.detach() } } if (c) { if (o instanceof qf) { i.setSelection(c) } else { o.setTo(c) } } else { } const l = r.getAffectedRange() || t.createRange(o.anchor); r.destroy(); return l })) } class Dw { constructor(t, e, n) { this._firstNode = null; this._lastNode = null; this._lastAutoParagraph = null; this._filterAttributesOf = []; this._affectedStart = null; this._affectedEnd = null; this._nodeToSelect = null; this.model = t; this.writer = e; this.position = n; this.canMergeWith = new Set([this.position.parent]); this.schema = t.schema; this._documentFragment = e.createDocumentFragment(); this._documentFragmentPosition = e.createPositionAt(this._documentFragment, 0) } handleNodes(t) { for (const e of Array.from(t)) { this._handleNode(e) } this._insertPartialFragment(); if (this._lastAutoParagraph) { this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph) } this._mergeOnRight(); this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer); this._filterAttributesOf = [] } _updateLastNodeFromAutoParagraph(t) { const e = this.writer.createPositionAfter(this._lastNode); const n = this.writer.createPositionAfter(t); if (n.isAfter(e)) { this._lastNode = t; if (this.position.parent != t || !this.position.isAtEnd) { throw new I("insertcontent-invalid-insertion-position", this) } this.position = n; this._setAffectedBoundaries(this.position) } } getSelectionRange() { if (this._nodeToSelect) { return yf._createOn(this._nodeToSelect) } return this.model.schema.getNearestSelectionRange(this.position) } getAffectedRange() { if (!this._affectedStart) { return null } return new yf(this._affectedStart, this._affectedEnd) } destroy() { if (this._affectedStart) { this._affectedStart.detach() } if (this._affectedEnd) { this._affectedEnd.detach() } } _handleNode(t) { if (this.schema.isObject(t)) { this._handleObject(t); return } let e = this._checkAndAutoParagraphToAllowedPosition(t); if (!e) { e = this._checkAndSplitToAllowedPosition(t); if (!e) { this._handleDisallowedNode(t); return } } this._appendToFragment(t); if (!this._firstNode) { this._firstNode = t } this._lastNode = t } _insertPartialFragment() { if (this._documentFragment.isEmpty) { return } const t = Vk.fromPosition(this.position, "toNext"); this._setAffectedBoundaries(this.position); if (this._documentFragment.getChild(0) == this._firstNode) { this.writer.insert(this._firstNode, this.position); this._mergeOnLeft(); this.position = t.toPosition() } if (!this._documentFragment.isEmpty) { this.writer.insert(this._documentFragment, this.position) } this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0); this.position = t.toPosition(); t.detach() } _handleObject(t) { if (this._checkAndSplitToAllowedPosition(t)) { this._appendToFragment(t) } else { this._tryAutoparagraphing(t) } } _handleDisallowedNode(t) { if (t.is("element")) { this.handleNodes(t.getChildren()) } else { this._tryAutoparagraphing(t) } } _appendToFragment(t) { if (!this.schema.checkChild(this.position, t)) { throw new I("insertcontent-wrong-position", this, { node: t, position: this.position }) } this.writer.insert(t, this._documentFragmentPosition); this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(t.offsetSize); if (this.schema.isObject(t) && !this.schema.checkChild(this.position, "$text")) { this._nodeToSelect = t } else { this._nodeToSelect = null } this._filterAttributesOf.push(t) } _setAffectedBoundaries(t) { if (!this._affectedStart) { this._affectedStart = Vk.fromPosition(t, "toPrevious") } if (!this._affectedEnd || this._affectedEnd.isBefore(t)) { if (this._affectedEnd) { this._affectedEnd.detach() } this._affectedEnd = Vk.fromPosition(t, "toNext") } } _mergeOnLeft() { const t = this._firstNode; if (!(t instanceof gf)) { return } if (!this._canMergeLeft(t)) { return } const e = Vk._createBefore(t); e.stickiness = "toNext"; const n = Vk.fromPosition(this.position, "toNext"); if (this._affectedStart.isEqual(e)) { this._affectedStart.detach(); this._affectedStart = Vk._createAt(e.nodeBefore, "end", "toPrevious") } if (this._firstNode === this._lastNode) { this._firstNode = e.nodeBefore; this._lastNode = e.nodeBefore } this.writer.merge(e); if (e.isEqual(this._affectedEnd) && this._firstNode === this._lastNode) { this._affectedEnd.detach(); this._affectedEnd = Vk._createAt(e.nodeBefore, "end", "toNext") } this.position = n.toPosition(); n.detach(); this._filterAttributesOf.push(this.position.parent); e.detach() } _mergeOnRight() { const t = this._lastNode; if (!(t instanceof gf)) { return } if (!this._canMergeRight(t)) { return } const e = Vk._createAfter(t); e.stickiness = "toNext"; if (!this.position.isEqual(e)) { throw new I("insertcontent-invalid-insertion-position", this) } this.position = bf._createAt(e.nodeBefore, "end"); const n = Vk.fromPosition(this.position, "toPrevious"); if (this._affectedEnd.isEqual(e)) { this._affectedEnd.detach(); this._affectedEnd = Vk._createAt(e.nodeBefore, "end", "toNext") } if (this._firstNode === this._lastNode) { this._firstNode = e.nodeBefore; this._lastNode = e.nodeBefore } this.writer.merge(e); if (e.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode) { this._affectedStart.detach(); this._affectedStart = Vk._createAt(e.nodeBefore, 0, "toPrevious") } this.position = n.toPosition(); n.detach(); this._filterAttributesOf.push(this.position.parent); e.detach() } _canMergeLeft(t) { const e = t.previousSibling; return e instanceof gf && this.canMergeWith.has(e) && this.model.schema.checkMerge(e, t) } _canMergeRight(t) { const e = t.nextSibling; return e instanceof gf && this.canMergeWith.has(e) && this.model.schema.checkMerge(t, e) } _tryAutoparagraphing(t) { const e = this.writer.createElement("paragraph"); if (this._getAllowedIn(this.position.parent, e) && this.schema.checkChild(e, t)) { e._appendChild(t); this._handleNode(e) } } _checkAndAutoParagraphToAllowedPosition(t) { if (this.schema.checkChild(this.position.parent, t)) { return true } if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", t)) { return false } this._insertPartialFragment(); const e = this.writer.createElement("paragraph"); this.writer.insert(e, this.position); this._setAffectedBoundaries(this.position); this._lastAutoParagraph = e; this.position = this.writer.createPositionAt(e, 0); return true } _checkAndSplitToAllowedPosition(t) { const e = this._getAllowedIn(this.position.parent, t); if (!e) { return false } if (e != this.position.parent) { this._insertPartialFragment() } while (e != this.position.parent) { if (this.position.isAtStart) { const t = this.position.parent; this.position = this.writer.createPositionBefore(t); if (t.isEmpty && t.parent === e) { this.writer.remove(t) } } else if (this.position.isAtEnd) { this.position = this.writer.createPositionAfter(this.position.parent) } else { const t = this.writer.createPositionAfter(this.position.parent); this._setAffectedBoundaries(this.position); this.writer.split(this.position); this.position = t; this.canMergeWith.add(this.position.nodeAfter) } } return true } _getAllowedIn(t, e) { if (this.schema.checkChild(t, e)) { return t } if (this.schema.isLimit(t)) { return null } return this._getAllowedIn(t.parent, e) } } function Sw(t, e, n = "auto") { const i = t.getSelectedElement(); if (i && e.schema.isObject(i) && !e.schema.isInline(i)) { if (n == "before" || n == "after") { return e.createRange(e.createPositionAt(i, n)) } return e.createRangeOn(i) } const o = ol(t.getSelectedBlocks()); if (!o) { return e.createRange(t.focus) } if (o.isEmpty) { return e.createRange(e.createPositionAt(o, 0)) } const r = e.createPositionAfter(o); if (t.focus.isTouching(r)) { return e.createRange(r) } return e.createRange(e.createPositionBefore(o)) } function Tw(t, e, n, i = {}) { if (!t.schema.isObject(e)) { throw new I("insertobject-element-not-an-object", t, { object: e }) } const o = n ? n : t.document.selection; let r = o; if (i.findOptimalPosition && t.schema.isBlock(e)) { r = t.createSelection(Sw(o, t, i.findOptimalPosition)) } const s = ol(o.getSelectedBlocks()); const a = {}; if (s) { Object.assign(a, t.schema.getAttributesWithProperty(s, "copyOnReplace", true)) } return t.change((n => { if (!r.isCollapsed) { t.deleteContent(r, { doNotAutoparagraph: true }) } let o = e; const s = r.anchor.parent; if (!t.schema.checkChild(s, e) && t.schema.checkChild(s, "paragraph") && t.schema.checkChild("paragraph", e)) { o = n.createElement("paragraph"); n.insert(e, o) } t.schema.setAllowedAttributes(o, a, n); const c = t.insertContent(o, r); if (c.isCollapsed) { return c } if (i.setSelection) { Iw(n, e, i.setSelection, a) } return c })) } function Iw(t, e, n, i) { const o = t.model; if (n == "on") { t.setSelection(e, "on"); return } if (n != "after") { throw new I("insertobject-invalid-place-parameter-value", o) } let r = e.nextSibling; if (o.schema.isInline(e)) { t.setSelection(e, "after"); return } const s = r && o.schema.checkChild(r, "$text"); if (!s && o.schema.checkChild(e.parent, "paragraph")) { r = t.createElement("paragraph"); o.schema.setAllowedAttributes(r, i, t); o.insertContent(r, t.createPositionAfter(e)) } if (r) { t.setSelection(r, 0) } } const Mw = ' ,.?!:;"-()'; function Bw(t, e, n = {}) { const i = t.schema; const o = n.direction != "backward"; const r = n.unit ? n.unit : "character"; const s = !!n.treatEmojiAsSingleUnit; const a = e.focus; const c = new ff({ boundaries: Pw(a, o), singleCharacters: true, direction: o ? "forward" : "backward" }); const l = { walker: c, schema: i, isForward: o, unit: r, treatEmojiAsSingleUnit: s }; let d; while (d = c.next()) { if (d.done) { return } const n = Lw(l, d.value); if (n) { if (e instanceof qf) { t.change((t => { t.setSelectionFocus(n) })) } else { e.setFocus(n) } return } } } function Lw(t, e) { const { isForward: n, walker: i, unit: o, schema: r, treatEmojiAsSingleUnit: s } = t; const { type: a, item: c, nextPosition: l } = e; if (a == "text") { if (t.unit === "word") { return zw(i, n) } return Nw(i, o, s) } if (a == (n ? "elementStart" : "elementEnd")) { if (r.isSelectable(c)) { return bf._createAt(c, n ? "after" : "before") } if (r.checkChild(l, "$text")) { return l } } else { if (r.isLimit(c)) { i.skip((() => true)); return } if (r.checkChild(l, "$text")) { return l } } } function Nw(t, e, n) { const i = t.position.textNode; if (i) { const o = i.data; let r = t.position.offset - i.startOffset; while (ml(o, r) || e == "character" && fl(o, r) || n && bl(o, r)) { t.next(); r = t.position.offset - i.startOffset } } return t.position } function zw(t, e) { let n = t.position.textNode; if (!n) { n = e ? t.position.nodeAfter : t.position.nodeBefore } while (n && n.is("$text")) { const i = t.position.offset - n.startOffset; if (Rw(n, i, e)) { n = e ? t.position.nodeAfter : t.position.nodeBefore } else if (Ow(n.data, i, e)) { break } else { t.next() } } return t.position } function Pw(t, e) { const n = t.root; const i = bf._createAt(n, e ? "end" : 0); if (e) { return new yf(t, i) } else { return new yf(i, t) } } function Ow(t, e, n) { const i = e + (n ? 0 : -1); return Mw.includes(t.charAt(i)) } function Rw(t, e, n) { return e === (n ? t.offsetSize : 0) } class Vw extends (lt()) { constructor() { super(); this.markers = new Jk; this.document = new Qk(this); this.schema = new Db; this._pendingChanges = []; this._currentWriter = null;["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((t => this.decorate(t))); this.on("applyOperation", ((t, e) => { const n = e[0]; n._validate() }), { priority: "highest" }); this.schema.register("$root", { isLimit: true }); this.schema.register("$container", { allowIn: ["$root", "$container"] }); this.schema.register("$block", { allowIn: ["$root", "$container"], isBlock: true }); this.schema.register("$blockObject", { allowWhere: "$block", isBlock: true, isObject: true }); this.schema.register("$inlineObject", { allowWhere: "$text", allowAttributesOf: "$text", isInline: true, isObject: true }); this.schema.register("$text", { allowIn: "$block", isInline: true, isContent: true }); this.schema.register("$clipboardHolder", { allowContentOf: "$root", allowChildren: "$text", isLimit: true }); this.schema.register("$documentFragment", { allowContentOf: "$root", allowChildren: "$text", isLimit: true }); this.schema.register("$marker"); this.schema.addChildCheck(((t, e) => { if (e.name === "$marker") { return true } })); gb(this); this.document.registerPostFixer(Wp); this.on("insertContent", ((t, [e, n]) => { t.return = Ew(this, e, n) })); this.on("insertObject", ((t, [e, n, i]) => { t.return = Tw(this, e, n, i) })) } change(t) { try { if (this._pendingChanges.length === 0) { this._pendingChanges.push({ batch: new Hk, callback: t }); return this._runPendingChanges()[0] } else { return t(this._currentWriter) } } catch (t) { I.rethrowUnexpectedError(t, this) } } enqueueChange(t, e) { try { if (!t) { t = new Hk } else if (typeof t === "function") { e = t; t = new Hk } else if (!(t instanceof Hk)) { t = new Hk(t) } this._pendingChanges.push({ batch: t, callback: e }); if (this._pendingChanges.length == 1) { this._runPendingChanges() } } catch (t) { I.rethrowUnexpectedError(t, this) } } applyOperation(t) { t._execute() } insertContent(t, e, n, ...i) { const o = jw(e, n); return this.fire("insertContent", [t, o, n, ...i]) } insertObject(t, e, n, i, ...o) { const r = jw(e, n); return this.fire("insertObject", [t, r, i, i, ...o]) } deleteContent(t, e) { lw(this, t, e) } modifySelection(t, e) { Bw(this, t, e) } getSelectedContent(t) { return yw(this, t) } hasContent(t, e = {}) { const n = t instanceof yf ? t : yf._createIn(t); if (n.isCollapsed) { return false } const { ignoreWhitespaces: i = false, ignoreMarkers: o = false } = e; if (!o) { for (const t of this.markers.getMarkersIntersectingRange(n)) { if (t.affectsData) { return true } } } for (const t of n.getItems()) { if (this.schema.isContent(t)) { if (t.is("$textProxy")) { if (!i) { return true } else if (t.data.search(/\S/) !== -1) { return true } } else { return true } } } return false } createPositionFromPath(t, e, n) { return new bf(t, e, n) } createPositionAt(t, e) { return bf._createAt(t, e) } createPositionAfter(t) { return bf._createAfter(t) } createPositionBefore(t) { return bf._createBefore(t) } createRange(t, e) { return new yf(t, e) } createRangeIn(t) { return yf._createIn(t) } createRangeOn(t) { return yf._createOn(t) } createSelection(...t) { return new Bf(...t) } createBatch(t) { return new Hk(t) } createOperationFromJSON(t) { return xk.fromJSON(t, this.document) } destroy() { this.document.destroy(); this.stopListening() } _runPendingChanges() { const t = []; this.fire("_beforeChanges"); try { while (this._pendingChanges.length) { const e = this._pendingChanges[0].batch; this._currentWriter = new iw(this, e); const n = this._pendingChanges[0].callback(this._currentWriter); t.push(n); this.document._handleChangeBlock(this._currentWriter); this._pendingChanges.shift(); this._currentWriter = null } } finally { this._pendingChanges.length = 0; this._currentWriter = null; this.fire("_afterChanges") } return t } } function jw(t, e) { if (!t) { return } if (t instanceof Bf || t instanceof qf) { return t } if (t instanceof lf) { return new Bf(t, e) } return new Bf(t) } class Fw extends Sg { constructor() { super(...arguments); this.domEventType = "click" } onDomEvent(t) { this.fire(t.type, t) } } class Hw extends Sg { constructor() { super(...arguments); this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"] } onDomEvent(t) { this.fire(t.type, t) } } class Uw { constructor(t) { this.document = t } createDocumentFragment(t) { return new Th(this.document, t) } createElement(t, e, n) { return new $u(this.document, t, e, n) } createText(t) { return new $l(this.document, t) } clone(t, e = false) { return t._clone(e) } appendChild(t, e) { return e._appendChild(t) } insertChild(t, e, n) { return n._insertChild(t, e) } removeChildren(t, e, n) { return n._removeChildren(t, e) } remove(t) { const e = t.parent; if (e) { return this.removeChildren(e.getChildIndex(t), 1, e) } return [] } replace(t, e) { const n = t.parent; if (n) { const i = n.getChildIndex(t); this.removeChildren(i, 1, n); this.insertChild(i, e, n); return true } return false } unwrapElement(t) { const e = t.parent; if (e) { const n = e.getChildIndex(t); this.remove(t); this.insertChild(n, t.getChildren(), e) } } rename(t, e) { const n = new $u(this.document, t, e.getAttributes(), e.getChildren()); return this.replace(e, n) ? n : null } setAttribute(t, e, n) { n._setAttribute(t, e) } removeAttribute(t, e) { e._removeAttribute(t) } addClass(t, e) { e._addClass(t) } removeClass(t, e) { e._removeClass(t) } setStyle(t, e, n) { if (de(t) && n === undefined) { e._setStyle(t) } else { n._setStyle(t, e) } } removeStyle(t, e) { e._removeStyle(t) } setCustomProperty(t, e, n) { n._setCustomProperty(t, e) } removeCustomProperty(t, e) { return e._removeCustomProperty(t) } createPositionAt(t, e) { return ih._createAt(t, e) } createPositionAfter(t) { return ih._createAfter(t) } createPositionBefore(t) { return ih._createBefore(t) } createRange(t, e) { return new oh(t, e) } createRangeOn(t) { return oh._createOn(t) } createRangeIn(t) { return oh._createIn(t) } createSelection(...t) { return new sh(...t) } } const Ww = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i; const qw = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i; const Gw = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i; const $w = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i; const Kw = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i; const Yw = new Set(["black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange", "aliceblue", "antiquewhite", "aquamarine", "azure", "beige", "bisque", "blanchedalmond", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "gainsboro", "ghostwhite", "gold", "goldenrod", "greenyellow", "grey", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "limegreen", "linen", "magenta", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "oldlace", "olivedrab", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "thistle", "tomato", "turquoise", "violet", "wheat", "whitesmoke", "yellowgreen", "activeborder", "activecaption", "appworkspace", "background", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "captiontext", "graytext", "highlight", "highlighttext", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infobackground", "infotext", "menu", "menutext", "scrollbar", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "window", "windowframe", "windowtext", "rebeccapurple", "currentcolor", "transparent"]); function Qw(t) { if (t.startsWith("#")) { return Ww.test(t) } if (t.startsWith("rgb")) { return qw.test(t) || Gw.test(t) } if (t.startsWith("hsl")) { return $w.test(t) || Kw.test(t) } return Yw.has(t.toLowerCase()) } const Zw = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"]; function Jw(t) { return Zw.includes(t) } const Xw = /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/; function tA(t) { return Xw.test(t) } const eA = /^[+-]?[0-9]*([.][0-9]+)?%$/; function nA(t) { return eA.test(t) } const iA = ["repeat-x", "repeat-y", "repeat", "space", "round", "no-repeat"]; function oA(t) { return iA.includes(t) } const rA = ["center", "top", "bottom", "left", "right"]; function sA(t) { return rA.includes(t) } const aA = ["fixed", "scroll", "local"]; function cA(t) { return aA.includes(t) } const lA = /^url\(/; function dA(t) { return lA.test(t) } function uA(t = "") { if (t === "") { return { top: undefined, right: undefined, bottom: undefined, left: undefined } } const e = fA(t); const n = e[0]; const i = e[2] || n; const o = e[1] || n; const r = e[3] || o; return { top: n, bottom: i, right: o, left: r } } function hA(t) { return e => { const { top: n, right: i, bottom: o, left: r } = e; const s = []; if (![n, i, r, o].every((t => !!t))) { if (n) { s.push([t + "-top", n]) } if (i) { s.push([t + "-right", i]) } if (o) { s.push([t + "-bottom", o]) } if (r) { s.push([t + "-left", r]) } } else { s.push([t, gA(e)]) } return s } } function gA({ top: t, right: e, bottom: n, left: i }) { const o = []; if (i !== e) { o.push(t, e, n, i) } else if (n !== t) { o.push(t, e, n) } else if (e !== t) { o.push(t, e) } else { o.push(t) } return o.join(" ") } function mA(t) { return e => ({ path: t, value: uA(e) }) } function fA(t) { return t.replace(/, /g, ",").split(" ").map((t => t.replace(/,/g, ", "))) } function pA(t) { t.setNormalizer("background", bA()); t.setNormalizer("background-color", kA()); t.setReducer("background", wA()); t.setStyleRelation("background", ["background-color"]) } function bA() { return t => { const e = {}; const n = fA(t); for (const t of n) { if (oA(t)) { e.repeat = e.repeat || []; e.repeat.push(t) } else if (sA(t)) { e.position = e.position || []; e.position.push(t) } else if (cA(t)) { e.attachment = t } else if (Qw(t)) { e.color = t } else if (dA(t)) { e.image = t } } return { path: "background", value: e } } } function kA() { return t => ({ path: "background.color", value: t }) } function wA() { return t => { const e = []; e.push(["background-color", t.color]); return e } } function AA(t) { t.setNormalizer("border", _A()); t.setNormalizer("border-top", CA("top")); t.setNormalizer("border-right", CA("right")); t.setNormalizer("border-bottom", CA("bottom")); t.setNormalizer("border-left", CA("left")); t.setNormalizer("border-color", vA("color")); t.setNormalizer("border-width", vA("width")); t.setNormalizer("border-style", vA("style")); t.setNormalizer("border-top-color", xA("color", "top")); t.setNormalizer("border-top-style", xA("style", "top")); t.setNormalizer("border-top-width", xA("width", "top")); t.setNormalizer("border-right-color", xA("color", "right")); t.setNormalizer("border-right-style", xA("style", "right")); t.setNormalizer("border-right-width", xA("width", "right")); t.setNormalizer("border-bottom-color", xA("color", "bottom")); t.setNormalizer("border-bottom-style", xA("style", "bottom")); t.setNormalizer("border-bottom-width", xA("width", "bottom")); t.setNormalizer("border-left-color", xA("color", "left")); t.setNormalizer("border-left-style", xA("style", "left")); t.setNormalizer("border-left-width", xA("width", "left")); t.setExtractor("border-top", EA("top")); t.setExtractor("border-right", EA("right")); t.setExtractor("border-bottom", EA("bottom")); t.setExtractor("border-left", EA("left")); t.setExtractor("border-top-color", "border.color.top"); t.setExtractor("border-right-color", "border.color.right"); t.setExtractor("border-bottom-color", "border.color.bottom"); t.setExtractor("border-left-color", "border.color.left"); t.setExtractor("border-top-width", "border.width.top"); t.setExtractor("border-right-width", "border.width.right"); t.setExtractor("border-bottom-width", "border.width.bottom"); t.setExtractor("border-left-width", "border.width.left"); t.setExtractor("border-top-style", "border.style.top"); t.setExtractor("border-right-style", "border.style.right"); t.setExtractor("border-bottom-style", "border.style.bottom"); t.setExtractor("border-left-style", "border.style.left"); t.setReducer("border-color", hA("border-color")); t.setReducer("border-style", hA("border-style")); t.setReducer("border-width", hA("border-width")); t.setReducer("border-top", IA("top")); t.setReducer("border-right", IA("right")); t.setReducer("border-bottom", IA("bottom")); t.setReducer("border-left", IA("left")); t.setReducer("border", TA()); t.setStyleRelation("border", ["border-color", "border-style", "border-width", "border-top", "border-right", "border-bottom", "border-left", "border-top-color", "border-right-color", "border-bottom-color", "border-left-color", "border-top-style", "border-right-style", "border-bottom-style", "border-left-style", "border-top-width", "border-right-width", "border-bottom-width", "border-left-width"]); t.setStyleRelation("border-color", ["border-top-color", "border-right-color", "border-bottom-color", "border-left-color"]); t.setStyleRelation("border-style", ["border-top-style", "border-right-style", "border-bottom-style", "border-left-style"]); t.setStyleRelation("border-width", ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"]); t.setStyleRelation("border-top", ["border-top-color", "border-top-style", "border-top-width"]); t.setStyleRelation("border-right", ["border-right-color", "border-right-style", "border-right-width"]); t.setStyleRelation("border-bottom", ["border-bottom-color", "border-bottom-style", "border-bottom-width"]); t.setStyleRelation("border-left", ["border-left-color", "border-left-style", "border-left-width"]) } function _A() { return t => { const { color: e, style: n, width: i } = SA(t); return { path: "border", value: { color: uA(e), style: uA(n), width: uA(i) } } } } function CA(t) { return e => { const { color: n, style: i, width: o } = SA(e); const r = {}; if (n !== undefined) { r.color = { [t]: n } } if (i !== undefined) { r.style = { [t]: i } } if (o !== undefined) { r.width = { [t]: o } } return { path: "border", value: r } } } function vA(t) { return e => ({ path: "border", value: yA(e, t) }) } function yA(t, e) { return { [e]: uA(t) } } function xA(t, e) { return n => ({ path: "border", value: { [t]: { [e]: n } } }) } function EA(t) { return (e, n) => { if (n.border) { return DA(n.border, t) } } } function DA(t, e) { const n = {}; if (t.width && t.width[e]) { n.width = t.width[e] } if (t.style && t.style[e]) { n.style = t.style[e] } if (t.color && t.color[e]) { n.color = t.color[e] } return n } function SA(t) { const e = {}; const n = fA(t); for (const t of n) { if (tA(t) || /thin|medium|thick/.test(t)) { e.width = t } else if (Jw(t)) { e.style = t } else { e.color = t } } return e } function TA() { return e => { const n = DA(e, "top"); const i = DA(e, "right"); const o = DA(e, "bottom"); const r = DA(e, "left"); const s = [n, i, o, r]; const a = { width: t(s, "width"), style: t(s, "style"), color: t(s, "color") }; const c = MA(a, "all"); if (c.length) { return c } const l = Object.entries(a).reduce(((t, [e, n]) => { if (n) { t.push([`border-${e}`, n]); s.forEach((t => delete t[e])) } return t }), []); return [...l, ...MA(n, "top"), ...MA(i, "right"), ...MA(o, "bottom"), ...MA(r, "left")] }; function t(t, e) { return t.map((t => t[e])).reduce(((t, e) => t == e ? t : null)) } } function IA(t) { return e => MA(e, t) } function MA(t, e) { const n = []; if (t && t.width) { n.push("width") } if (t && t.style) { n.push("style") } if (t && t.color) { n.push("color") } if (n.length == 3) { const i = n.map((e => t[e])).join(" "); return [e == "all" ? ["border", i] : [`border-${e}`, i]] } if (e == "all") { return [] } return n.map((n => [`border-${e}-${n}`, t[n]])) } function BA(t) { t.setNormalizer("margin", mA("margin")); t.setNormalizer("margin-top", (t => ({ path: "margin.top", value: t }))); t.setNormalizer("margin-right", (t => ({ path: "margin.right", value: t }))); t.setNormalizer("margin-bottom", (t => ({ path: "margin.bottom", value: t }))); t.setNormalizer("margin-left", (t => ({ path: "margin.left", value: t }))); t.setReducer("margin", hA("margin")); t.setStyleRelation("margin", ["margin-top", "margin-right", "margin-bottom", "margin-left"]) } function LA(t) { t.setNormalizer("padding", mA("padding")); t.setNormalizer("padding-top", (t => ({ path: "padding.top", value: t }))); t.setNormalizer("padding-right", (t => ({ path: "padding.right", value: t }))); t.setNormalizer("padding-bottom", (t => ({ path: "padding.bottom", value: t }))); t.setNormalizer("padding-left", (t => ({ path: "padding.left", value: t }))); t.setReducer("padding", hA("padding")); t.setStyleRelation("padding", ["padding-top", "padding-right", "padding-bottom", "padding-left"]) } class NA { constructor() { this._commands = new Map } add(t, e) { this._commands.set(t, e) } get(t) { return this._commands.get(t) } execute(t, ...e) { const n = this.get(t); if (!n) { throw new I("commandcollection-command-not-found", this, { commandName: t }) } return n.execute(...e) } *names() { yield* this._commands.keys() } *commands() { yield* this._commands.values() } [Symbol.iterator]() { return this._commands[Symbol.iterator]() } destroy() { for (const t of this.commands()) { t.destroy() } } } class zA extends sl { constructor(t) { super(); this.editor = t } set(t, e, n = {}) { if (typeof e == "string") { const t = e; e = (e, n) => { this.editor.execute(t); n() } } super.set(t, e, n) } } class PA extends (lt()) { constructor(t = {}) { super(); const e = this.constructor; const n = t.language || e.defaultConfig && e.defaultConfig.language; this._context = t.context || new xl({ language: n }); this._context._addEditor(this, !t.context); const i = Array.from(e.builtinPlugins || []); this.config = new ja(t, e.defaultConfig); this.config.define("plugins", i); this.config.define(this._context._getEditorConfig()); this.plugins = new yl(this, i, this._context.plugins); this.locale = this._context.locale; this.t = this.locale.t; this._readOnlyLocks = new Set; this.commands = new NA; this.set("state", "initializing"); this.once("ready", (() => this.state = "ready"), { priority: "high" }); this.once("destroy", (() => this.state = "destroyed"), { priority: "high" }); this.model = new Vw; const o = new Uu; this.data = new Jb(this.model, o); this.editing = new Cb(this.model, o); this.editing.view.document.bind("isReadOnly").to(this); this.conversion = new tk([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher); this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher); this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher); this.keystrokes = new zA(this); this.keystrokes.listenTo(this.editing.view.document) } get isReadOnly() { return this._readOnlyLocks.size > 0 } set isReadOnly(t) { throw new I("editor-isreadonly-has-no-setter") } enableReadOnlyMode(t) { if (typeof t !== "string" && typeof t !== "symbol") { throw new I("editor-read-only-lock-id-invalid", null, { lockId: t }) } if (this._readOnlyLocks.has(t)) { return } this._readOnlyLocks.add(t); if (this._readOnlyLocks.size === 1) { this.fire("change:isReadOnly", "isReadOnly", true, false) } } disableReadOnlyMode(t) { if (typeof t !== "string" && typeof t !== "symbol") { throw new I("editor-read-only-lock-id-invalid", null, { lockId: t }) } if (!this._readOnlyLocks.has(t)) { return } this._readOnlyLocks.delete(t); if (this._readOnlyLocks.size === 0) { this.fire("change:isReadOnly", "isReadOnly", false, true) } } initPlugins() { const t = this.config; const e = t.get("plugins"); const n = t.get("removePlugins") || []; const i = t.get("extraPlugins") || []; const o = t.get("substitutePlugins") || []; return this.plugins.init(e.concat(i), n, o) } destroy() { let t = Promise.resolve(); if (this.state == "initializing") { t = new Promise((t => this.once("ready", t))) } return t.then((() => { this.fire("destroy"); this.stopListening(); this.commands.destroy() })).then((() => this.plugins.destroy())).then((() => { this.model.destroy(); this.data.destroy(); this.editing.destroy(); this.keystrokes.destroy() })).then((() => this._context._removeEditor(this))) } execute(t, ...e) { try { return this.commands.execute(t, ...e) } catch (t) { I.rethrowUnexpectedError(t, this) } } focus() { this.editing.view.focus() } static create(...t) { throw new Error("This is an abstract method.") } } function OA(t) { if (!He(t.updateSourceElement)) { throw new I("attachtoform-missing-elementapi-interface", t) } const e = t.sourceElement; if (RA(e) && e.form) { let n; const i = e.form; const o = () => t.updateSourceElement(); if (He(i.submit)) { n = i.submit; i.submit = () => { o(); n.apply(i) } } i.addEventListener("submit", o); t.on("destroy", (() => { i.removeEventListener("submit", o); if (n) { i.submit = n } })) } } function RA(t) { return !!t && t.tagName.toLowerCase() === "textarea" } function VA(t) { class e extends t { setData(t) { this.data.set(t) } getData(t) { return this.data.get(t) } } return e } { const t = VA(Object); VA.setData = t.prototype.setData; VA.getData = t.prototype.getData } function jA(t) { class e extends t { updateSourceElement(t = this.data.get()) { if (!this.sourceElement) { throw new I("editor-missing-sourceelement", this) } const e = this.config.get("updateSourceElementOnDestroy"); const n = this.sourceElement instanceof HTMLTextAreaElement; if (!e && !n) { lc(this.sourceElement, ""); return } lc(this.sourceElement, t) } } return e } jA.updateSourceElement = jA(Object).prototype.updateSourceElement; function FA(t, e) { if (e.ckeditorInstance) { throw new I("editor-source-element-already-used", t) } e.ckeditorInstance = t; t.once("destroy", (() => { delete e.ckeditorInstance })) } class HA extends El { static get pluginName() { return "PendingActions" } init() { this.set("hasAny", false); this._actions = new il({ idProperty: "_id" }); this._actions.delegate("add", "remove").to(this) } add(t) { if (typeof t !== "string") { throw new I("pendingactions-add-invalid-message", this) } const e = new (lt()); e.set("message", t); this._actions.add(e); this.hasAny = true; return e } remove(t) { this._actions.remove(t); this.hasAny = !!this._actions.length } get first() { return this._actions.get(0) } [Symbol.iterator]() { return this._actions[Symbol.iterator]() } } const UA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>'; const WA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>'; const qA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>'; const GA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>'; const $A = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>'; const KA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>'; const YA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>'; const QA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>'; const ZA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>'; const JA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>'; const XA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>'; const t_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>'; const e_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>'; const n_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>'; const i_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>'; const o_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>'; const r_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>'; const s_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>'; const a_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>'; const c_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>'; const l_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>'; const d_ = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>'; const u_ = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>'; const h_ = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>'; const g_ = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>'; const m_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>'; const f_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>'; const p_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>'; const b_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>'; const k_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>'; const w_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>'; const A_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>'; const __ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path clip-rule="evenodd" d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>'; const C_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path clip-rule="evenodd" d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>'; const v_ = { bold: k_, cancel: UA, caption: WA, check: qA, cog: GA, eraser: $A, image: YA, lowVision: KA, importExport: C_, paragraph: w_, plus: A_, text: __, alignBottom: QA, alignMiddle: ZA, alignTop: JA, alignLeft: XA, alignCenter: t_, alignRight: e_, alignJustify: n_, objectLeft: c_, objectCenter: o_, objectRight: l_, objectFullWidth: s_, objectInline: a_, objectBlockLeft: i_, objectBlockRight: r_, objectSizeFull: d_, objectSizeLarge: u_, objectSizeSmall: h_, objectSizeMedium: g_, pencil: m_, pilcrow: f_, quote: p_, threeVerticalDots: b_ }; function y_({ emitter: t, activator: e, callback: n, contextElements: i }) { t.listenTo(document, "mousedown", ((t, o) => { if (!e()) { return } const r = typeof o.composedPath == "function" ? o.composedPath() : []; const s = typeof i == "function" ? i() : i; for (const t of s) { if (t.contains(o.target) || r.includes(t)) { return } } n() })) } function x_(t) { class e extends t { disableCssTransitions() { this._isCssTransitionsDisabled = true } enableCssTransitions() { this._isCssTransitionsDisabled = false } constructor(...t) { super(...t); this.set("_isCssTransitionsDisabled", false); this.initializeCssTransitionDisablerMixin() } initializeCssTransitionDisablerMixin() { this.extendTemplate({ attributes: { class: [this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")] } }) } } return e } function E_({ view: t }) { t.listenTo(t.element, "submit", ((e, n) => { n.preventDefault(); t.fire("submit") }), { useCapture: true }) } function D_({ keystrokeHandler: t, focusTracker: e, gridItems: n, numberOfColumns: i, uiLanguageDirection: o }) { const r = typeof i === "number" ? () => i : i; t.set("arrowright", s(((t, e) => o === "rtl" ? c(t, e.length) : a(t, e.length)))); t.set("arrowleft", s(((t, e) => o === "rtl" ? a(t, e.length) : c(t, e.length)))); t.set("arrowup", s(((t, e) => { let n = t - r(); if (n < 0) { n = t + r() * Math.floor(e.length / r()); if (n > e.length - 1) { n -= r() } } return n }))); t.set("arrowdown", s(((t, e) => { let n = t + r(); if (n > e.length - 1) { n = t % r() } return n }))); function s(t) { return i => { const o = n.find((t => t.element === e.focusedElement)); const r = n.getIndex(o); const s = t(r, n); n.get(s).focus(); i.stopPropagation(); i.preventDefault() } } function a(t, e) { if (t === e - 1) { return 0 } else { return t + 1 } } function c(t, e) { if (t === 0) { return e - 1 } else { return t - 1 } } } class S_ extends il { constructor(t = []) { super(t, { idProperty: "viewUid" }); this.on("add", ((t, e, n) => { this._renderViewIntoCollectionParent(e, n) })); this.on("remove", ((t, e) => { if (e.element && this._parentElement) { e.element.remove() } })); this._parentElement = null } destroy() { this.map((t => t.destroy())) } setParent(t) { this._parentElement = t; for (const t of this) { this._renderViewIntoCollectionParent(t) } } delegate(...t) { if (!t.length || !T_(t)) { throw new I("ui-viewcollection-delegate-wrong-events", this) } return { to: e => { for (const n of this) { for (const i of t) { n.delegate(i).to(e) } } this.on("add", ((n, i) => { for (const n of t) { i.delegate(n).to(e) } })); this.on("remove", ((n, i) => { for (const n of t) { i.stopDelegating(n, e) } })) } } } _renderViewIntoCollectionParent(t, e) { if (!t.isRendered) { t.render() } if (t.element && this._parentElement) { this._parentElement.insertBefore(t.element, this._parentElement.children[e]) } } remove(t) { return super.remove(t) } } function T_(t) { return t.every((t => typeof t == "string")) } var I_ = n(6150); var M_ = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; M_.insert = "head"; M_.singleton = true; var B_ = Sl()(I_.Z, M_); const L_ = I_.Z.locals || {}; class N_ extends (Ga(lt())) { constructor(t) { super(); this.element = null; this.isRendered = false; this.locale = t; this.t = t && t.t; this._viewCollections = new il; this._unboundChildren = this.createCollection(); this._viewCollections.on("add", ((e, n) => { n.locale = t; n.t = t && t.t })); this.decorate("render") } get bindTemplate() { if (this._bindTemplate) { return this._bindTemplate } return this._bindTemplate = P_.bind(this, this) } createCollection(t) { const e = new S_(t); this._viewCollections.add(e); return e } registerChild(t) { if (!Ct(t)) { t = [t] } for (const e of t) { this._unboundChildren.add(e) } } deregisterChild(t) { if (!Ct(t)) { t = [t] } for (const e of t) { this._unboundChildren.remove(e) } } setTemplate(t) { this.template = new P_(t) } extendTemplate(t) { P_.extend(this.template, t) } render() { if (this.isRendered) { throw new I("ui-view-render-already-rendered", this) } if (this.template) { this.element = this.template.render(); this.registerChild(this.template.getViews()) } this.isRendered = true } destroy() { this.stopListening(); this._viewCollections.map((t => t.destroy())); if (this.template && this.template._revertData) { this.template.revert(this.element) } } } const z_ = "http://www.w3.org/1999/xhtml"; class P_ extends (U()) { constructor(t) { super(); Object.assign(this, $_(G_(t))); this._isRendered = false; this._revertData = null } render() { const t = this._renderNode({ intoFragment: true }); this._isRendered = true; return t } apply(t) { this._revertData = aC(); this._renderNode({ node: t, intoFragment: false, isApplying: true, revertData: this._revertData }); return t } revert(t) { if (!this._revertData) { throw new I("ui-template-revert-not-applied", [this, t]) } this._revertTemplateFromNode(t, this._revertData) } *getViews() { function* t(e) { if (e.children) { for (const n of e.children) { if (iC(n)) { yield n } else if (oC(n)) { yield* t(n) } } } } yield* t(this) } static bind(t, e) { return { to(n, i) { return new R_({ eventNameOrFunction: n, attribute: n, observable: t, emitter: e, callback: i }) }, if(n, i, o) { return new V_({ observable: t, emitter: e, attribute: n, valueIfTrue: i, callback: o }) } } } static extend(t, e) { if (t._isRendered) { throw new I("template-extend-render", [this, t]) } eC(t, $_(G_(e))) } _renderNode(t) { let e; if (t.node) { e = this.tag && this.text } else { e = this.tag ? this.text : !this.text } if (e) { throw new I("ui-template-wrong-syntax", this) } if (this.text) { return this._renderText(t) } else { return this._renderElement(t) } } _renderElement(t) { let e = t.node; if (!e) { e = t.node = document.createElementNS(this.ns || z_, this.tag) } this._renderAttributes(t); this._renderElementChildren(t); this._setUpListeners(t); return e } _renderText(t) { let e = t.node; if (e) { t.revertData.text = e.textContent } else { e = t.node = document.createTextNode("") } if (j_(this.text)) { this._bindToObservable({ schema: this.text, updater: U_(e), data: t }) } else { e.textContent = this.text.join("") } return e } _renderAttributes(t) { if (!this.attributes) { return } const e = t.node; const n = t.revertData; for (const i in this.attributes) { const o = e.getAttribute(i); const r = this.attributes[i]; if (n) { n.attributes[i] = o } const s = sC(r) ? r[0].ns : null; if (j_(r)) { const a = sC(r) ? r[0].value : r; if (n && cC(i)) { a.unshift(o) } this._bindToObservable({ schema: a, updater: W_(e, i, s), data: t }) } else if (i == "style" && typeof r[0] !== "string") { this._renderStyleAttribute(r[0], t) } else { if (n && o && cC(i)) { r.unshift(o) } const t = r.map((t => t ? t.value || t : t)).reduce(((t, e) => t.concat(e)), []).reduce(X_, ""); if (!nC(t)) { e.setAttributeNS(s, i, t) } } } } _renderStyleAttribute(t, e) { const n = e.node; for (const i in t) { const o = t[i]; if (j_(o)) { this._bindToObservable({ schema: [o], updater: q_(n, i), data: e }) } else { n.style[i] = o } } } _renderElementChildren(t) { const e = t.node; const n = t.intoFragment ? document.createDocumentFragment() : e; const i = t.isApplying; let o = 0; for (const r of this.children) { if (rC(r)) { if (!i) { r.setParent(e); for (const t of r) { n.appendChild(t.element) } } } else if (iC(r)) { if (!i) { if (!r.isRendered) { r.render() } n.appendChild(r.element) } } else if (Ua(r)) { n.appendChild(r) } else { if (i) { const e = t.revertData; const i = aC(); e.children.push(i); r._renderNode({ intoFragment: false, node: n.childNodes[o++], isApplying: true, revertData: i }) } else { n.appendChild(r.render()) } } } if (t.intoFragment) { e.appendChild(n) } } _setUpListeners(t) { if (!this.eventListeners) { return } for (const e in this.eventListeners) { const n = this.eventListeners[e].map((n => { const [i, o] = e.split("@"); return n.activateDomEventListener(i, o, t) })); if (t.revertData) { t.revertData.bindings.push(n) } } } _bindToObservable({ schema: t, updater: e, data: n }) { const i = n.revertData; H_(t, e, n); const o = t.filter((t => !nC(t))).filter((t => t.observable)).map((i => i.activateAttributeListener(t, e, n))); if (i) { i.bindings.push(o) } } _revertTemplateFromNode(t, e) { for (const t of e.bindings) { for (const e of t) { e() } } if (e.text) { t.textContent = e.text; return } const n = t; for (const t in e.attributes) { const i = e.attributes[t]; if (i === null) { n.removeAttribute(t) } else { n.setAttribute(t, i) } } for (let t = 0; t < e.children.length; ++t) { this._revertTemplateFromNode(n.childNodes[t], e.children[t]) } } } class O_ { constructor(t) { this.attribute = t.attribute; this.observable = t.observable; this.emitter = t.emitter; this.callback = t.callback } getValue(t) { const e = this.observable[this.attribute]; return this.callback ? this.callback(e, t) : e } activateAttributeListener(t, e, n) { const i = () => H_(t, e, n); this.emitter.listenTo(this.observable, `change:${this.attribute}`, i); return () => { this.emitter.stopListening(this.observable, `change:${this.attribute}`, i) } } } class R_ extends O_ { constructor(t) { super(t); this.eventNameOrFunction = t.eventNameOrFunction } activateDomEventListener(t, e, n) { const i = (t, n) => { if (!e || n.target.matches(e)) { if (typeof this.eventNameOrFunction == "function") { this.eventNameOrFunction(n) } else { this.observable.fire(this.eventNameOrFunction, n) } } }; this.emitter.listenTo(n.node, t, i); return () => { this.emitter.stopListening(n.node, t, i) } } } class V_ extends O_ { constructor(t) { super(t); this.valueIfTrue = t.valueIfTrue } getValue(t) { const e = super.getValue(t); return nC(e) ? false : this.valueIfTrue || true } } function j_(t) { if (!t) { return false } if (t.value) { t = t.value } if (Array.isArray(t)) { return t.some(j_) } else if (t instanceof O_) { return true } return false } function F_(t, e) { return t.map((t => { if (t instanceof O_) { return t.getValue(e) } return t })) } function H_(t, e, { node: n }) { const i = F_(t, n); let o; if (t.length == 1 && t[0] instanceof V_) { o = i[0] } else { o = i.reduce(X_, "") } if (nC(o)) { e.remove() } else { e.set(o) } } function U_(t) { return { set(e) { t.textContent = e }, remove() { t.textContent = "" } } } function W_(t, e, n) { return { set(i) { t.setAttributeNS(n, e, i) }, remove() { t.removeAttributeNS(n, e) } } } function q_(t, e) { return { set(n) { t.style[e] = n }, remove() { t.style[e] = null } } } function G_(t) { const e = Oa(t, (t => { if (t && (t instanceof O_ || oC(t) || iC(t) || rC(t))) { return t } })); return e } function $_(t) { if (typeof t == "string") { t = Q_(t) } else if (t.text) { Z_(t) } if (t.on) { t.eventListeners = Y_(t.on); delete t.on } if (!t.text) { if (t.attributes) { K_(t.attributes) } const e = []; if (t.children) { if (rC(t.children)) { e.push(t.children) } else { for (const n of t.children) { if (oC(n) || iC(n) || Ua(n)) { e.push(n) } else { e.push(new P_(n)) } } } } t.children = e } return t } function K_(t) { for (const e in t) { if (t[e].value) { t[e].value = $c(t[e].value) } J_(t, e) } } function Y_(t) { for (const e in t) { J_(t, e) } return t } function Q_(t) { return { text: [t] } } function Z_(t) { t.text = $c(t.text) } function J_(t, e) { t[e] = $c(t[e]) } function X_(t, e) { if (nC(e)) { return t } else if (nC(t)) { return e } else { return `${t} ${e}` } } function tC(t, e) { for (const n in e) { if (t[n]) { t[n].push(...e[n]) } else { t[n] = e[n] } } } function eC(t, e) { if (e.attributes) { if (!t.attributes) { t.attributes = {} } tC(t.attributes, e.attributes) } if (e.eventListeners) { if (!t.eventListeners) { t.eventListeners = {} } tC(t.eventListeners, e.eventListeners) } if (e.text) { t.text.push(...e.text) } if (e.children && e.children.length) { if (t.children.length != e.children.length) { throw new I("ui-template-extend-children-mismatch", t) } let n = 0; for (const i of e.children) { eC(t.children[n++], i) } } } function nC(t) { return !t && t !== 0 } function iC(t) { return t instanceof N_ } function oC(t) { return t instanceof P_ } function rC(t) { return t instanceof S_ } function sC(t) { return nt(t[0]) && t[0].ns } function aC() { return { children: [], bindings: [], attributes: {} } } function cC(t) { return t == "class" || t == "style" } class lC extends S_ { constructor(t, e = []) { super(e); this.locale = t } attachToDom() { this._bodyCollectionContainer = new P_({ tag: "div", attributes: { class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"], dir: this.locale.uiLanguageDirection }, children: this }).render(); let t = document.querySelector(".ck-body-wrapper"); if (!t) { t = Jt(document, "div", { class: "ck-body-wrapper" }); document.body.appendChild(t) } t.appendChild(this._bodyCollectionContainer) } detachFromDom() { super.destroy(); if (this._bodyCollectionContainer) { this._bodyCollectionContainer.remove() } const t = document.querySelector(".ck-body-wrapper"); if (t && t.childElementCount == 0) { t.remove() } } } var dC = n(1174); var uC = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; uC.insert = "head"; uC.singleton = true; var hC = Sl()(dC.Z, uC); const gC = dC.Z.locals || {}; class mC extends N_ { constructor() { super(); const t = this.bindTemplate; this.set("content", ""); this.set("viewBox", "0 0 20 20"); this.set("fillColor", ""); this.set("isColorInherited", true); this.setTemplate({ tag: "svg", ns: "http://www.w3.org/2000/svg", attributes: { class: ["ck", "ck-icon", "ck-reset_all-excluded", t.if("isColorInherited", "ck-icon_inherit-color")], viewBox: t.to("viewBox") } }) } render() { super.render(); this._updateXMLContent(); this._colorFillPaths(); this.on("change:content", (() => { this._updateXMLContent(); this._colorFillPaths() })); this.on("change:fillColor", (() => { this._colorFillPaths() })) } _updateXMLContent() { if (this.content) { const t = (new DOMParser).parseFromString(this.content.trim(), "image/svg+xml"); const e = t.querySelector("svg"); const n = e.getAttribute("viewBox"); if (n) { this.viewBox = n } for (const { name: t, value: n } of Array.from(e.attributes)) { if (mC.presentationalAttributeNames.includes(t)) { this.element.setAttribute(t, n) } } while (this.element.firstChild) { this.element.removeChild(this.element.firstChild) } while (e.childNodes.length > 0) { this.element.appendChild(e.childNodes[0]) } } } _colorFillPaths() { if (this.fillColor) { this.element.querySelectorAll(".ck-icon__fill").forEach((t => { t.style.fill = this.fillColor })) } } } mC.presentationalAttributeNames = ["alignment-baseline", "baseline-shift", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-rendering", "cursor", "direction", "display", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "overflow", "paint-order", "pointer-events", "shape-rendering", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-overflow", "text-rendering", "transform", "unicode-bidi", "vector-effect", "visibility", "white-space", "word-spacing", "writing-mode"]; var fC = n(4499); var pC = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; pC.insert = "head"; pC.singleton = true; var bC = Sl()(fC.Z, pC); const kC = fC.Z.locals || {}; class wC extends N_ { constructor(t) { super(t); const e = this.bindTemplate; const n = x(); this.set("class", undefined); this.set("labelStyle", undefined); this.set("icon", undefined); this.set("isEnabled", true); this.set("isOn", false); this.set("isVisible", true); this.set("isToggleable", false); this.set("keystroke", undefined); this.set("label", undefined); this.set("tabindex", -1); this.set("tooltip", false); this.set("tooltipPosition", "s"); this.set("type", "button"); this.set("withText", false); this.set("withKeystroke", false); this.children = this.createCollection(); this.labelView = this._createLabelView(n); this.iconView = new mC; this.iconView.extendTemplate({ attributes: { class: "ck-button__icon" } }); this.keystrokeView = this._createKeystrokeView(); this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this)); const i = { tag: "button", attributes: { class: ["ck", "ck-button", e.to("class"), e.if("isEnabled", "ck-disabled", (t => !t)), e.if("isVisible", "ck-hidden", (t => !t)), e.to("isOn", (t => t ? "ck-on" : "ck-off")), e.if("withText", "ck-button_with-text"), e.if("withKeystroke", "ck-button_with-keystroke")], type: e.to("type", (t => t ? t : "button")), tabindex: e.to("tabindex"), "aria-labelledby": `ck-editor__aria-label_${n}`, "aria-disabled": e.if("isEnabled", true, (t => !t)), "aria-pressed": e.to("isOn", (t => this.isToggleable ? String(!!t) : false)), "data-cke-tooltip-text": e.to("_tooltipString"), "data-cke-tooltip-position": e.to("tooltipPosition") }, children: this.children, on: { click: e.to((t => { if (this.isEnabled) { this.fire("execute") } else { t.preventDefault() } })) } }; if (r.isSafari) { i.on.mousedown = e.to((t => { this.focus(); t.preventDefault() })) } this.setTemplate(i) } render() { super.render(); if (this.icon) { this.iconView.bind("content").to(this, "icon"); this.children.add(this.iconView) } this.children.add(this.labelView); if (this.withKeystroke && this.keystroke) { this.children.add(this.keystrokeView) } } focus() { this.element.focus() } _createLabelView(t) { const e = new N_; const n = this.bindTemplate; e.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__label"], style: n.to("labelStyle"), id: `ck-editor__aria-label_${t}` }, children: [{ text: n.to("label") }] }); return e } _createKeystrokeView() { const t = new N_; t.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__keystroke"] }, children: [{ text: this.bindTemplate.to("keystroke", (t => jc(t))) }] }); return t } _getTooltipString(t, e, n) { if (t) { if (typeof t == "string") { return t } else { if (n) { n = jc(n) } if (t instanceof Function) { return t(e, n) } else { return `${e}${n ? ` (${n})` : ""}` } } } return "" } } var AC = n(9681); var _C = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; _C.insert = "head"; _C.singleton = true; var CC = Sl()(AC.Z, _C); const vC = AC.Z.locals || {}; class yC extends wC { constructor(t) { super(t); this.isToggleable = true; this.toggleSwitchView = this._createToggleView(); this.extendTemplate({ attributes: { class: "ck-switchbutton" } }) } render() { super.render(); this.children.add(this.toggleSwitchView) } _createToggleView() { const t = new N_; t.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__toggle"] }, children: [{ tag: "span", attributes: { class: ["ck", "ck-button__toggle__inner"] } }] }); return t } } function xC(t, e) { const n = t.t; const i = { Black: n("Black"), "Dim grey": n("Dim grey"), Grey: n("Grey"), "Light grey": n("Light grey"), White: n("White"), Red: n("Red"), Orange: n("Orange"), Yellow: n("Yellow"), "Light green": n("Light green"), Green: n("Green"), Aquamarine: n("Aquamarine"), Turquoise: n("Turquoise"), "Light blue": n("Light blue"), Blue: n("Blue"), Purple: n("Purple") }; return e.map((t => { const e = i[t.label]; if (e && e != t.label) { t.label = e } return t })) } function EC(t) { return t.map(DC).filter((t => !!t)) } function DC(t) { if (typeof t === "string") { return { model: t, label: t, hasBorder: false, view: { name: "span", styles: { color: t } } } } else { return { model: t.color, label: t.label || t.color, hasBorder: t.hasBorder === undefined ? false : t.hasBorder, view: { name: "span", styles: { color: `${t.color}` } } } } } const SC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035 8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>'; class TC extends wC { constructor(t) { super(t); const e = this.bindTemplate; this.set("color", undefined); this.set("hasBorder", false); this.icon = SC; this.extendTemplate({ attributes: { style: { backgroundColor: e.to("color") }, class: ["ck", "ck-color-grid__tile", e.if("hasBorder", "ck-color-table__color-tile_bordered")] } }) } render() { super.render(); this.iconView.fillColor = "hsl(0, 0%, 100%)" } } var IC = n(4923); var MC = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; MC.insert = "head"; MC.singleton = true; var BC = Sl()(IC.Z, MC); const LC = IC.Z.locals || {}; class NC extends N_ { constructor(t, e) { super(t); const n = e && e.colorDefinitions ? e.colorDefinitions : []; this.columns = e && e.columns ? e.columns : 5; const i = { gridTemplateColumns: `repeat( ${this.columns}, 1fr)` }; this.set("selectedColor", undefined); this.items = this.createCollection(); this.focusTracker = new rl; this.keystrokes = new sl; this.items.on("add", ((t, e) => { e.isOn = e.color === this.selectedColor })); n.forEach((t => { const e = new TC; e.set({ color: t.color, label: t.label, tooltip: true, hasBorder: t.options.hasBorder }); e.on("execute", (() => { this.fire("execute", { value: t.color, hasBorder: t.options.hasBorder, label: t.label }) })); this.items.add(e) })); this.setTemplate({ tag: "div", children: this.items, attributes: { class: ["ck", "ck-color-grid"], style: i } }); this.on("change:selectedColor", ((t, e, n) => { for (const t of this.items) { t.isOn = t.color === n } })) } focus() { if (this.items.length) { this.items.first.focus() } } focusLast() { if (this.items.length) { this.items.last.focus() } } render() { super.render(); for (const t of this.items) { this.focusTracker.add(t.element) } this.items.on("add", ((t, e) => { this.focusTracker.add(e.element) })); this.items.on("remove", ((t, e) => { this.focusTracker.remove(e.element) })); this.keystrokes.listenTo(this.element); D_({ keystrokeHandler: this.keystrokes, focusTracker: this.focusTracker, gridItems: this.items, numberOfColumns: this.columns, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection }) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } } class zC { constructor(t) { this._components = new Map; this.editor = t } *names() { for (const t of this._components.values()) { yield t.originalName } } add(t, e) { this._components.set(PC(t), { callback: e, originalName: t }) } create(t) { if (!this.has(t)) { throw new I("componentfactory-item-missing", this, { name: t }) } return this._components.get(PC(t)).callback(this.editor.locale) } has(t) { return this._components.has(PC(t)) } } function PC(t) { return String(t).toLowerCase() } var OC = n(3488); var RC = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; RC.insert = "head"; RC.singleton = true; var VC = Sl()(OC.Z, RC); const jC = OC.Z.locals || {}; class FC extends N_ { constructor(t, e, n) { super(t); const i = this.bindTemplate; this.buttonView = e; this.panelView = n; this.set("isOpen", false); this.set("isEnabled", true); this.set("class", undefined); this.set("id", undefined); this.set("panelPosition", "auto"); this.keystrokes = new sl; this.focusTracker = new rl; this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-dropdown", i.to("class"), i.if("isEnabled", "ck-disabled", (t => !t))], id: i.to("id"), "aria-describedby": i.to("ariaDescribedById") }, children: [e, n] }); e.extendTemplate({ attributes: { class: ["ck-dropdown__button"], "data-cke-tooltip-disabled": i.to("isOpen") } }) } render() { super.render(); this.focusTracker.add(this.buttonView.element); this.focusTracker.add(this.panelView.element); this.listenTo(this.buttonView, "open", (() => { this.isOpen = !this.isOpen })); this.panelView.bind("isVisible").to(this, "isOpen"); this.on("change:isOpen", ((t, e, n) => { if (!n) { return } if (this.panelPosition === "auto") { this.panelView.position = FC._getOptimalPosition({ element: this.panelView.element, target: this.buttonView.element, fitInViewport: true, positions: this._panelPositions }).name } else { this.panelView.position = this.panelPosition } })); this.keystrokes.listenTo(this.element); const t = (t, e) => { if (this.isOpen) { this.isOpen = false; e() } }; this.keystrokes.set("arrowdown", ((t, e) => { if (this.buttonView.isEnabled && !this.isOpen) { this.isOpen = true; e() } })); this.keystrokes.set("arrowright", ((t, e) => { if (this.isOpen) { e() } })); this.keystrokes.set("arrowleft", t); this.keystrokes.set("esc", t) } focus() { this.buttonView.focus() } get _panelPositions() { const { south: t, north: e, southEast: n, southWest: i, northEast: o, northWest: r, southMiddleEast: s, southMiddleWest: a, northMiddleEast: c, northMiddleWest: l } = FC.defaultPanelPositions; if (this.locale.uiLanguageDirection !== "rtl") { return [n, i, s, a, t, o, r, c, l, e] } else { return [i, n, a, s, t, r, o, l, c, e] } } } FC.defaultPanelPositions = { south: (t, e) => ({ top: t.bottom, left: t.left - (e.width - t.width) / 2, name: "s" }), southEast: t => ({ top: t.bottom, left: t.left, name: "se" }), southWest: (t, e) => ({ top: t.bottom, left: t.left - e.width + t.width, name: "sw" }), southMiddleEast: (t, e) => ({ top: t.bottom, left: t.left - (e.width - t.width) / 4, name: "sme" }), southMiddleWest: (t, e) => ({ top: t.bottom, left: t.left - (e.width - t.width) * 3 / 4, name: "smw" }), north: (t, e) => ({ top: t.top - e.height, left: t.left - (e.width - t.width) / 2, name: "n" }), northEast: (t, e) => ({ top: t.top - e.height, left: t.left, name: "ne" }), northWest: (t, e) => ({ top: t.top - e.height, left: t.left - e.width + t.width, name: "nw" }), northMiddleEast: (t, e) => ({ top: t.top - e.height, left: t.left - (e.width - t.width) / 4, name: "nme" }), northMiddleWest: (t, e) => ({ top: t.top - e.height, left: t.left - (e.width - t.width) * 3 / 4, name: "nmw" }) }; FC._getOptimalPosition = pc; class HC extends N_ { constructor(t) { super(t); const e = this.bindTemplate; this.set("isVisible", false); this.set("position", "se"); this.children = this.createCollection(); this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-dropdown__panel", e.to("position", (t => `ck-dropdown__panel_${t}`)), e.if("isVisible", "ck-dropdown__panel-visible")] }, children: this.children, on: { selectstart: e.to((t => t.preventDefault())) } }) } focus() { if (this.children.length) { const t = this.children.first; if (typeof t.focus === "function") { t.focus() } else { M("ui-dropdown-panel-focus-child-missing-focus", { childView: this.children.first, dropdownPanel: this }) } } } focusLast() { if (this.children.length) { const t = this.children.last; if (typeof t.focusLast === "function") { t.focusLast() } else { t.focus() } } } } const UC = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>'; class WC extends wC { constructor(t) { super(t); this.arrowView = this._createArrowView(); this.extendTemplate({ attributes: { "aria-haspopup": true, "aria-expanded": this.bindTemplate.to("isOn", (t => String(t))) } }); this.delegate("execute").to(this, "open") } render() { super.render(); this.children.add(this.arrowView) } _createArrowView() { const t = new mC; t.content = UC; t.extendTemplate({ attributes: { class: "ck-dropdown__arrow" } }); return t } } var qC = n(66); var GC = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; GC.insert = "head"; GC.singleton = true; var $C = Sl()(qC.Z, GC); const KC = qC.Z.locals || {}; class YC extends N_ { constructor(t) { super(t); const e = this.bindTemplate; this.set("class", undefined); this.set("labelStyle", undefined); this.set("icon", undefined); this.set("isEnabled", true); this.set("isOn", false); this.set("isToggleable", false); this.set("isVisible", true); this.set("keystroke", undefined); this.set("withKeystroke", false); this.set("label", undefined); this.set("tabindex", -1); this.set("tooltip", false); this.set("tooltipPosition", "s"); this.set("type", "button"); this.set("withText", false); this.children = this.createCollection(); this.actionView = this._createActionView(); this.arrowView = this._createArrowView(); this.keystrokes = new sl; this.focusTracker = new rl; this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-splitbutton", e.to("class"), e.if("isVisible", "ck-hidden", (t => !t)), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")] }, children: this.children }) } render() { super.render(); this.children.add(this.actionView); this.children.add(this.arrowView); this.focusTracker.add(this.actionView.element); this.focusTracker.add(this.arrowView.element); this.keystrokes.listenTo(this.element); this.keystrokes.set("arrowright", ((t, e) => { if (this.focusTracker.focusedElement === this.actionView.element) { this.arrowView.focus(); e() } })); this.keystrokes.set("arrowleft", ((t, e) => { if (this.focusTracker.focusedElement === this.arrowView.element) { this.actionView.focus(); e() } })) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } focus() { this.actionView.focus() } _createActionView() { const t = new wC; t.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this); t.extendTemplate({ attributes: { class: "ck-splitbutton__action" } }); t.delegate("execute").to(this); return t } _createArrowView() { const t = new wC; const e = t.bindTemplate; t.icon = UC; t.extendTemplate({ attributes: { class: ["ck-splitbutton__arrow"], "data-cke-tooltip-disabled": e.to("isOn"), "aria-haspopup": true, "aria-expanded": e.to("isOn", (t => String(t))) } }); t.bind("isEnabled").to(this); t.bind("label").to(this); t.bind("tooltip").to(this); t.delegate("execute").to(this, "open"); return t } } class QC { constructor(t) { this.focusables = t.focusables; this.focusTracker = t.focusTracker; this.keystrokeHandler = t.keystrokeHandler; this.actions = t.actions; if (t.actions && t.keystrokeHandler) { for (const e in t.actions) { let n = t.actions[e]; if (typeof n == "string") { n = [n] } for (const i of n) { t.keystrokeHandler.set(i, ((t, n) => { this[e](); n() })) } } } } get first() { return this.focusables.find(ZC) || null } get last() { return this.focusables.filter(ZC).slice(-1)[0] || null } get next() { return this._getFocusableItem(1) } get previous() { return this._getFocusableItem(-1) } get current() { let t = null; if (this.focusTracker.focusedElement === null) { return null } this.focusables.find(((e, n) => { const i = e.element === this.focusTracker.focusedElement; if (i) { t = n } return i })); return t } focusFirst() { this._focus(this.first) } focusLast() { this._focus(this.last) } focusNext() { this._focus(this.next) } focusPrevious() { this._focus(this.previous) } _focus(t) { if (t) { t.focus() } } _getFocusableItem(t) { const e = this.current; const n = this.focusables.length; if (!n) { return null } if (e === null) { return this[t === 1 ? "first" : "last"] } let i = (e + n + t) % n; do { const e = this.focusables.get(i); if (ZC(e)) { return e } i = (i + n + t) % n } while (i !== e); return null } } function ZC(t) { return !!(t.focus && mc(t.element)) } class JC extends N_ { constructor(t) { super(t); this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__separator"] } }) } } class XC extends N_ { constructor(t) { super(t); this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__line-break"] } }) } } function tv(t) { return t.bindTemplate.to((e => { if (e.target === t.element) { e.preventDefault() } })) } function ev(t) { if (Array.isArray(t)) { return { items: t, removeItems: [] } } if (!t) { return { items: [], removeItems: [] } } return Object.assign({ items: [], removeItems: [] }, t) } var nv = n(5571); var iv = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; iv.insert = "head"; iv.singleton = true; var ov = Sl()(nv.Z, iv); const rv = nv.Z.locals || {}; const { threeVerticalDots: sv } = v_; const av = { alignLeft: v_.alignLeft, bold: v_.bold, importExport: v_.importExport, paragraph: v_.paragraph, plus: v_.plus, text: v_.text, threeVerticalDots: v_.threeVerticalDots }; class cv extends N_ { constructor(t, e) { super(t); const n = this.bindTemplate; const i = this.t; this.options = e || {}; this.set("ariaLabel", i("Editor toolbar")); this.set("maxWidth", "auto"); this.items = this.createCollection(); this.focusTracker = new rl; this.keystrokes = new sl; this.set("class", undefined); this.set("isCompact", false); this.itemsView = new lv(t); this.children = this.createCollection(); this.children.add(this.itemsView); this.focusables = this.createCollection(); const o = t.uiLanguageDirection === "rtl"; this._focusCycler = new QC({ focusables: this.focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: [o ? "arrowright" : "arrowleft", "arrowup"], focusNext: [o ? "arrowleft" : "arrowright", "arrowdown"] } }); const r = ["ck", "ck-toolbar", n.to("class"), n.if("isCompact", "ck-toolbar_compact")]; if (this.options.shouldGroupWhenFull && this.options.isFloating) { r.push("ck-toolbar_floating") } this.setTemplate({ tag: "div", attributes: { class: r, role: "toolbar", "aria-label": n.to("ariaLabel"), style: { maxWidth: n.to("maxWidth") } }, children: this.children, on: { mousedown: tv(this) } }); this._behavior = this.options.shouldGroupWhenFull ? new uv(this) : new dv(this) } render() { super.render(); for (const t of this.items) { this.focusTracker.add(t.element) } this.items.on("add", ((t, e) => { this.focusTracker.add(e.element) })); this.items.on("remove", ((t, e) => { this.focusTracker.remove(e.element) })); this.keystrokes.listenTo(this.element); this._behavior.render(this) } destroy() { this._behavior.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy(); return super.destroy() } focus() { this._focusCycler.focusFirst() } focusLast() { this._focusCycler.focusLast() } fillFromConfig(t, e, n) { this.items.addMany(this._buildItemsFromConfig(t, e, n)) } _buildItemsFromConfig(t, e, n) { const i = ev(t); const o = n || i.removeItems; const r = this._cleanItemsConfiguration(i.items, e, o).map((t => { if (nt(t)) { return this._createNestedToolbarDropdown(t, e, o) } else if (t === "|") { return new JC } else if (t === "-") { return new XC } return e.create(t) })).filter((t => !!t)); return r } _cleanItemsConfiguration(t, e, n) { const i = t.filter(((t, i, o) => { if (t === "|") { return true } if (n.indexOf(t) !== -1) { return false } if (t === "-") { if (this.options.shouldGroupWhenFull) { M("toolbarview-line-break-ignored-when-grouping-items", o); return false } return true } if (!nt(t) && !e.has(t)) { M("toolbarview-item-unavailable", { item: t }); return false } return true })); return this._cleanSeparatorsAndLineBreaks(i) } _cleanSeparatorsAndLineBreaks(t) { const e = t => t !== "-" && t !== "|"; const n = t.length; const i = t.findIndex(e); if (i === -1) { return [] } const o = n - t.slice().reverse().findIndex(e); return t.slice(i, o).filter(((t, n, i) => { if (e(t)) { return true } const o = n > 0 && i[n - 1] === t; return !o })) } _createNestedToolbarDropdown(t, e, n) { let { label: i, icon: o, items: r, tooltip: s = true, withText: a = false } = t; r = this._cleanItemsConfiguration(r, e, n); if (!r.length) { return null } const c = this.locale; const l = Dv(c); if (!i) { M("toolbarview-nested-toolbar-dropdown-missing-label", t) } l.class = "ck-toolbar__nested-toolbar-dropdown"; l.buttonView.set({ label: i, tooltip: s, withText: !!a }); if (o !== false) { l.buttonView.icon = av[o] || o || sv } else { l.buttonView.withText = true } Sv(l, (() => l.toolbarView._buildItemsFromConfig(r, e, n))); return l } } class lv extends N_ { constructor(t) { super(t); this.children = this.createCollection(); this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-toolbar__items"] }, children: this.children }) } } class dv { constructor(t) { const e = t.bindTemplate; t.set("isVertical", false); t.itemsView.children.bindTo(t.items).using((t => t)); t.focusables.bindTo(t.items).using((t => t)); t.extendTemplate({ attributes: { class: [e.if("isVertical", "ck-toolbar_vertical")] } }) } render() { } destroy() { } } class uv { constructor(t) { this.resizeObserver = null; this.cachedPadding = null; this.shouldUpdateGroupingOnNextResize = false; this.view = t; this.viewChildren = t.children; this.viewFocusables = t.focusables; this.viewItemsView = t.itemsView; this.viewFocusTracker = t.focusTracker; this.viewLocale = t.locale; this.ungroupedItems = t.createCollection(); this.groupedItems = t.createCollection(); this.groupedItemsDropdown = this._createGroupedItemsDropdown(); t.itemsView.children.bindTo(this.ungroupedItems).using((t => t)); this.ungroupedItems.on("change", this._updateFocusCycleableItems.bind(this)); t.children.on("change", this._updateFocusCycleableItems.bind(this)); t.items.on("change", ((t, e) => { const n = e.index; const i = Array.from(e.added); for (const t of e.removed) { if (n >= this.ungroupedItems.length) { this.groupedItems.remove(t) } else { this.ungroupedItems.remove(t) } } for (let t = n; t < n + i.length; t++) { const e = i[t - n]; if (t > this.ungroupedItems.length) { this.groupedItems.add(e, t - this.ungroupedItems.length) } else { this.ungroupedItems.add(e, t) } } this._updateGrouping() })); t.extendTemplate({ attributes: { class: ["ck-toolbar_grouping"] } }) } render(t) { this.viewElement = t.element; this._enableGroupingOnResize(); this._enableGroupingOnMaxWidthChange(t) } destroy() { this.groupedItemsDropdown.destroy(); this.resizeObserver.destroy() } _updateGrouping() { if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) { return } if (!mc(this.viewElement)) { this.shouldUpdateGroupingOnNextResize = true; return } const t = this.groupedItems.length; let e; while (this._areItemsOverflowing) { this._groupLastItem(); e = true } if (!e && this.groupedItems.length) { while (this.groupedItems.length && !this._areItemsOverflowing) { this._ungroupFirstItem() } if (this._areItemsOverflowing) { this._groupLastItem() } } if (this.groupedItems.length !== t) { this.view.fire("groupedItemsUpdate") } } get _areItemsOverflowing() { if (!this.ungroupedItems.length) { return false } const t = this.viewElement; const e = this.viewLocale.uiLanguageDirection; const n = new oc(t.lastChild); const i = new oc(t); if (!this.cachedPadding) { const n = Za.window.getComputedStyle(t); const i = e === "ltr" ? "paddingRight" : "paddingLeft"; this.cachedPadding = Number.parseInt(n[i]) } if (e === "ltr") { return n.right > i.right - this.cachedPadding } else { return n.left < i.left + this.cachedPadding } } _enableGroupingOnResize() { let t; this.resizeObserver = new cc(this.viewElement, (e => { if (!t || t !== e.contentRect.width || this.shouldUpdateGroupingOnNextResize) { this.shouldUpdateGroupingOnNextResize = false; this._updateGrouping(); t = e.contentRect.width } })); this._updateGrouping() } _enableGroupingOnMaxWidthChange(t) { t.on("change:maxWidth", (() => { this._updateGrouping() })) } _groupLastItem() { if (!this.groupedItems.length) { this.viewChildren.add(new JC); this.viewChildren.add(this.groupedItemsDropdown); this.viewFocusTracker.add(this.groupedItemsDropdown.element) } this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0) } _ungroupFirstItem() { this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)); if (!this.groupedItems.length) { this.viewChildren.remove(this.groupedItemsDropdown); this.viewChildren.remove(this.viewChildren.last); this.viewFocusTracker.remove(this.groupedItemsDropdown.element) } } _createGroupedItemsDropdown() { const t = this.viewLocale; const e = t.t; const n = Dv(t); n.class = "ck-toolbar__grouped-dropdown"; n.panelPosition = t.uiLanguageDirection === "ltr" ? "sw" : "se"; Sv(n, this.groupedItems); n.buttonView.set({ label: e("Show more items"), tooltip: true, tooltipPosition: t.uiLanguageDirection === "rtl" ? "se" : "sw", icon: sv }); return n } _updateFocusCycleableItems() { this.viewFocusables.clear(); this.ungroupedItems.map((t => { this.viewFocusables.add(t) })); if (this.groupedItems.length) { this.viewFocusables.add(this.groupedItemsDropdown) } } } var hv = n(1162); var gv = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; gv.insert = "head"; gv.singleton = true; var mv = Sl()(hv.Z, gv); const fv = hv.Z.locals || {}; class pv extends N_ { constructor(t) { super(t); const e = this.bindTemplate; this.items = this.createCollection(); this.focusTracker = new rl; this.keystrokes = new sl; this._focusCycler = new QC({ focusables: this.items, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "arrowup", focusNext: "arrowdown" } }); this.set("ariaLabel", undefined); this.setTemplate({ tag: "ul", attributes: { class: ["ck", "ck-reset", "ck-list"], "aria-label": e.to("ariaLabel") }, children: this.items }) } render() { super.render(); for (const t of this.items) { this.focusTracker.add(t.element) } this.items.on("add", ((t, e) => { this.focusTracker.add(e.element) })); this.items.on("remove", ((t, e) => { this.focusTracker.remove(e.element) })); this.keystrokes.listenTo(this.element) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } focus() { this._focusCycler.focusFirst() } focusLast() { this._focusCycler.focusLast() } } class bv extends N_ { constructor(t) { super(t); const e = this.bindTemplate; this.set("isVisible", true); this.children = this.createCollection(); this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__item", e.if("isVisible", "ck-hidden", (t => !t))] }, children: this.children }) } focus() { this.children.first.focus() } } class kv extends N_ { constructor(t) { super(t); this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__separator"] } }) } } var wv = n(5075); var Av = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Av.insert = "head"; Av.singleton = true; var _v = Sl()(wv.Z, Av); const Cv = wv.Z.locals || {}; var vv = n(6875); var yv = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; yv.insert = "head"; yv.singleton = true; var xv = Sl()(vv.Z, yv); const Ev = vv.Z.locals || {}; function Dv(t, e = WC) { const n = new e(t); const i = new HC(t); const o = new FC(t, n, i); n.bind("isEnabled").to(o); if (n instanceof YC) { n.arrowView.bind("isOn").to(o, "isOpen") } else { n.bind("isOn").to(o, "isOpen") } Lv(o); return o } function Sv(t, e, n = {}) { t.extendTemplate({ attributes: { class: ["ck-toolbar-dropdown"] } }); if (t.isOpen) { Tv(t, e, n) } else { t.once("change:isOpen", (() => Tv(t, e, n)), { priority: "highest" }) } if (n.enableActiveItemFocusOnDropdownOpen) { Bv(t, (() => t.toolbarView.items.find((t => t.isOn)))) } } function Tv(t, e, n) { const i = t.locale; const o = i.t; const r = t.toolbarView = new cv(i); const s = typeof e == "function" ? e() : e; r.ariaLabel = n.ariaLabel || o("Dropdown toolbar"); if (n.maxWidth) { r.maxWidth = n.maxWidth } if (n.class) { r.class = n.class } if (n.isCompact) { r.isCompact = n.isCompact } if (n.isVertical) { r.isVertical = true } if (s instanceof S_) { r.items.bindTo(s).using((t => t)) } else { r.items.addMany(s) } t.panelView.children.add(r); r.items.delegate("execute").to(t) } function Iv(t, e, n = {}) { if (t.isOpen) { Mv(t, e, n) } else { t.once("change:isOpen", (() => Mv(t, e, n)), { priority: "highest" }) } Bv(t, (() => t.listView.items.find((t => { if (t instanceof bv) { return t.children.first.isOn } return false })))) } function Mv(t, e, n) { const i = t.locale; const o = t.listView = new pv(i); const r = typeof e == "function" ? e() : e; o.ariaLabel = n.ariaLabel; o.items.bindTo(r).using((t => { if (t.type === "separator") { return new kv(i) } else if (t.type === "button" || t.type === "switchbutton") { const e = new bv(i); let n; if (t.type === "button") { n = new wC(i) } else { n = new yC(i) } n.bind(...Object.keys(t.model)).to(t.model); n.delegate("execute").to(e); e.children.add(n); return e } return null })); t.panelView.children.add(o); o.items.delegate("execute").to(t) } function Bv(t, e) { t.on("change:isOpen", (() => { if (!t.isOpen) { return } const n = e(); if (!n) { return } if (typeof n.focus === "function") { n.focus() } else { M("ui-dropdown-focus-child-on-open-child-missing-focus", { view: n }) } }), { priority: D.low - 10 }) } function Lv(t) { Nv(t); zv(t); Pv(t); Ov(t); Rv(t); Vv(t) } function Nv(t) { t.on("render", (() => { y_({ emitter: t, activator: () => t.isOpen, callback: () => { t.isOpen = false }, contextElements: [t.element] }) })) } function zv(t) { t.on("execute", (e => { if (e.source instanceof yC) { return } t.isOpen = false })) } function Pv(t) { t.focusTracker.on("change:isFocused", ((e, n, i) => { if (t.isOpen && !i) { t.isOpen = false } })) } function Ov(t) { t.keystrokes.set("arrowdown", ((e, n) => { if (t.isOpen) { t.panelView.focus(); n() } })); t.keystrokes.set("arrowup", ((e, n) => { if (t.isOpen) { t.panelView.focusLast(); n() } })) } function Rv(t) { t.on("change:isOpen", ((e, n, i) => { if (i) { return } const o = t.panelView.element; if (o && o.contains(Za.document.activeElement)) { t.buttonView.focus() } })) } function Vv(t) { t.on("change:isOpen", ((e, n, i) => { if (!i) { return } t.panelView.focus() }), { priority: "low" }) } var jv = n(8245); var Fv = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Fv.insert = "head"; Fv.singleton = true; var Hv = Sl()(jv.Z, Fv); const Uv = jv.Z.locals || {}; const Wv = dc("px"); const qv = Za.document.body; class Gv extends N_ { constructor(t) { super(t); const e = this.bindTemplate; this.set("top", 0); this.set("left", 0); this.set("position", "arrow_nw"); this.set("isVisible", false); this.set("withArrow", true); this.set("class", undefined); this._pinWhenIsVisibleCallback = null; this.content = this.createCollection(); this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-panel", e.to("position", (t => `ck-balloon-panel_${t}`)), e.if("isVisible", "ck-balloon-panel_visible"), e.if("withArrow", "ck-balloon-panel_with-arrow"), e.to("class")], style: { top: e.to("top", Wv), left: e.to("left", Wv) } }, children: this.content }) } show() { this.isVisible = true } hide() { this.isVisible = false } attachTo(t) { this.show(); const e = Gv.defaultPositions; const n = Object.assign({}, { element: this.element, positions: [e.southArrowNorth, e.southArrowNorthMiddleWest, e.southArrowNorthMiddleEast, e.southArrowNorthWest, e.southArrowNorthEast, e.northArrowSouth, e.northArrowSouthMiddleWest, e.northArrowSouthMiddleEast, e.northArrowSouthWest, e.northArrowSouthEast, e.viewportStickyNorth], limiter: qv, fitInViewport: true }, t); const i = Gv._getOptimalPosition(n); const o = parseInt(i.left); const r = parseInt(i.top); const s = i.name; const a = i.config || {}; const { withArrow: c = true } = a; this.top = r; this.left = o; this.position = s; this.withArrow = c } pin(t) { this.unpin(); this._pinWhenIsVisibleCallback = () => { if (this.isVisible) { this._startPinning(t) } else { this._stopPinning() } }; this._startPinning(t); this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback) } unpin() { if (this._pinWhenIsVisibleCallback) { this._stopPinning(); this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback); this._pinWhenIsVisibleCallback = null; this.hide() } } _startPinning(t) { this.attachTo(t); const e = $v(t.target); const n = t.limiter ? $v(t.limiter) : qv; this.listenTo(Za.document, "scroll", ((i, o) => { const r = o.target; const s = e && r.contains(e); const a = n && r.contains(n); if (s || a || !e || !n) { this.attachTo(t) } }), { useCapture: true }); this.listenTo(Za.window, "resize", (() => { this.attachTo(t) })) } _stopPinning() { this.stopListening(Za.document, "scroll"); this.stopListening(Za.window, "resize") } } Gv.arrowSideOffset = 25; Gv.arrowHeightOffset = 10; Gv.stickyVerticalOffset = 20; Gv._getOptimalPosition = pc; Gv.defaultPositions = Kv(); function $v(t) { if (Va(t)) { return t } if (ec(t)) { return t.commonAncestorContainer } if (typeof t == "function") { return $v(t()) } return null } function Kv(t = {}) { const { sideOffset: e = Gv.arrowSideOffset, heightOffset: n = Gv.arrowHeightOffset, stickyVerticalOffset: i = Gv.stickyVerticalOffset, config: o } = t; return { northWestArrowSouthWest: (t, n) => ({ top: r(t, n), left: t.left - e, name: "arrow_sw", ...o && { config: o } }), northWestArrowSouthMiddleWest: (t, n) => ({ top: r(t, n), left: t.left - n.width * .25 - e, name: "arrow_smw", ...o && { config: o } }), northWestArrowSouth: (t, e) => ({ top: r(t, e), left: t.left - e.width / 2, name: "arrow_s", ...o && { config: o } }), northWestArrowSouthMiddleEast: (t, n) => ({ top: r(t, n), left: t.left - n.width * .75 + e, name: "arrow_sme", ...o && { config: o } }), northWestArrowSouthEast: (t, n) => ({ top: r(t, n), left: t.left - n.width + e, name: "arrow_se", ...o && { config: o } }), northArrowSouthWest: (t, n) => ({ top: r(t, n), left: t.left + t.width / 2 - e, name: "arrow_sw", ...o && { config: o } }), northArrowSouthMiddleWest: (t, n) => ({ top: r(t, n), left: t.left + t.width / 2 - n.width * .25 - e, name: "arrow_smw", ...o && { config: o } }), northArrowSouth: (t, e) => ({ top: r(t, e), left: t.left + t.width / 2 - e.width / 2, name: "arrow_s", ...o && { config: o } }), northArrowSouthMiddleEast: (t, n) => ({ top: r(t, n), left: t.left + t.width / 2 - n.width * .75 + e, name: "arrow_sme", ...o && { config: o } }), northArrowSouthEast: (t, n) => ({ top: r(t, n), left: t.left + t.width / 2 - n.width + e, name: "arrow_se", ...o && { config: o } }), northEastArrowSouthWest: (t, n) => ({ top: r(t, n), left: t.right - e, name: "arrow_sw", ...o && { config: o } }), northEastArrowSouthMiddleWest: (t, n) => ({ top: r(t, n), left: t.right - n.width * .25 - e, name: "arrow_smw", ...o && { config: o } }), northEastArrowSouth: (t, e) => ({ top: r(t, e), left: t.right - e.width / 2, name: "arrow_s", ...o && { config: o } }), northEastArrowSouthMiddleEast: (t, n) => ({ top: r(t, n), left: t.right - n.width * .75 + e, name: "arrow_sme", ...o && { config: o } }), northEastArrowSouthEast: (t, n) => ({ top: r(t, n), left: t.right - n.width + e, name: "arrow_se", ...o && { config: o } }), southWestArrowNorthWest: t => ({ top: s(t), left: t.left - e, name: "arrow_nw", ...o && { config: o } }), southWestArrowNorthMiddleWest: (t, n) => ({ top: s(t), left: t.left - n.width * .25 - e, name: "arrow_nmw", ...o && { config: o } }), southWestArrowNorth: (t, e) => ({ top: s(t), left: t.left - e.width / 2, name: "arrow_n", ...o && { config: o } }), southWestArrowNorthMiddleEast: (t, n) => ({ top: s(t), left: t.left - n.width * .75 + e, name: "arrow_nme", ...o && { config: o } }), southWestArrowNorthEast: (t, n) => ({ top: s(t), left: t.left - n.width + e, name: "arrow_ne", ...o && { config: o } }), southArrowNorthWest: t => ({ top: s(t), left: t.left + t.width / 2 - e, name: "arrow_nw", ...o && { config: o } }), southArrowNorthMiddleWest: (t, n) => ({ top: s(t), left: t.left + t.width / 2 - n.width * .25 - e, name: "arrow_nmw", ...o && { config: o } }), southArrowNorth: (t, e) => ({ top: s(t), left: t.left + t.width / 2 - e.width / 2, name: "arrow_n", ...o && { config: o } }), southArrowNorthMiddleEast: (t, n) => ({ top: s(t), left: t.left + t.width / 2 - n.width * .75 + e, name: "arrow_nme", ...o && { config: o } }), southArrowNorthEast: (t, n) => ({ top: s(t), left: t.left + t.width / 2 - n.width + e, name: "arrow_ne", ...o && { config: o } }), southEastArrowNorthWest: t => ({ top: s(t), left: t.right - e, name: "arrow_nw", ...o && { config: o } }), southEastArrowNorthMiddleWest: (t, n) => ({ top: s(t), left: t.right - n.width * .25 - e, name: "arrow_nmw", ...o && { config: o } }), southEastArrowNorth: (t, e) => ({ top: s(t), left: t.right - e.width / 2, name: "arrow_n", ...o && { config: o } }), southEastArrowNorthMiddleEast: (t, n) => ({ top: s(t), left: t.right - n.width * .75 + e, name: "arrow_nme", ...o && { config: o } }), southEastArrowNorthEast: (t, n) => ({ top: s(t), left: t.right - n.width + e, name: "arrow_ne", ...o && { config: o } }), westArrowEast: (t, e) => ({ top: t.top + t.height / 2 - e.height / 2, left: t.left - e.width - n, name: "arrow_e", ...o && { config: o } }), eastArrowWest: (t, e) => ({ top: t.top + t.height / 2 - e.height / 2, left: t.right + n, name: "arrow_w", ...o && { config: o } }), viewportStickyNorth: (t, e, n) => { if (!t.getIntersection(n)) { return null } return { top: n.top + i, left: t.left + t.width / 2 - e.width / 2, name: "arrowless", config: { withArrow: false, ...o } } } }; function r(t, e) { return t.top - e.height - n } function s(t) { return t.bottom + n } } var Yv = n(9948); var Qv = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Qv.insert = "head"; Qv.singleton = true; var Zv = Sl()(Yv.Z, Qv); const Jv = Yv.Z.locals || {}; const Xv = "ck-tooltip"; class ty extends (Ga()) { constructor(t) { super(); this._currentElementWithTooltip = null; this._currentTooltipPosition = null; this._resizeObserver = null; ty._editors.add(t); if (ty._instance) { return ty._instance } ty._instance = this; this.tooltipTextView = new N_(t.locale); this.tooltipTextView.set("text", ""); this.tooltipTextView.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-tooltip__text"] }, children: [{ text: this.tooltipTextView.bindTemplate.to("text") }] }); this.balloonPanelView = new Gv(t.locale); this.balloonPanelView.class = Xv; this.balloonPanelView.content.add(this.tooltipTextView); this._pinTooltipDebounced = Yg(this._pinTooltip, 600); this.listenTo(Za.document, "mouseenter", this._onEnterOrFocus.bind(this), { useCapture: true }); this.listenTo(Za.document, "mouseleave", this._onLeaveOrBlur.bind(this), { useCapture: true }); this.listenTo(Za.document, "focus", this._onEnterOrFocus.bind(this), { useCapture: true }); this.listenTo(Za.document, "blur", this._onLeaveOrBlur.bind(this), { useCapture: true }); this.listenTo(Za.document, "scroll", this._onScroll.bind(this), { useCapture: true }); this._watchdogExcluded = true } destroy(t) { const e = t.ui.view && t.ui.view.body; ty._editors.delete(t); this.stopListening(t.ui); if (e && e.has(this.balloonPanelView)) { e.remove(this.balloonPanelView) } if (!ty._editors.size) { this._unpinTooltip(); this.balloonPanelView.destroy(); this.stopListening(); ty._instance = null } } static getPositioningFunctions(t) { const e = ty.defaultBalloonPositions; return { s: [e.southArrowNorth, e.southArrowNorthEast, e.southArrowNorthWest], n: [e.northArrowSouth], e: [e.eastArrowWest], w: [e.westArrowEast], sw: [e.southArrowNorthEast], se: [e.southArrowNorthWest] }[t] } _onEnterOrFocus(t, { target: e }) { const n = ey(e); if (!n) { return } if (n === this._currentElementWithTooltip) { return } this._unpinTooltip(); this._pinTooltipDebounced(n, ny(n)) } _onLeaveOrBlur(t, { target: e, relatedTarget: n }) { if (t.name === "mouseleave") { if (!Va(e)) { return } if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) { return } const t = ey(e); const i = ey(n); if (t && t !== i) { this._unpinTooltip() } } else { if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) { return } this._unpinTooltip() } } _onScroll(t, { target: e }) { if (!this._currentElementWithTooltip) { return } if (e.contains(this.balloonPanelView.element) && e.contains(this._currentElementWithTooltip)) { return } this._unpinTooltip() } _pinTooltip(t, { text: e, position: n, cssClass: i }) { const o = ol(ty._editors.values()).ui.view.body; if (!o.has(this.balloonPanelView)) { o.add(this.balloonPanelView) } this.tooltipTextView.text = e; this.balloonPanelView.pin({ target: t, positions: ty.getPositioningFunctions(n) }); this._resizeObserver = new cc(t, (() => { if (!mc(t)) { this._unpinTooltip() } })); this.balloonPanelView.class = [Xv, i].filter((t => t)).join(" "); for (const t of ty._editors) { this.listenTo(t.ui, "update", this._updateTooltipPosition.bind(this), { priority: "low" }) } this._currentElementWithTooltip = t; this._currentTooltipPosition = n } _unpinTooltip() { this._pinTooltipDebounced.cancel(); this.balloonPanelView.unpin(); for (const t of ty._editors) { this.stopListening(t.ui, "update") } this._currentElementWithTooltip = null; this._currentTooltipPosition = null; if (this._resizeObserver) { this._resizeObserver.destroy() } } _updateTooltipPosition() { if (!mc(this._currentElementWithTooltip)) { this._unpinTooltip(); return } this.balloonPanelView.pin({ target: this._currentElementWithTooltip, positions: ty.getPositioningFunctions(this._currentTooltipPosition) }) } } ty.defaultBalloonPositions = Kv({ heightOffset: 5, sideOffset: 13 }); ty._editors = new Set; ty._instance = null; function ey(t) { if (!Va(t)) { return null } return t.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])") } function ny(t) { return { text: t.dataset.ckeTooltipText, position: t.dataset.ckeTooltipPosition || "s", cssClass: t.dataset.ckeTooltipClass || "" } } class iy extends (lt()) { constructor(t) { super(); this.isReady = false; this._editableElementsMap = new Map; this._focusableToolbarDefinitions = []; this.editor = t; this.componentFactory = new zC(t); this.focusTracker = new rl; this.tooltipManager = new ty(t); this.set("viewportOffset", this._readViewportOffsetFromConfig()); this.once("ready", (() => { this.isReady = true })); this.listenTo(t.editing.view.document, "layoutChanged", (() => this.update())); this._initFocusTracking() } get element() { return null } update() { this.fire("update") } destroy() { this.stopListening(); this.focusTracker.destroy(); this.tooltipManager.destroy(this.editor); for (const t of this._editableElementsMap.values()) { t.ckeditorInstance = null; this.editor.keystrokes.stopListening(t) } this._editableElementsMap = new Map; this._focusableToolbarDefinitions = [] } setEditableElement(t, e) { this._editableElementsMap.set(t, e); if (!e.ckeditorInstance) { e.ckeditorInstance = this.editor } this.focusTracker.add(e); const n = () => { if (this.editor.editing.view.getDomRoot(t)) { return } this.editor.keystrokes.listenTo(e) }; if (this.isReady) { n() } else { this.once("ready", n) } } removeEditableElement(t) { const e = this._editableElementsMap.get(t); if (!e) { return } this._editableElementsMap.delete(t); this.editor.keystrokes.stopListening(e); this.focusTracker.remove(e); e.ckeditorInstance = null } getEditableElement(t = "main") { return this._editableElementsMap.get(t) } getEditableElementsNames() { return this._editableElementsMap.keys() } addToolbar(t, e = {}) { if (t.isRendered) { this.focusTracker.add(t.element); this.editor.keystrokes.listenTo(t.element) } else { t.once("render", (() => { this.focusTracker.add(t.element); this.editor.keystrokes.listenTo(t.element) })) } this._focusableToolbarDefinitions.push({ toolbarView: t, options: e }) } get _editableElements() { console.warn("editor-ui-deprecated-editable-elements: " + "The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", { editorUI: this }); return this._editableElementsMap } _readViewportOffsetFromConfig() { const t = this.editor; const e = t.config.get("ui.viewportOffset"); if (e) { return e } const n = t.config.get("toolbar.viewportTopOffset"); if (n) { console.warn("editor-ui-deprecated-viewport-offset-config: " + "The `toolbar.vieportTopOffset` configuration option is deprecated. " + "It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."); return { top: n } } return { top: 0 } } _initFocusTracking() { const t = this.editor; const e = t.editing.view; let n; let i; t.keystrokes.set("Alt+F10", ((t, o) => { const r = this.focusTracker.focusedElement; if (Array.from(this._editableElementsMap.values()).includes(r) && !Array.from(e.domRoots.values()).includes(r)) { n = r } const s = this._getCurrentFocusedToolbarDefinition(); if (!s || !i) { i = this._getFocusableCandidateToolbarDefinitions() } for (let t = 0; t < i.length; t++) { const t = i.shift(); i.push(t); if (t !== s && this._focusFocusableCandidateToolbar(t)) { if (s && s.options.afterBlur) { s.options.afterBlur() } break } } o() })); t.keystrokes.set("Esc", ((e, i) => { const o = this._getCurrentFocusedToolbarDefinition(); if (!o) { return } if (n) { n.focus(); n = null } else { t.editing.view.focus() } if (o.options.afterBlur) { o.options.afterBlur() } i() })) } _getFocusableCandidateToolbarDefinitions() { const t = []; for (const e of this._focusableToolbarDefinitions) { const { toolbarView: n, options: i } = e; if (mc(n.element) || i.beforeFocus) { t.push(e) } } t.sort(((t, e) => oy(t) - oy(e))); return t } _getCurrentFocusedToolbarDefinition() { for (const t of this._focusableToolbarDefinitions) { if (t.toolbarView.element && t.toolbarView.element.contains(this.focusTracker.focusedElement)) { return t } } return null } _focusFocusableCandidateToolbar(t) { const { toolbarView: e, options: { beforeFocus: n } } = t; if (n) { n() } if (!mc(e.element)) { return false } e.focus(); return true } } function oy(t) { const { toolbarView: e, options: n } = t; let i = 10; if (mc(e.element)) { i-- } if (n.isContextual) { i-- } return i } var ry = n(4547); var sy = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; sy.insert = "head"; sy.singleton = true; var ay = Sl()(ry.Z, sy); const cy = ry.Z.locals || {}; class ly extends N_ { constructor(t) { super(t); this.body = new lC(t) } render() { super.render(); this.body.attachToDom() } destroy() { this.body.detachFromDom(); return super.destroy() } } var dy = n(2751); var uy = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; uy.insert = "head"; uy.singleton = true; var hy = Sl()(dy.Z, uy); const gy = dy.Z.locals || {}; class my extends N_ { constructor(t) { super(t); this.set("text", undefined); this.set("for", undefined); this.id = `ck-editor__label_${x()}`; const e = this.bindTemplate; this.setTemplate({ tag: "label", attributes: { class: ["ck", "ck-label"], id: this.id, for: e.to("for") }, children: [{ text: e.to("text") }] }) } } class fy extends (null && EditorUIView) { constructor(t) { super(t); this.top = this.createCollection(); this.main = this.createCollection(); this._voiceLabelView = this._createVoiceLabel(); this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"], role: "application", dir: t.uiLanguageDirection, lang: t.uiLanguage, "aria-labelledby": this._voiceLabelView.id }, children: [this._voiceLabelView, { tag: "div", attributes: { class: ["ck", "ck-editor__top", "ck-reset_all"], role: "presentation" }, children: this.top }, { tag: "div", attributes: { class: ["ck", "ck-editor__main"], role: "presentation" }, children: this.main }] }) } _createVoiceLabel() { const t = this.t; const e = new LabelView; e.text = t("Rich Text Editor"); e.extendTemplate({ attributes: { class: "ck-voice-label" } }); return e } } class py extends N_ { constructor(t, e, n) { super(t); this.name = null; this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"], lang: t.contentLanguage, dir: t.contentLanguageDirection } }); this.set("isFocused", false); this._editableElement = n; this._hasExternalElement = !!this._editableElement; this._editingView = e } render() { super.render(); if (this._hasExternalElement) { this.template.apply(this.element = this._editableElement) } else { this._editableElement = this.element } this.on("change:isFocused", (() => this._updateIsFocusedClasses())); this._updateIsFocusedClasses() } destroy() { if (this._hasExternalElement) { this.template.revert(this._editableElement) } super.destroy() } get hasExternalElement() { return this._hasExternalElement } _updateIsFocusedClasses() { const t = this._editingView; if (t.isRenderingInProgress) { n(this) } else { e(this) } function e(e) { t.change((n => { const i = t.document.getRoot(e.name); n.addClass(e.isFocused ? "ck-focused" : "ck-blurred", i); n.removeClass(e.isFocused ? "ck-blurred" : "ck-focused", i) })) } function n(i) { t.once("change:isRenderingInProgress", ((t, o, r) => { if (!r) { e(i) } else { n(i) } })) } } } class by extends py { constructor(t, e, n, i = {}) { super(t, e, n); const o = t.t; this.extendTemplate({ attributes: { role: "textbox", class: "ck-editor__editable_inline" } }); this._generateLabel = i.label || (() => o("Editor editing area: %0", this.name)) } render() { super.render(); const t = this._editingView; t.change((e => { const n = t.document.getRoot(this.name); e.setAttribute("aria-label", this._generateLabel(this), n) })) } } var ky = n(5523); var wy = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; wy.insert = "head"; wy.singleton = true; var Ay = Sl()(ky.Z, wy); const _y = ky.Z.locals || {}; class Cy extends N_ { constructor(t, e = {}) { super(t); const n = this.bindTemplate; this.set("label", e.label || ""); this.set("class", e.class || null); this.children = this.createCollection(); this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-form__header", n.to("class")] }, children: this.children }); const i = new N_(t); i.setTemplate({ tag: "h2", attributes: { class: ["ck", "ck-form__header__label"] }, children: [{ text: n.to("label") }] }); this.children.add(i) } } var vy = n(6985); var yy = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; yy.insert = "head"; yy.singleton = true; var xy = Sl()(vy.Z, yy); const Ey = vy.Z.locals || {}; class Dy extends N_ { constructor(t) { super(t); this.set("value", undefined); this.set("id", undefined); this.set("placeholder", undefined); this.set("isReadOnly", false); this.set("hasError", false); this.set("ariaDescribedById", undefined); this.focusTracker = new rl; this.bind("isFocused").to(this.focusTracker); this.set("isEmpty", true); this.set("inputMode", "text"); const e = this.bindTemplate; this.setTemplate({ tag: "input", attributes: { class: ["ck", "ck-input", e.if("isFocused", "ck-input_focused"), e.if("isEmpty", "ck-input-text_empty"), e.if("hasError", "ck-error")], id: e.to("id"), placeholder: e.to("placeholder"), readonly: e.to("isReadOnly"), inputmode: e.to("inputMode"), "aria-invalid": e.if("hasError", true), "aria-describedby": e.to("ariaDescribedById") }, on: { input: e.to(((...t) => { this.fire("input", ...t); this._updateIsEmpty() })), change: e.to(this._updateIsEmpty.bind(this)) } }) } render() { super.render(); this.focusTracker.add(this.element); this._setDomElementValue(this.value); this._updateIsEmpty(); this.on("change:value", ((t, e, n) => { this._setDomElementValue(n); this._updateIsEmpty() })) } destroy() { super.destroy(); this.focusTracker.destroy() } select() { this.element.select() } focus() { this.element.focus() } _updateIsEmpty() { this.isEmpty = Sy(this.element) } _setDomElementValue(t) { this.element.value = !t && t !== 0 ? "" : t } } function Sy(t) { return !t.value } class Ty extends Dy { constructor(t) { super(t); this.extendTemplate({ attributes: { type: "text", class: ["ck-input-text"] } }) } } class Iy extends Dy { constructor(t, { min: e, max: n, step: i } = {}) { super(t); const o = this.bindTemplate; this.set("min", e); this.set("max", n); this.set("step", i); this.extendTemplate({ attributes: { type: "number", class: ["ck-input-number"], min: o.to("min"), max: o.to("max"), step: o.to("step") } }) } } class My extends (null && View) { constructor(t) { super(t); const e = this.bindTemplate; this.setTemplate({ tag: "iframe", attributes: { class: ["ck", "ck-reset_all"], sandbox: "allow-same-origin allow-scripts" }, on: { load: e.to("loaded") } }) } render() { return new Promise((t => { this.on("loaded", t); return super.render() })) } } var By = n(8111); var Ly = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Ly.insert = "head"; Ly.singleton = true; var Ny = Sl()(By.Z, Ly); const zy = By.Z.locals || {}; class Py extends N_ { constructor(t, e) { super(t); const n = `ck-labeled-field-view-${x()}`; const i = `ck-labeled-field-view-status-${x()}`; this.fieldView = e(this, n, i); this.set("label", undefined); this.set("isEnabled", true); this.set("isEmpty", true); this.set("isFocused", false); this.set("errorText", null); this.set("infoText", null); this.set("class", undefined); this.set("placeholder", undefined); this.labelView = this._createLabelView(n); this.statusView = this._createStatusView(i); this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]); this.bind("_statusText").to(this, "errorText", this, "infoText", ((t, e) => t || e)); const o = this.bindTemplate; this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view", o.to("class"), o.if("isEnabled", "ck-disabled", (t => !t)), o.if("isEmpty", "ck-labeled-field-view_empty"), o.if("isFocused", "ck-labeled-field-view_focused"), o.if("placeholder", "ck-labeled-field-view_placeholder"), o.if("errorText", "ck-error")] }, children: [{ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__input-wrapper"] }, children: this.fieldWrapperChildren }, this.statusView] }) } _createLabelView(t) { const e = new my(this.locale); e.for = t; e.bind("text").to(this, "label"); return e } _createStatusView(t) { const e = new N_(this.locale); const n = this.bindTemplate; e.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__status", n.if("errorText", "ck-labeled-field-view__status_error"), n.if("_statusText", "ck-hidden", (t => !t))], id: t, role: n.if("errorText", "alert") }, children: [{ text: n.to("_statusText") }] }); return e } focus() { this.fieldView.focus() } } function Oy(t, e, n) { const i = new Ty(t.locale); i.set({ id: e, ariaDescribedById: n }); i.bind("isReadOnly").to(t, "isEnabled", (t => !t)); i.bind("hasError").to(t, "errorText", (t => !!t)); i.on("input", (() => { t.errorText = null })); t.bind("isEmpty", "isFocused", "placeholder").to(i); return i } function Ry(t, e, n) { const i = new Iy(t.locale); i.set({ id: e, ariaDescribedById: n, inputMode: "numeric" }); i.bind("isReadOnly").to(t, "isEnabled", (t => !t)); i.bind("hasError").to(t, "errorText", (t => !!t)); i.on("input", (() => { t.errorText = null })); t.bind("isEmpty", "isFocused", "placeholder").to(i); return i } function Vy(t, e, n) { const i = Dv(t.locale); i.set({ id: e, ariaDescribedById: n }); i.bind("isEnabled").to(t); return i } class jy extends El { static get pluginName() { return "Notification" } init() { this.on("show:warning", ((t, e) => { window.alert(e.message) }), { priority: "lowest" }) } showSuccess(t, e = {}) { this._showNotification({ message: t, type: "success", namespace: e.namespace, title: e.title }) } showInfo(t, e = {}) { this._showNotification({ message: t, type: "info", namespace: e.namespace, title: e.title }) } showWarning(t, e = {}) { this._showNotification({ message: t, type: "warning", namespace: e.namespace, title: e.title }) } _showNotification(t) { const e = t.namespace ? `show:${t.type}:${t.namespace}` : `show:${t.type}`; this.fire(e, { message: t.message, type: t.type, title: t.title || "" }) } } class Fy extends (lt()) { constructor(t, e) { super(); if (e) { Eg(this, e) } if (t) { this.set(t) } } } const Hy = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>'; const Uy = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'; var Wy = n(1757); var qy = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; qy.insert = "head"; qy.singleton = true; var Gy = Sl()(Wy.Z, qy); const $y = Wy.Z.locals || {}; var Ky = n(3553); var Yy = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Yy.insert = "head"; Yy.singleton = true; var Qy = Sl()(Ky.Z, Yy); const Zy = Ky.Z.locals || {}; const Jy = dc("px"); class Xy extends wl { static get pluginName() { return "ContextualBalloon" } constructor(t) { super(t); this._viewToStack = new Map; this._idToStack = new Map; this._view = null; this._rotatorView = null; this._fakePanelsView = null; this.positionLimiter = () => { const t = this.editor.editing.view; const e = t.document; const n = e.selection.editableElement; if (n) { return t.domConverter.mapViewToDom(n.root) } return null }; this.set("visibleView", null); this.set("_numberOfStacks", 0); this.set("_singleViewMode", false) } destroy() { super.destroy(); if (this._view) { this._view.destroy() } if (this._rotatorView) { this._rotatorView.destroy() } if (this._fakePanelsView) { this._fakePanelsView.destroy() } } get view() { if (!this._view) { this._createPanelView() } return this._view } hasView(t) { return Array.from(this._viewToStack.keys()).includes(t) } add(t) { if (!this._view) { this._createPanelView() } if (this.hasView(t.view)) { throw new I("contextualballoon-add-view-exist", [this, t]) } const e = t.stackId || "main"; if (!this._idToStack.has(e)) { this._idToStack.set(e, new Map([[t.view, t]])); this._viewToStack.set(t.view, this._idToStack.get(e)); this._numberOfStacks = this._idToStack.size; if (!this._visibleStack || t.singleViewMode) { this.showStack(e) } return } const n = this._idToStack.get(e); if (t.singleViewMode) { this.showStack(e) } n.set(t.view, t); this._viewToStack.set(t.view, n); if (n === this._visibleStack) { this._showView(t) } } remove(t) { if (!this.hasView(t)) { throw new I("contextualballoon-remove-view-not-exist", [this, t]) } const e = this._viewToStack.get(t); if (this._singleViewMode && this.visibleView === t) { this._singleViewMode = false } if (this.visibleView === t) { if (e.size === 1) { if (this._idToStack.size > 1) { this._showNextStack() } else { this.view.hide(); this.visibleView = null; this._rotatorView.hideView() } } else { this._showView(Array.from(e.values())[e.size - 2]) } } if (e.size === 1) { this._idToStack.delete(this._getStackId(e)); this._numberOfStacks = this._idToStack.size } else { e.delete(t) } this._viewToStack.delete(t) } updatePosition(t) { if (t) { this._visibleStack.get(this.visibleView).position = t } this.view.pin(this._getBalloonPosition()); this._fakePanelsView.updatePosition() } showStack(t) { this.visibleStack = t; const e = this._idToStack.get(t); if (!e) { throw new I("contextualballoon-showstack-stack-not-exist", this) } if (this._visibleStack === e) { return } this._showView(Array.from(e.values()).pop()) } _createPanelView() { this._view = new Gv(this.editor.locale); this.editor.ui.view.body.add(this._view); this.editor.ui.focusTracker.add(this._view.element); this._rotatorView = this._createRotatorView(); this._fakePanelsView = this._createFakePanelsView() } get _visibleStack() { return this._viewToStack.get(this.visibleView) } _getStackId(t) { const e = Array.from(this._idToStack.entries()).find((e => e[1] === t)); return e[0] } _showNextStack() { const t = Array.from(this._idToStack.values()); let e = t.indexOf(this._visibleStack) + 1; if (!t[e]) { e = 0 } this.showStack(this._getStackId(t[e])) } _showPrevStack() { const t = Array.from(this._idToStack.values()); let e = t.indexOf(this._visibleStack) - 1; if (!t[e]) { e = t.length - 1 } this.showStack(this._getStackId(t[e])) } _createRotatorView() { const t = new tx(this.editor.locale); const e = this.editor.locale.t; this.view.content.add(t); t.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", ((t, e) => !e && t > 1)); t.on("change:isNavigationVisible", (() => this.updatePosition()), { priority: "low" }); t.bind("counter").to(this, "visibleView", this, "_numberOfStacks", ((t, n) => { if (n < 2) { return "" } const i = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1; return e("%0 of %1", [i, n]) })); t.buttonNextView.on("execute", (() => { if (t.focusTracker.isFocused) { this.editor.editing.view.focus() } this._showNextStack() })); t.buttonPrevView.on("execute", (() => { if (t.focusTracker.isFocused) { this.editor.editing.view.focus() } this._showPrevStack() })); return t } _createFakePanelsView() { const t = new ex(this.editor.locale, this.view); t.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", ((t, e) => { const n = !e && t >= 2; return n ? Math.min(t - 1, 2) : 0 })); t.listenTo(this.view, "change:top", (() => t.updatePosition())); t.listenTo(this.view, "change:left", (() => t.updatePosition())); this.editor.ui.view.body.add(t); return t } _showView({ view: t, balloonClassName: e = "", withArrow: n = true, singleViewMode: i = false }) { this.view.class = e; this.view.withArrow = n; this._rotatorView.showView(t); this.visibleView = t; this.view.pin(this._getBalloonPosition()); this._fakePanelsView.updatePosition(); if (i) { this._singleViewMode = true } } _getBalloonPosition() { let t = Array.from(this._visibleStack.values()).pop().position; if (t) { if (!t.limiter) { t = Object.assign({}, t, { limiter: this.positionLimiter }) } t = Object.assign({}, t, { viewportOffsetConfig: this.editor.ui.viewportOffset }) } return t } } class tx extends N_ { constructor(t) { super(t); const e = t.t; const n = this.bindTemplate; this.set("isNavigationVisible", true); this.focusTracker = new rl; this.buttonPrevView = this._createButtonView(e("Previous"), Hy); this.buttonNextView = this._createButtonView(e("Next"), Uy); this.content = this.createCollection(); this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-rotator"], "z-index": "-1" }, children: [{ tag: "div", attributes: { class: ["ck-balloon-rotator__navigation", n.to("isNavigationVisible", (t => t ? "" : "ck-hidden"))] }, children: [this.buttonPrevView, { tag: "span", attributes: { class: ["ck-balloon-rotator__counter"] }, children: [{ text: n.to("counter") }] }, this.buttonNextView] }, { tag: "div", attributes: { class: "ck-balloon-rotator__content" }, children: this.content }] }) } render() { super.render(); this.focusTracker.add(this.element) } destroy() { super.destroy(); this.focusTracker.destroy() } showView(t) { this.hideView(); this.content.add(t) } hideView() { this.content.clear() } _createButtonView(t, e) { const n = new wC(this.locale); n.set({ label: t, icon: e, tooltip: true }); return n } } class ex extends N_ { constructor(t, e) { super(t); const n = this.bindTemplate; this.set("top", 0); this.set("left", 0); this.set("height", 0); this.set("width", 0); this.set("numberOfPanels", 0); this.content = this.createCollection(); this._balloonPanelView = e; this.setTemplate({ tag: "div", attributes: { class: ["ck-fake-panel", n.to("numberOfPanels", (t => t ? "" : "ck-hidden"))], style: { top: n.to("top", Jy), left: n.to("left", Jy), width: n.to("width", Jy), height: n.to("height", Jy) } }, children: this.content }); this.on("change:numberOfPanels", ((t, e, n, i) => { if (n > i) { this._addPanels(n - i) } else { this._removePanels(i - n) } this.updatePosition() })) } _addPanels(t) { while (t--) { const t = new N_; t.setTemplate({ tag: "div" }); this.content.add(t); this.registerChild(t) } } _removePanels(t) { while (t--) { const t = this.content.last; this.content.remove(t); this.deregisterChild(t); t.destroy() } } updatePosition() { if (this.numberOfPanels) { const { top: t, left: e } = this._balloonPanelView; const { width: n, height: i } = new oc(this._balloonPanelView.element); Object.assign(this, { top: t, left: e, width: n, height: i }) } } } var nx = n(3609); var ix = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; ix.insert = "head"; ix.singleton = true; var ox = Sl()(nx.Z, ix); const rx = nx.Z.locals || {}; const sx = dc("px"); class ax extends (null && View) { constructor(t) { super(t); const e = this.bindTemplate; this.set("isActive", false); this.set("isSticky", false); this.set("limiterElement", null); this.set("limiterBottomOffset", 50); this.set("viewportTopOffset", 0); this.set("_marginLeft", null); this.set("_isStickyToTheLimiter", false); this.set("_hasViewportTopOffset", false); this.content = this.createCollection(); this._contentPanelPlaceholder = new Template({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__placeholder"], style: { display: e.to("isSticky", (t => t ? "block" : "none")), height: e.to("isSticky", (t => t ? sx(this._panelRect.height) : null)) } } }).render(); this._contentPanel = new Template({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__content", e.if("isSticky", "ck-sticky-panel__content_sticky"), e.if("_isStickyToTheLimiter", "ck-sticky-panel__content_sticky_bottom-limit")], style: { width: e.to("isSticky", (t => t ? sx(this._contentPanelPlaceholder.getBoundingClientRect().width) : null)), top: e.to("_hasViewportTopOffset", (t => t ? sx(this.viewportTopOffset) : null)), bottom: e.to("_isStickyToTheLimiter", (t => t ? sx(this.limiterBottomOffset) : null)), marginLeft: e.to("_marginLeft") } }, children: this.content }).render(); this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel"] }, children: [this._contentPanelPlaceholder, this._contentPanel] }) } render() { super.render(); this._checkIfShouldBeSticky(); this.listenTo(global.window, "scroll", (() => { this._checkIfShouldBeSticky() })); this.listenTo(this, "change:isActive", (() => { this._checkIfShouldBeSticky() })) } _checkIfShouldBeSticky() { const t = this._panelRect = this._contentPanel.getBoundingClientRect(); let e; if (!this.limiterElement) { this.isSticky = false } else { e = this._limiterRect = this.limiterElement.getBoundingClientRect(); this.isSticky = this.isActive && e.top < this.viewportTopOffset && this._panelRect.height + this.limiterBottomOffset < e.height } if (this.isSticky) { this._isStickyToTheLimiter = e.bottom < t.height + this.limiterBottomOffset + this.viewportTopOffset; this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset; this._marginLeft = this._isStickyToTheLimiter ? null : sx(-global.window.scrollX) } else { this._isStickyToTheLimiter = false; this._hasViewportTopOffset = false; this._marginLeft = null } } } const cx = dc("px"); class lx extends wl { static get pluginName() { return "BalloonToolbar" } static get requires() { return [Xy] } constructor(t) { super(t); this._resizeObserver = null; this._balloonConfig = ev(t.config.get("balloonToolbar")); this.toolbarView = this._createToolbarView(); this.focusTracker = new rl; t.ui.once("ready", (() => { this.focusTracker.add(t.ui.getEditableElement()); this.focusTracker.add(this.toolbarView.element) })); t.ui.addToolbar(this.toolbarView, { beforeFocus: () => this.show(true), afterBlur: () => this.hide(), isContextual: true }); this._balloon = t.plugins.get(Xy); this._fireSelectionChangeDebounced = Yg((() => this.fire("_selectionChangeDebounced")), 200); this.decorate("show") } init() { const t = this.editor; const e = t.model.document.selection; this.listenTo(this.focusTracker, "change:isFocused", ((t, e, n) => { const i = this._balloon.visibleView === this.toolbarView; if (!n && i) { this.hide() } else if (n) { this.show() } })); this.listenTo(e, "change:range", ((t, n) => { if (n.directChange || e.isCollapsed) { this.hide() } this._fireSelectionChangeDebounced() })); this.listenTo(this, "_selectionChangeDebounced", (() => { if (this.editor.editing.view.document.isFocused) { this.show() } })); if (!this._balloonConfig.shouldNotGroupWhenFull) { this.listenTo(t, "ready", (() => { const e = t.ui.view.editable.element; this._resizeObserver = new cc(e, (t => { this.toolbarView.maxWidth = cx(t.contentRect.width * .9) })) })) } this.listenTo(this.toolbarView, "groupedItemsUpdate", (() => { this._updatePosition() })) } afterInit() { const t = this.editor.ui.componentFactory; this.toolbarView.fillFromConfig(this._balloonConfig, t) } _createToolbarView() { const t = this.editor.locale.t; const e = !this._balloonConfig.shouldNotGroupWhenFull; const n = new cv(this.editor.locale, { shouldGroupWhenFull: e, isFloating: true }); n.ariaLabel = t("Editor contextual toolbar"); n.render(); return n } show(t = false) { const e = this.editor; const n = e.model.document.selection; const i = e.model.schema; if (this._balloon.hasView(this.toolbarView)) { return } if (n.isCollapsed && !t) { return } if (dx(n, i)) { return } if (Array.from(this.toolbarView.items).every((t => t.isEnabled !== undefined && !t.isEnabled))) { return } this.listenTo(this.editor.ui, "update", (() => { this._updatePosition() })); this._balloon.add({ view: this.toolbarView, position: this._getBalloonPositionData(), balloonClassName: "ck-toolbar-container" }) } hide() { if (this._balloon.hasView(this.toolbarView)) { this.stopListening(this.editor.ui, "update"); this._balloon.remove(this.toolbarView) } } _getBalloonPositionData() { const t = this.editor; const e = t.editing.view; const n = e.document; const i = n.selection; const o = n.selection.isBackward; return { target: () => { const t = o ? i.getFirstRange() : i.getLastRange(); const n = oc.getDomRangeRects(e.domConverter.viewRangeToDom(t)); if (o) { return n[0] } else { if (n.length > 1 && n[n.length - 1].width === 0) { n.pop() } return n[n.length - 1] } }, positions: this._getBalloonPositions(o) } } _updatePosition() { this._balloon.updatePosition(this._getBalloonPositionData()) } destroy() { super.destroy(); this.stopListening(); this._fireSelectionChangeDebounced.cancel(); this.toolbarView.destroy(); this.focusTracker.destroy(); if (this._resizeObserver) { this._resizeObserver.destroy() } } _getBalloonPositions(t) { const e = r.isSafari && r.isiOS; const n = e ? Kv({ heightOffset: Math.max(Gv.arrowHeightOffset, Math.round(20 / Za.window.visualViewport.scale)) }) : Gv.defaultPositions; return t ? [n.northWestArrowSouth, n.northWestArrowSouthWest, n.northWestArrowSouthEast, n.northWestArrowSouthMiddleEast, n.northWestArrowSouthMiddleWest, n.southWestArrowNorth, n.southWestArrowNorthWest, n.southWestArrowNorthEast, n.southWestArrowNorthMiddleWest, n.southWestArrowNorthMiddleEast] : [n.southEastArrowNorth, n.southEastArrowNorthEast, n.southEastArrowNorthWest, n.southEastArrowNorthMiddleEast, n.southEastArrowNorthMiddleWest, n.northEastArrowSouth, n.northEastArrowSouthEast, n.northEastArrowSouthWest, n.northEastArrowSouthMiddleEast, n.northEastArrowSouthMiddleWest] } } function dx(t, e) { if (t.rangeCount === 1) { return false } return [...t.getRanges()].every((t => { const n = t.getContainedElement(); return n && e.isSelectable(n) })) } var ux = n(6706); var hx = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; hx.insert = "head"; hx.singleton = true; var gx = Sl()(ux.Z, hx); const mx = ux.Z.locals || {}; const fx = dc("px"); class px extends wC { constructor(t) { super(t); const e = this.bindTemplate; this.isVisible = false; this.isToggleable = true; this.set("top", 0); this.set("left", 0); this.extendTemplate({ attributes: { class: "ck-block-toolbar-button", style: { top: e.to("top", (t => fx(t))), left: e.to("left", (t => fx(t))) } } }) } } const bx = dc("px"); const { pilcrow: kx } = v_; class wx extends wl { static get pluginName() { return "BlockToolbar" } constructor(t) { super(t); this._resizeObserver = null; this._blockToolbarConfig = ev(this.editor.config.get("blockToolbar")); this.toolbarView = this._createToolbarView(); this.panelView = this._createPanelView(); this.buttonView = this._createButtonView(); y_({ emitter: this.panelView, contextElements: [this.panelView.element, this.buttonView.element], activator: () => this.panelView.isVisible, callback: () => this._hidePanel() }) } init() { const t = this.editor; this.listenTo(t.model.document.selection, "change:range", ((t, e) => { if (e.directChange) { this._hidePanel() } })); this.listenTo(t.ui, "update", (() => this._updateButton())); this.listenTo(t, "change:isReadOnly", (() => this._updateButton()), { priority: "low" }); this.listenTo(t.ui.focusTracker, "change:isFocused", (() => this._updateButton())); this.listenTo(this.buttonView, "change:isVisible", ((t, e, n) => { if (n) { this.buttonView.listenTo(window, "resize", (() => this._updateButton())) } else { this.buttonView.stopListening(window, "resize"); this._hidePanel() } })); t.ui.addToolbar(this.toolbarView, { beforeFocus: () => this._showPanel(), afterBlur: () => this._hidePanel() }) } afterInit() { const t = this.editor.ui.componentFactory; const e = this._blockToolbarConfig; this.toolbarView.fillFromConfig(e, t); for (const t of this.toolbarView.items) { t.on("execute", (() => this._hidePanel(true)), { priority: "high" }) } if (!e.shouldNotGroupWhenFull) { this.listenTo(this.editor, "ready", (() => { const t = this.editor.ui.view.editable.element; this._resizeObserver = new cc(t, (() => { this.toolbarView.maxWidth = this._getToolbarMaxWidth() })) })) } } destroy() { super.destroy(); this.panelView.destroy(); this.buttonView.destroy(); this.toolbarView.destroy(); if (this._resizeObserver) { this._resizeObserver.destroy() } } _createToolbarView() { const t = this.editor.locale.t; const e = !this._blockToolbarConfig.shouldNotGroupWhenFull; const n = new cv(this.editor.locale, { shouldGroupWhenFull: e, isFloating: true }); n.ariaLabel = t("Editor block content toolbar"); n.focusTracker.on("change:isFocused", ((t, e, n) => { if (!n) { this._hidePanel() } })); return n } _createPanelView() { const t = this.editor; const e = new Gv(t.locale); e.content.add(this.toolbarView); e.class = "ck-toolbar-container"; t.ui.view.body.add(e); t.ui.focusTracker.add(e.element); this.toolbarView.keystrokes.set("Esc", ((t, e) => { this._hidePanel(true); e() })); return e } _createButtonView() { const t = this.editor; const e = t.t; const n = new px(t.locale); const i = n.bindTemplate; n.set({ label: e("Edit block"), icon: kx, withText: false }); n.extendTemplate({ on: { mousedown: i.to((t => { if (r.isSafari && this.panelView.isVisible) { this.toolbarView.focus() } t.preventDefault() })) } }); n.bind("isOn").to(this.panelView, "isVisible"); n.bind("tooltip").to(this.panelView, "isVisible", (t => !t)); this.listenTo(n, "execute", (() => { if (!this.panelView.isVisible) { this._showPanel() } else { this._hidePanel(true) } })); t.ui.view.body.add(n); t.ui.focusTracker.add(n.element); return n } _updateButton() { const t = this.editor; const e = t.model; const n = t.editing.view; if (!t.ui.focusTracker.isFocused) { this._hideButton(); return } if (t.isReadOnly) { this._hideButton(); return } const i = Array.from(e.document.selection.getSelectedBlocks())[0]; if (!i || Array.from(this.toolbarView.items).every((t => !t.isEnabled))) { this._hideButton(); return } const o = n.domConverter.mapViewToDom(t.editing.mapper.toViewElement(i)); this.buttonView.isVisible = true; this._attachButtonToElement(o); if (this.panelView.isVisible) { this._showPanel() } } _hideButton() { this.buttonView.isVisible = false } _showPanel() { if (!this.buttonView.isVisible) { return } const t = this.panelView.isVisible; this.panelView.show(); this.toolbarView.maxWidth = this._getToolbarMaxWidth(); this.panelView.pin({ target: this.buttonView.element, limiter: this.editor.ui.getEditableElement() }); if (!t) { this.toolbarView.items.get(0).focus() } } _hidePanel(t) { this.panelView.isVisible = false; if (t) { this.editor.editing.view.focus() } } _attachButtonToElement(t) { const e = window.getComputedStyle(t); const n = new oc(this.editor.ui.getEditableElement()); const i = parseInt(e.paddingTop, 10); const o = parseInt(e.lineHeight, 10) || parseInt(e.fontSize, 10) * 1.2; const r = pc({ element: this.buttonView.element, target: t, positions: [(t, e) => { let r; if (this.editor.locale.uiLanguageDirection === "ltr") { r = n.left - e.width } else { r = n.right } return { top: t.top + i + (o - e.height) / 2, left: r } }] }); this.buttonView.top = r.top; this.buttonView.left = r.left } _getToolbarMaxWidth() { const t = this.editor.ui.view.editable.element; const e = new oc(t); const n = new oc(this.buttonView.element); const i = this.editor.locale.uiLanguageDirection === "rtl"; const o = i ? n.left - e.right + n.width : e.left - n.left; return bx(e.width + o) } } class Ax { constructor(t) { this.crashes = []; this.state = "initializing"; this._now = Date.now; this.crashes = []; this._crashNumberLimit = typeof t.crashNumberLimit === "number" ? t.crashNumberLimit : 3; this._minimumNonErrorTimePeriod = typeof t.minimumNonErrorTimePeriod === "number" ? t.minimumNonErrorTimePeriod : 5e3; this._boundErrorHandler = t => { const e = "error" in t ? t.error : t.reason; if (e instanceof Error) { this._handleError(e, t) } }; this._listeners = {}; if (!this._restart) { throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. " + "Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.") } } destroy() { this._stopErrorHandling(); this._listeners = {} } on(t, e) { if (!this._listeners[t]) { this._listeners[t] = [] } this._listeners[t].push(e) } off(t, e) { this._listeners[t] = this._listeners[t].filter((t => t !== e)) } _fire(t, ...e) { const n = this._listeners[t] || []; for (const t of n) { t.apply(this, [null, ...e]) } } _startErrorHandling() { window.addEventListener("error", this._boundErrorHandler); window.addEventListener("unhandledrejection", this._boundErrorHandler) } _stopErrorHandling() { window.removeEventListener("error", this._boundErrorHandler); window.removeEventListener("unhandledrejection", this._boundErrorHandler) } _handleError(t, e) { if (this._shouldReactToError(t)) { this.crashes.push({ message: t.message, stack: t.stack, filename: e instanceof ErrorEvent ? e.filename : undefined, lineno: e instanceof ErrorEvent ? e.lineno : undefined, colno: e instanceof ErrorEvent ? e.colno : undefined, date: this._now() }); const n = this._shouldRestart(); this.state = "crashed"; this._fire("stateChange"); this._fire("error", { error: t, causesRestart: n }); if (n) { this._restart() } else { this.state = "crashedPermanently"; this._fire("stateChange") } } } _shouldReactToError(t) { return t.is && t.is("CKEditorError") && t.context !== undefined && t.context !== null && this.state === "ready" && this._isErrorComingFromThisItem(t) } _shouldRestart() { if (this.crashes.length <= this._crashNumberLimit) { return true } const t = this.crashes[this.crashes.length - 1].date; const e = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date; const n = (t - e) / this._crashNumberLimit; return n > this._minimumNonErrorTimePeriod } } function _x(t, e = new Set) { const n = [t]; const i = new Set; let o = 0; while (n.length > o) { const t = n[o++]; if (i.has(t) || !Cx(t) || e.has(t)) { continue } i.add(t); if (Symbol.iterator in t) { try { for (const e of t) { n.push(e) } } catch (t) { } } else { for (const e in t) { if (e === "defaultValue") { continue } n.push(t[e]) } } } return i } function Cx(t) { const e = Object.prototype.toString.call(t); const n = typeof t; return !(n === "number" || n === "boolean" || n === "string" || n === "symbol" || n === "function" || e === "[object Date]" || e === "[object RegExp]" || e === "[object Module]" || t === undefined || t === null || t._watchdogExcluded || t instanceof EventTarget || t instanceof Event) } function vx(t, e, n = new Set) { if (t === e && xx(t)) { return true } const i = _x(t, n); const o = _x(e, n); for (const t of i) { if (o.has(t)) { return true } } return false } function yx(t, e, n) { const { subNodes: i, prevNodeMap: o } = getSubNodes(t, n.subNodes); const { subNodes: r, prevNodeMap: s } = getSubNodes(e, n.subNodes); for (const n of i) { if (r.has(n)) { const i = []; i.push(n); let r = o.get(n); while (r && r !== t) { i.push(r); r = o.get(r) } r = s.get(n); while (r && r !== e) { i.unshift(r); r = s.get(r) } console.log("--------"); console.log({ target1: t }); console.log({ sharedNode: n }); console.log({ target2: e }); console.log({ connection: i }); return true } } return false } function xx(t) { return typeof t === "object" && t !== null } var Ex = "Expected a function"; function Dx(t, e, n) { var i = true, o = true; if (typeof t != "function") { throw new TypeError(Ex) } if (nt(n)) { i = "leading" in n ? !!n.leading : i; o = "trailing" in n ? !!n.trailing : o } return Yg(t, e, { leading: i, maxWait: e, trailing: o }) } const Sx = Dx; class Tx extends Ax { constructor(t, e = {}) { super(e); this._editor = null; this._throttledSave = Sx(this._save.bind(this), typeof e.saveInterval === "number" ? e.saveInterval : 5e3); if (t) { this._creator = (e, n) => t.create(e, n) } this._destructor = t => t.destroy() } get editor() { return this._editor } get _item() { return this._editor } setCreator(t) { this._creator = t } setDestructor(t) { this._destructor = t } _restart() { return Promise.resolve().then((() => { this.state = "initializing"; this._fire("stateChange"); return this._destroy() })).catch((t => { console.error("An error happened during the editor destroying.", t) })).then((() => { if (typeof this._elementOrData === "string") { return this.create(this._data, this._config, this._config.context) } else { const t = Object.assign({}, this._config, { initialData: this._data }); return this.create(this._elementOrData, t, t.context) } })).then((() => { this._fire("restart") })) } create(t = this._elementOrData, e = this._config, n) { return Promise.resolve().then((() => { super._startErrorHandling(); this._elementOrData = t; this._config = this._cloneEditorConfiguration(e) || {}; this._config.context = n; return this._creator(t, this._config) })).then((t => { this._editor = t; t.model.document.on("change:data", this._throttledSave); this._lastDocumentVersion = t.model.document.version; this._data = this._getData(); this.state = "ready"; this._fire("stateChange") })) } destroy() { return Promise.resolve().then((() => { this.state = "destroyed"; this._fire("stateChange"); super.destroy(); return this._destroy() })) } _destroy() { return Promise.resolve().then((() => { this._stopErrorHandling(); this._throttledSave.flush(); const t = this._editor; this._editor = null; t.model.document.off("change:data", this._throttledSave); return this._destructor(t) })) } _save() { const t = this._editor.model.document.version; try { this._data = this._getData(); this._lastDocumentVersion = t } catch (t) { console.error(t, "An error happened during restoring editor data. " + "Editor will be restored from the previously saved data.") } } _setExcludedProperties(t) { this._excludedProps = t } _getData() { const t = {}; for (const e of this._editor.model.document.getRootNames()) { t[e] = this._editor.data.get({ rootName: e }) } return t } _isErrorComingFromThisItem(t) { return vx(this._editor, t.context, this._excludedProps) } _cloneEditorConfiguration(t) { return Oa(t, ((t, e) => { if (Va(t)) { return t } if (e === "context") { return t } })) } } const Ix = Symbol("MainQueueId"); class Mx extends Ax { constructor(t, e = {}) { super(e); this._watchdogs = new Map; this._context = null; this._contextProps = new Set; this._actionQueues = new Bx; this._watchdogConfig = e; this._creator = e => t.create(e); this._destructor = t => t.destroy(); this._actionQueues.onEmpty((() => { if (this.state === "initializing") { this.state = "ready"; this._fire("stateChange") } })) } setCreator(t) { this._creator = t } setDestructor(t) { this._destructor = t } get context() { return this._context } create(t = {}) { return this._actionQueues.enqueue(Ix, (() => { this._contextConfig = t; return this._create() })) } getItem(t) { const e = this._getWatchdog(t); return e._item } getItemState(t) { const e = this._getWatchdog(t); return e.state } add(t) { const e = Lx(t); return Promise.all(e.map((t => this._actionQueues.enqueue(t.id, (() => { if (this.state === "destroyed") { throw new Error("Cannot add items to destroyed watchdog.") } if (!this._context) { throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.") } let e; if (this._watchdogs.has(t.id)) { throw new Error(`Item with the given id is already added: '${t.id}'.`) } if (t.type === "editor") { e = new Tx(null, this._watchdogConfig); e.setCreator(t.creator); e._setExcludedProperties(this._contextProps); if (t.destructor) { e.setDestructor(t.destructor) } this._watchdogs.set(t.id, e); e.on("error", ((n, { error: i, causesRestart: o }) => { this._fire("itemError", { itemId: t.id, error: i }); if (!o) { return } this._actionQueues.enqueue(t.id, (() => new Promise((n => { const i = () => { e.off("restart", i); this._fire("itemRestart", { itemId: t.id }); n() }; e.on("restart", i) })))) })); return e.create(t.sourceElementOrData, t.config, this._context) } else { throw new Error(`Not supported item type: '${t.type}'.`) } }))))) } remove(t) { const e = Lx(t); return Promise.all(e.map((t => this._actionQueues.enqueue(t, (() => { const e = this._getWatchdog(t); this._watchdogs.delete(t); return e.destroy() }))))) } destroy() { return this._actionQueues.enqueue(Ix, (() => { this.state = "destroyed"; this._fire("stateChange"); super.destroy(); return this._destroy() })) } _restart() { return this._actionQueues.enqueue(Ix, (() => { this.state = "initializing"; this._fire("stateChange"); return this._destroy().catch((t => { console.error("An error happened during destroying the context or items.", t) })).then((() => this._create())).then((() => this._fire("restart"))) })) } _create() { return Promise.resolve().then((() => { this._startErrorHandling(); return this._creator(this._contextConfig) })).then((t => { this._context = t; this._contextProps = _x(this._context); return Promise.all(Array.from(this._watchdogs.values()).map((t => { t._setExcludedProperties(this._contextProps); return t.create(undefined, undefined, this._context) }))) })) } _destroy() { return Promise.resolve().then((() => { this._stopErrorHandling(); const t = this._context; this._context = null; this._contextProps = new Set; return Promise.all(Array.from(this._watchdogs.values()).map((t => t.destroy()))).then((() => this._destructor(t))) })) } _getWatchdog(t) { const e = this._watchdogs.get(t); if (!e) { throw new Error(`Item with the given id was not registered: ${t}.`) } return e } _isErrorComingFromThisItem(t) { for (const e of this._watchdogs.values()) { if (e._isErrorComingFromThisItem(t)) { return false } } return vx(this._context, t.context) } } class Bx { constructor() { this._onEmptyCallbacks = []; this._queues = new Map; this._activeActions = 0 } onEmpty(t) { this._onEmptyCallbacks.push(t) } enqueue(t, e) { const n = t === Ix; this._activeActions++; if (!this._queues.get(t)) { this._queues.set(t, Promise.resolve()) } const i = n ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(Ix), this._queues.get(t)]); const o = i.then(e); const r = o.catch((() => { })); this._queues.set(t, r); return o.finally((() => { this._activeActions--; if (this._queues.get(t) === r && this._activeActions === 0) { this._onEmptyCallbacks.forEach((t => t())) } })) } } function Lx(t) { return Array.isArray(t) ? t : [t] } class Nx extends iy { constructor(t, e) { super(t); this.view = e } get element() { return this.view.editable.element } init() { const t = this.editor; const e = this.view; const n = t.editing.view; const i = e.editable; const o = n.document.getRoot(); i.name = o.rootName; e.render(); const r = i.element; this.setEditableElement(i.name, r); i.bind("isFocused").to(this.focusTracker); n.attachDomRoot(r); this._initPlaceholder(); this.fire("ready") } destroy() { super.destroy(); const t = this.view; const e = this.editor.editing.view; e.detachDomRoot(t.editable.name); t.destroy() } _initPlaceholder() { const t = this.editor; const e = t.editing.view; const n = e.document.getRoot(); const i = t.sourceElement; const o = t.config.get("placeholder"); if (o) { const t = typeof o === "string" ? o : o[n.rootName]; if (t) { Nl({ view: e, element: n, text: t, isDirectHost: false, keepOnFocus: true }) } } } } class zx extends ly { constructor(t, e, n) { super(t); const i = t.t; this.editable = new by(t, e, n, { label: t => i("Rich Text Editor. Editing area: %0", t.name) }) } render() { super.render(); this.registerChild(this.editable) } } class Px extends (VA(jA(PA))) { constructor(t, e = {}) { if (!Rx(t) && e.initialData !== undefined) { throw new I("editor-create-initial-data", null) } super(e); if (this.config.get("initialData") === undefined) { this.config.set("initialData", Ox(t)) } if (Rx(t)) { this.sourceElement = t; FA(this, t) } const n = this.config.get("plugins"); n.push(lx); this.config.set("plugins", n); this.config.define("balloonToolbar", this.config.get("toolbar")); this.model.document.createRoot(); const i = new zx(this.locale, this.editing.view, this.sourceElement); this.ui = new Nx(this, i); OA(this) } destroy() { const t = this.getData(); this.ui.destroy(); return super.destroy().then((() => { if (this.sourceElement) { this.updateSourceElement(t) } })) } static create(t, e = {}) { return new Promise((n => { if (Rx(t) && t.tagName === "TEXTAREA") { throw new I("editor-wrong-element", null) } const i = new this(t, e); n(i.initPlugins().then((() => i.ui.init())).then((() => i.data.init(i.config.get("initialData")))).then((() => i.fire("ready"))).then((() => i))) })) } } Px.Context = xl; Px.EditorWatchdog = Tx; Px.ContextWatchdog = Mx; function Ox(t) { return Rx(t) ? Xa(t) : t } function Rx(t) { return Va(t) } const Vx = ["left", "right", "center", "justify"]; function jx(t) { return Vx.includes(t) } function Fx(t, e) { if (e.contentLanguageDirection == "rtl") { return t === "right" } else { return t === "left" } } function Hx(t) { const e = t.map((t => { let e; if (typeof t == "string") { e = { name: t } } else { e = t } return e })).filter((t => { const e = Vx.includes(t.name); if (!e) { M("alignment-config-name-not-recognized", { option: t }) } return e })); const n = e.filter((t => Boolean(t.className))).length; if (n && n < e.length) { throw new I("alignment-config-classnames-are-missing", { configuredOptions: t }) } e.forEach(((e, n, i) => { const o = i.slice(n + 1); const r = o.some((t => t.name == e.name)); if (r) { throw new I("alignment-config-name-already-defined", { option: e, configuredOptions: t }) } if (e.className) { const n = o.some((t => t.className == e.className)); if (n) { throw new I("alignment-config-classname-already-defined", { option: e, configuredOptions: t }) } } })); return e } const Ux = "alignment"; class Wx extends _l { refresh() { const t = this.editor; const e = t.locale; const n = ol(this.editor.model.document.selection.getSelectedBlocks()); this.isEnabled = Boolean(n) && this._canBeAligned(n); if (this.isEnabled && n.hasAttribute("alignment")) { this.value = n.getAttribute("alignment") } else { this.value = e.contentLanguageDirection === "rtl" ? "right" : "left" } } execute(t = {}) { const e = this.editor; const n = e.locale; const i = e.model; const o = i.document; const r = t.value; i.change((t => { const e = Array.from(o.selection.getSelectedBlocks()).filter((t => this._canBeAligned(t))); const i = e[0].getAttribute("alignment"); const s = Fx(r, n) || i === r || !r; if (s) { qx(e, t) } else { Gx(e, t, r) } })) } _canBeAligned(t) { return this.editor.model.schema.checkAttribute(t, Ux) } } function qx(t, e) { for (const n of t) { e.removeAttribute(Ux, n) } } function Gx(t, e, n) { for (const i of t) { e.setAttribute(Ux, n, i) } } class $x extends wl { static get pluginName() { return "AlignmentEditing" } constructor(t) { super(t); t.config.define("alignment", { options: Vx.map((t => ({ name: t }))) }) } init() { const t = this.editor; const e = t.locale; const n = t.model.schema; const i = Hx(t.config.get("alignment.options")); const o = i.filter((t => jx(t.name) && !Fx(t.name, e))); const r = o.some((t => !!t.className)); n.extend("$block", { allowAttributes: "alignment" }); t.model.schema.setAttributeProperties("alignment", { isFormatting: true }); if (r) { t.conversion.attributeToAttribute(Zx(o)) } else { t.conversion.for("downcast").attributeToAttribute(Kx(o)) } const s = Yx(o); for (const e of s) { t.conversion.for("upcast").attributeToAttribute(e) } const a = Qx(o); for (const e of a) { t.conversion.for("upcast").attributeToAttribute(e) } t.commands.add("alignment", new Wx(t)) } } function Kx(t) { const e = {}; for (const { name: n } of t) { e[n] = { key: "style", value: { "text-align": n } } } const n = { model: { key: "alignment", values: t.map((t => t.name)) }, view: e }; return n } function Yx(t) { const e = []; for (const { name: n } of t) { e.push({ view: { key: "style", value: { "text-align": n } }, model: { key: "alignment", value: n } }) } return e } function Qx(t) { const e = []; for (const { name: n } of t) { e.push({ view: { key: "align", value: n }, model: { key: "alignment", value: n } }) } return e } function Zx(t) { const e = {}; for (const n of t) { e[n.name] = { key: "class", value: n.className } } const n = { model: { key: "alignment", values: t.map((t => t.name)) }, view: e }; return n } const Jx = new Map([["left", v_.alignLeft], ["right", v_.alignRight], ["center", v_.alignCenter], ["justify", v_.alignJustify]]); class Xx extends wl { get localizedOptionTitles() { const t = this.editor.t; return { left: t("Align left"), right: t("Align right"), center: t("Align center"), justify: t("Justify") } } static get pluginName() { return "AlignmentUI" } init() { const t = this.editor; const e = t.ui.componentFactory; const n = t.t; const i = Hx(t.config.get("alignment.options")); i.map((t => t.name)).filter(jx).forEach((t => this._addButton(t))); e.add("alignment", (o => { const r = Dv(o); Sv(r, (() => i.map((t => e.create(`alignment:${t.name}`)))), { enableActiveItemFocusOnDropdownOpen: true, isVertical: true, ariaLabel: n("Text alignment toolbar") }); r.buttonView.set({ label: n("Text alignment"), tooltip: true }); r.extendTemplate({ attributes: { class: "ck-alignment-dropdown" } }); const s = o.contentLanguageDirection === "rtl" ? Jx.get("right") : Jx.get("left"); const a = t.commands.get("alignment"); r.buttonView.bind("icon").to(a, "value", (t => Jx.get(t) || s)); r.bind("isEnabled").to(a, "isEnabled"); this.listenTo(r, "execute", (() => { t.editing.view.focus() })); return r })) } _addButton(t) { const e = this.editor; e.ui.componentFactory.add(`alignment:${t}`, (n => { const i = e.commands.get("alignment"); const o = new wC(n); o.set({ label: this.localizedOptionTitles[t], icon: Jx.get(t), tooltip: true, isToggleable: true }); o.bind("isEnabled").to(i); o.bind("isOn").to(i, "value", (e => e === t)); this.listenTo(o, "execute", (() => { e.execute("alignment", { value: t }); e.editing.view.focus() })); return o })) } } class tE extends wl { static get requires() { return [$x, Xx] } static get pluginName() { return "Alignment" } } class eE extends Sg { constructor(t) { super(t); this.domEventType = ["paste", "copy", "cut", "drop", "dragover", "dragstart", "dragend", "dragenter", "dragleave"]; const e = this.document; this.listenTo(e, "paste", n("clipboardInput"), { priority: "low" }); this.listenTo(e, "drop", n("clipboardInput"), { priority: "low" }); this.listenTo(e, "dragover", n("dragging"), { priority: "low" }); function n(t) { return (n, i) => { i.preventDefault(); const o = i.dropRange ? [i.dropRange] : null; const r = new v(e, t); e.fire(r, { dataTransfer: i.dataTransfer, method: n.name, targetRanges: o, target: i.target }); if (r.stop.called) { i.stopPropagation() } } } } onDomEvent(t) { const e = "clipboardData" in t ? t.clipboardData : t.dataTransfer; const n = t.type == "drop" || t.type == "paste"; const i = { dataTransfer: new ef(e, { cacheFiles: n }) }; if (t.type == "drop" || t.type == "dragover") { i.dropRange = nE(this.view, t) } this.fire(t.type, t, i) } } function nE(t, e) { const n = e.target.ownerDocument; const i = e.clientX; const o = e.clientY; let r; if (n.caretRangeFromPoint && n.caretRangeFromPoint(i, o)) { r = n.caretRangeFromPoint(i, o) } else if (e.rangeParent) { r = n.createRange(); r.setStart(e.rangeParent, e.rangeOffset); r.collapse(true) } if (r) { return t.domConverter.domRangeToView(r) } return null } function iE(t) { t = t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;"); if (t.includes("</p><p>") || t.includes("<br>")) { t = `<p>${t}</p>` } return t } function oE(t) { return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, ((t, e) => { if (e.length == 1) { return " " } return e })).replace(/<!--[\s\S]*?-->/g, "") } const rE = ["figcaption", "li"]; function sE(t) { let e = ""; if (t.is("$text") || t.is("$textProxy")) { e = t.data } else if (t.is("element", "img") && t.hasAttribute("alt")) { e = t.getAttribute("alt") } else if (t.is("element", "br")) { e = "\n" } else { let n = null; for (const i of t.getChildren()) { const t = sE(i); if (n && (n.is("containerElement") || i.is("containerElement"))) { if (rE.includes(n.name) || rE.includes(i.name)) { e += "\n" } else { e += "\n\n" } } e += t; n = i } } return e } class aE extends wl { static get pluginName() { return "ClipboardPipeline" } init() { const t = this.editor; const e = t.editing.view; e.addObserver(eE); this._setupPasteDrop(); this._setupCopyCut() } _setupPasteDrop() { const t = this.editor; const e = t.model; const n = t.editing.view; const i = n.document; this.listenTo(i, "clipboardInput", (e => { if (t.isReadOnly) { e.stop() } }), { priority: "highest" }); this.listenTo(i, "clipboardInput", ((t, e) => { const i = e.dataTransfer; let o; if (e.content) { o = e.content } else { let t = ""; if (i.getData("text/html")) { t = oE(i.getData("text/html")) } else if (i.getData("text/plain")) { t = iE(i.getData("text/plain")) } o = this.editor.data.htmlProcessor.toView(t) } const r = new v(this, "inputTransformation"); this.fire(r, { content: o, dataTransfer: i, targetRanges: e.targetRanges, method: e.method }); if (r.stop.called) { t.stop() } n.scrollToTheSelection() }), { priority: "low" }); this.listenTo(this, "inputTransformation", ((t, n) => { if (n.content.isEmpty) { return } const i = this.editor.data; const o = i.toModel(n.content, "$clipboardHolder"); if (o.childCount == 0) { return } t.stop(); e.change((() => { this.fire("contentInsertion", { content: o, method: n.method, dataTransfer: n.dataTransfer, targetRanges: n.targetRanges }) })) }), { priority: "low" }); this.listenTo(this, "contentInsertion", ((t, n) => { n.resultRange = e.insertContent(n.content) }), { priority: "low" }) } _setupCopyCut() { const t = this.editor; const e = t.model.document; const n = t.editing.view; const i = n.document; const o = (n, o) => { const r = o.dataTransfer; o.preventDefault(); const s = t.data.toView(t.model.getSelectedContent(e.selection)); i.fire("clipboardOutput", { dataTransfer: r, content: s, method: n.name }) }; this.listenTo(i, "copy", o, { priority: "low" }); this.listenTo(i, "cut", ((e, n) => { if (t.isReadOnly) { n.preventDefault() } else { o(e, n) } }), { priority: "low" }); this.listenTo(i, "clipboardOutput", ((n, i) => { if (!i.content.isEmpty) { i.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(i.content)); i.dataTransfer.setData("text/plain", sE(i.content)) } if (i.method == "cut") { t.model.deleteContent(e.selection) } }), { priority: "low" }) } } class cE { constructor(t, e = 20) { this._batch = null; this.model = t; this._size = 0; this.limit = e; this._isLocked = false; this._changeCallback = (t, e) => { if (e.isLocal && e.isUndoable && e !== this._batch) { this._reset(true) } }; this._selectionChangeCallback = () => { this._reset() }; this.model.document.on("change", this._changeCallback); this.model.document.selection.on("change:range", this._selectionChangeCallback); this.model.document.selection.on("change:attribute", this._selectionChangeCallback) } get batch() { if (!this._batch) { this._batch = this.model.createBatch({ isTyping: true }) } return this._batch } get size() { return this._size } input(t) { this._size += t; if (this._size >= this.limit) { this._reset(true) } } get isLocked() { return this._isLocked } lock() { this._isLocked = true } unlock() { this._isLocked = false } destroy() { this.model.document.off("change", this._changeCallback); this.model.document.selection.off("change:range", this._selectionChangeCallback); this.model.document.selection.off("change:attribute", this._selectionChangeCallback) } _reset(t = false) { if (!this.isLocked || t) { this._batch = null; this._size = 0 } } } class lE extends _l { constructor(t, e) { super(t); this._buffer = new cE(t.model, e) } get buffer() { return this._buffer } destroy() { super.destroy(); this._buffer.destroy() } execute(t = {}) { const e = this.editor.model; const n = e.document; const i = t.text || ""; const o = i.length; let r = n.selection; if (t.selection) { r = t.selection } else if (t.range) { r = e.createSelection(t.range) } const s = t.resultRange; e.enqueueChange(this._buffer.batch, (t => { this._buffer.lock(); e.deleteContent(r); if (i) { e.insertContent(t.createText(i, n.selection.getAttributes()), r) } if (s) { t.setSelection(s) } else if (!r.is("documentSelection")) { t.setSelection(r) } this._buffer.unlock(); this._buffer.input(o) })) } } const dE = ["insertText", "insertReplacementText"]; class uE extends yg { constructor(t) { super(t); if (r.isAndroid) { dE.push("insertCompositionText") } const e = t.document; e.on("beforeinput", ((n, i) => { if (!this.isEnabled) { return } const { data: o, targetRanges: r, inputType: s, domEvent: a } = i; if (!dE.includes(s)) { return } const c = new v(e, "insertText"); e.fire(c, new Dg(t, a, { text: o, selection: t.createSelection(r) })); if (c.stop.called) { n.stop() } })); e.on("compositionend", ((n, { data: i, domEvent: o }) => { if (!this.isEnabled || r.isAndroid) { return } if (!i) { return } e.fire("insertText", new Dg(t, o, { text: i, selection: e.selection })) }), { priority: "lowest" }) } observe() { } stopObserving() { } } class hE extends wl { static get pluginName() { return "Input" } init() { const t = this.editor; const e = t.model; const n = t.editing.view; const i = e.document.selection; n.addObserver(uE); const o = new lE(t, t.config.get("typing.undoStep") || 20); t.commands.add("insertText", o); t.commands.add("input", o); this.listenTo(n.document, "insertText", ((i, o) => { if (!n.document.isComposing) { o.preventDefault() } const { text: s, selection: a, resultRange: c } = o; const l = Array.from(a.getRanges()).map((e => t.editing.mapper.toModelRange(e))); let d = s; if (r.isAndroid) { const t = Array.from(l[0].getItems()).reduce(((t, e) => t + (e.is("$textProxy") ? e.data : "")), ""); if (t) { if (t.length <= d.length) { if (d.startsWith(t)) { d = d.substring(t.length); l[0].start = l[0].start.getShiftedBy(t.length) } } else { if (t.startsWith(d)) { l[0].start = l[0].start.getShiftedBy(d.length); d = "" } } } } const u = { text: d, selection: e.createSelection(l) }; if (c) { u.resultRange = t.editing.mapper.toModelRange(c) } t.execute("insertText", u) })); if (r.isAndroid) { this.listenTo(n.document, "keydown", ((t, r) => { if (i.isCollapsed || r.keyCode != 229 || !n.document.isComposing) { return } gE(e, o) })) } else { this.listenTo(n.document, "compositionstart", (() => { if (i.isCollapsed) { return } gE(e, o) })) } } } function gE(t, e) { if (!e.isEnabled) { return } const n = e.buffer; n.lock(); t.enqueueChange(n.batch, (() => { t.deleteContent(t.document.selection) })); n.unlock() } class mE extends _l { constructor(t, e) { super(t); this.direction = e; this._buffer = new cE(t.model, t.config.get("typing.undoStep")) } get buffer() { return this._buffer } execute(t = {}) { const e = this.editor.model; const n = e.document; e.enqueueChange(this._buffer.batch, (i => { this._buffer.lock(); const o = i.createSelection(t.selection || n.selection); const r = t.sequence || 1; const s = o.isCollapsed; if (o.isCollapsed) { e.modifySelection(o, { direction: this.direction, unit: t.unit, treatEmojiAsSingleUnit: true }) } if (this._shouldEntireContentBeReplacedWithParagraph(r)) { this._replaceEntireContentWithParagraph(i); return } if (this._shouldReplaceFirstBlockWithParagraph(o, r)) { this.editor.execute("paragraph", { selection: o }); return } if (o.isCollapsed) { return } let a = 0; o.getFirstRange().getMinimalFlatRanges().forEach((t => { a += At(t.getWalker({ singleCharacters: true, ignoreElementEnd: true, shallow: true })) })); e.deleteContent(o, { doNotResetEntireContent: s, direction: this.direction }); this._buffer.input(a); i.setSelection(o); this._buffer.unlock() })) } _shouldEntireContentBeReplacedWithParagraph(t) { if (t > 1) { return false } const e = this.editor.model; const n = e.document; const i = n.selection; const o = e.schema.getLimitElement(i); const r = i.isCollapsed && i.containsEntireContent(o); if (!r) { return false } if (!e.schema.checkChild(o, "paragraph")) { return false } const s = o.getChild(0); if (s && s.is("element", "paragraph")) { return false } return true } _replaceEntireContentWithParagraph(t) { const e = this.editor.model; const n = e.document; const i = n.selection; const o = e.schema.getLimitElement(i); const r = t.createElement("paragraph"); t.remove(t.createRangeIn(o)); t.insert(r, o); t.setSelection(r, 0) } _shouldReplaceFirstBlockWithParagraph(t, e) { const n = this.editor.model; if (e > 1 || this.direction != "backward") { return false } if (!t.isCollapsed) { return false } const i = t.getFirstPosition(); const o = n.schema.getLimitElement(i); const r = o.getChild(0); if (i.parent != r) { return false } if (!t.containsEntireContent(r)) { return false } if (!n.schema.checkChild(o, "paragraph")) { return false } if (r.name == "paragraph") { return false } return true } } const fE = "character"; const pE = "word"; const bE = "codePoint"; const kE = "selection"; const wE = "backward"; const AE = "forward"; const _E = { deleteContent: { unit: kE, direction: wE }, deleteContentBackward: { unit: bE, direction: wE }, deleteWordBackward: { unit: pE, direction: wE }, deleteHardLineBackward: { unit: kE, direction: wE }, deleteSoftLineBackward: { unit: kE, direction: wE }, deleteContentForward: { unit: fE, direction: AE }, deleteWordForward: { unit: pE, direction: AE }, deleteHardLineForward: { unit: kE, direction: AE }, deleteSoftLineForward: { unit: kE, direction: AE } }; class CE extends yg { constructor(t) { super(t); const e = t.document; let n = 0; e.on("keydown", (() => { n++ })); e.on("keyup", (() => { n = 0 })); e.on("beforeinput", ((i, o) => { if (!this.isEnabled) { return } const { targetRanges: s, domEvent: a, inputType: c } = o; const l = _E[c]; if (!l) { return } const d = { direction: l.direction, unit: l.unit, sequence: n }; if (d.unit == kE) { d.selectionToRemove = t.createSelection(s[0]) } if (c === "deleteContentBackward") { if (r.isAndroid) { d.sequence = 1 } if (yE(s)) { d.unit = kE; d.selectionToRemove = t.createSelection(s) } } const u = new ch(e, "delete", s[0]); e.fire(u, new Dg(t, a, d)); if (u.stop.called) { i.stop() } })); if (r.isBlink) { vE(this) } } observe() { } stopObserving() { } } function vE(t) { const e = t.view; const n = e.document; let i = null; let o = false; n.on("keydown", ((t, { keyCode: e }) => { i = e; o = false })); n.on("keyup", ((a, { keyCode: c, domEvent: l }) => { const d = n.selection; const u = t.isEnabled && c == i && r(c) && !d.isCollapsed && !o; i = null; if (u) { const t = d.getFirstRange(); const i = new ch(n, "delete", t); const o = { unit: kE, direction: s(c), selectionToRemove: d }; n.fire(i, new Dg(e, l, o)) } })); n.on("beforeinput", ((t, { inputType: e }) => { const n = _E[e]; const a = r(i) && n && n.direction == s(i); if (a) { o = true } }), { priority: "high" }); n.on("beforeinput", ((t, { inputType: e, data: n }) => { const o = i == Pc["delete"] && e == "insertText" && n == ""; if (o) { t.stop() } }), { priority: "high" }); function r(t) { return t == Pc.backspace || t == Pc["delete"] } function s(t) { return t == Pc.backspace ? wE : AE } } function yE(t) { if (t.length != 1 || t[0].isCollapsed) { return false } const e = t[0].getWalker({ direction: "backward", singleCharacters: true, ignoreElementEnd: true }); let n = 0; for (const { nextPosition: t } of e) { if (!t.parent.is("$text")) { n++ } else { const e = t.parent.data; const i = t.offset; if (ml(e, i) || fl(e, i) || bl(e, i)) { continue } n++ } if (n > 1) { return true } } return false } class xE extends wl { static get pluginName() { return "Delete" } init() { const t = this.editor; const e = t.editing.view; const n = e.document; const i = t.model.document; e.addObserver(CE); this._undoOnBackspace = false; const o = new mE(t, "forward"); t.commands.add("deleteForward", o); t.commands.add("forwardDelete", o); t.commands.add("delete", new mE(t, "backward")); this.listenTo(n, "delete", ((i, o) => { if (!n.isComposing) { o.preventDefault() } const { direction: r, sequence: s, selectionToRemove: a, unit: c } = o; const l = r === "forward" ? "deleteForward" : "delete"; const d = { sequence: s }; if (c == "selection") { const e = Array.from(a.getRanges()).map((e => t.editing.mapper.toModelRange(e))); d.selection = t.model.createSelection(e) } else { d.unit = c } t.execute(l, d); e.scrollToTheSelection() }), { priority: "low" }); if (this.editor.plugins.has("UndoEditing")) { this.listenTo(n, "delete", ((e, n) => { if (this._undoOnBackspace && n.direction == "backward" && n.sequence == 1 && n.unit == "codePoint") { this._undoOnBackspace = false; t.execute("undo"); n.preventDefault(); e.stop() } }), { context: "$capture" }); this.listenTo(i, "change", (() => { this._undoOnBackspace = false })) } } requestUndoOnBackspace() { if (this.editor.plugins.has("UndoEditing")) { this._undoOnBackspace = true } } } class EE extends wl { static get requires() { return [hE, xE] } static get pluginName() { return "Typing" } } function DE(t, e) { let n = t.start; const i = Array.from(t.getItems()).reduce(((t, i) => { if (!(i.is("$text") || i.is("$textProxy"))) { n = e.createPositionAfter(i); return "" } return t + i.data }), ""); return { text: i, range: e.createRange(n, t.end) } } class SE extends (lt()) { constructor(t, e) { super(); this.model = t; this.testCallback = e; this._hasMatch = false; this.set("isEnabled", true); this.on("change:isEnabled", (() => { if (this.isEnabled) { this._startListening() } else { this.stopListening(t.document.selection); this.stopListening(t.document) } })); this._startListening() } get hasMatch() { return this._hasMatch } _startListening() { const t = this.model; const e = t.document; this.listenTo(e.selection, "change:range", ((t, { directChange: n }) => { if (!n) { return } if (!e.selection.isCollapsed) { if (this.hasMatch) { this.fire("unmatched"); this._hasMatch = false } return } this._evaluateTextBeforeSelection("selection") })); this.listenTo(e, "change:data", ((t, e) => { if (e.isUndo || !e.isLocal) { return } this._evaluateTextBeforeSelection("data", { batch: e }) })) } _evaluateTextBeforeSelection(t, e = {}) { const n = this.model; const i = n.document; const o = i.selection; const r = n.createRange(n.createPositionAt(o.focus.parent, 0), o.focus); const { text: s, range: a } = DE(r, n); const c = this.testCallback(s); if (!c && this.hasMatch) { this.fire("unmatched") } this._hasMatch = !!c; if (c) { const n = Object.assign(e, { text: s, range: a }); if (typeof c == "object") { Object.assign(n, c) } this.fire(`matched:${t}`, n) } } } class TE extends wl { static get pluginName() { return "TwoStepCaretMovement" } constructor(t) { super(t); this.attributes = new Set; this._overrideUid = null } init() { const t = this.editor; const e = t.model; const n = t.editing.view; const i = t.locale; const o = e.document.selection; this.listenTo(n.document, "arrowKey", ((t, e) => { if (!o.isCollapsed) { return } if (e.shiftKey || e.altKey || e.ctrlKey) { return } const n = e.keyCode == Pc.arrowright; const r = e.keyCode == Pc.arrowleft; if (!n && !r) { return } const s = i.contentLanguageDirection; let a = false; if (s === "ltr" && n || s === "rtl" && r) { a = this._handleForwardMovement(e) } else { a = this._handleBackwardMovement(e) } if (a === true) { t.stop() } }), { context: "$text", priority: "highest" }); this._isNextGravityRestorationSkipped = false; this.listenTo(o, "change:range", ((t, e) => { if (this._isNextGravityRestorationSkipped) { this._isNextGravityRestorationSkipped = false; return } if (!this._isGravityOverridden) { return } if (!e.directChange && NE(o.getFirstPosition(), this.attributes)) { return } this._restoreGravity() })) } registerAttribute(t) { this.attributes.add(t) } _handleForwardMovement(t) { const e = this.attributes; const n = this.editor.model; const i = n.document.selection; const o = i.getFirstPosition(); if (this._isGravityOverridden) { return false } if (o.isAtStart && IE(i, e)) { return false } if (NE(o, e)) { BE(t); this._overrideGravity(); return true } return false } _handleBackwardMovement(t) { const e = this.attributes; const n = this.editor.model; const i = n.document.selection; const o = i.getFirstPosition(); if (this._isGravityOverridden) { BE(t); this._restoreGravity(); ME(n, e, o); return true } else { if (o.isAtStart) { if (IE(i, e)) { BE(t); ME(n, e, o); return true } return false } if (LE(o, e)) { if (o.isAtEnd && !IE(i, e) && NE(o, e)) { BE(t); ME(n, e, o); return true } this._isNextGravityRestorationSkipped = true; this._overrideGravity(); return false } } return false } get _isGravityOverridden() { return !!this._overrideUid } _overrideGravity() { this._overrideUid = this.editor.model.change((t => t.overrideSelectionGravity())) } _restoreGravity() { this.editor.model.change((t => { t.restoreSelectionGravity(this._overrideUid); this._overrideUid = null })) } } function IE(t, e) { for (const n of e) { if (t.hasAttribute(n)) { return true } } return false } function ME(t, e, n) { const i = n.nodeBefore; t.change((t => { if (i) { t.setSelectionAttribute(i.getAttributes()) } else { t.removeSelectionAttribute(e) } })) } function BE(t) { t.preventDefault() } function LE(t, e) { const n = t.getShiftedBy(-1); return NE(n, e) } function NE(t, e) { const { nodeBefore: n, nodeAfter: i } = t; for (const t of e) { const e = n ? n.getAttribute(t) : undefined; const o = i ? i.getAttribute(t) : undefined; if (o !== e) { return true } } return false } var zE = /[\\^$.*+?()[\]{}|]/g, PE = RegExp(zE.source); function OE(t) { t = Id(t); return t && PE.test(t) ? t.replace(zE, "\\$&") : t } const RE = OE; const VE = { copyright: { from: "(c)", to: "©" }, registeredTrademark: { from: "(r)", to: "®" }, trademark: { from: "(tm)", to: "™" }, oneHalf: { from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "½", null] }, oneThird: { from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "⅓", null] }, twoThirds: { from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "⅔", null] }, oneForth: { from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "¼", null] }, threeQuarters: { from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "¾", null] }, lessThanOrEqual: { from: "<=", to: "≤" }, greaterThanOrEqual: { from: ">=", to: "≥" }, notEqual: { from: "!=", to: "≠" }, arrowLeft: { from: "<-", to: "←" }, arrowRight: { from: "->", to: "→" }, horizontalEllipsis: { from: "...", to: "…" }, enDash: { from: /(^| )(--)( )$/, to: [null, "–", null] }, emDash: { from: /(^| )(---)( )$/, to: [null, "—", null] }, quotesPrimary: { from: GE('"'), to: [null, "“", null, "”"] }, quotesSecondary: { from: GE("'"), to: [null, "‘", null, "’"] }, quotesPrimaryEnGb: { from: GE("'"), to: [null, "‘", null, "’"] }, quotesSecondaryEnGb: { from: GE('"'), to: [null, "“", null, "”"] }, quotesPrimaryPl: { from: GE('"'), to: [null, "„", null, "”"] }, quotesSecondaryPl: { from: GE("'"), to: [null, "‚", null, "’"] } }; const jE = { symbols: ["copyright", "registeredTrademark", "trademark"], mathematical: ["oneHalf", "oneThird", "twoThirds", "oneForth", "threeQuarters", "lessThanOrEqual", "greaterThanOrEqual", "notEqual", "arrowLeft", "arrowRight"], typography: ["horizontalEllipsis", "enDash", "emDash"], quotes: ["quotesPrimary", "quotesSecondary"] }; const FE = ["symbols", "mathematical", "typography", "quotes"]; class HE extends wl { static get requires() { return ["Delete", "Input"] } static get pluginName() { return "TextTransformation" } constructor(t) { super(t); t.config.define("typing", { transformations: { include: FE } }) } init() { const t = this.editor.model; const e = t.document.selection; e.on("change:range", (() => { this.isEnabled = !e.anchor.parent.is("element", "codeBlock") })); this._enableTransformationWatchers() } _enableTransformationWatchers() { const t = this.editor; const e = t.model; const n = t.plugins.get("Delete"); const i = $E(t.config.get("typing.transformations")); const o = t => { for (const e of i) { const n = e.from; const i = n.test(t); if (i) { return { normalizedTransformation: e } } } }; const r = new SE(t.model, o); r.on("matched:data", ((t, i) => { if (!i.batch.isTyping) { return } const { from: o, to: r } = i.normalizedTransformation; const s = o.exec(i.text); const a = r(s.slice(1)); const c = i.range; let l = s.index; e.enqueueChange((t => { for (let n = 1; n < s.length; n++) { const i = s[n]; const o = a[n - 1]; if (o == null) { l += i.length; continue } const r = c.start.getShiftedBy(l); const d = e.createRange(r, r.getShiftedBy(i.length)); const u = qE(r); e.insertContent(t.createText(o, u), d); l += o.length } e.enqueueChange((() => { n.requestUndoOnBackspace() })) })) })); r.bind("isEnabled").to(this) } } function UE(t) { if (typeof t == "string") { return new RegExp(`(${RE(t)})$`) } return t } function WE(t) { if (typeof t == "string") { return () => [t] } else if (t instanceof Array) { return () => t } return t } function qE(t) { const e = t.textNode ? t.textNode : t.nodeAfter; return e.getAttributes() } function GE(t) { return new RegExp(`(^|\\s)(${t})([^${t}]*)(${t})$`) } function $E(t) { const e = t.extra || []; const n = t.remove || []; const i = t => !n.includes(t); const o = t.include.concat(e).filter(i); return KE(o).filter(i).map((t => typeof t == "string" && VE[t] ? VE[t] : t)).filter((t => typeof t === "object")).map((t => ({ from: UE(t.from), to: WE(t.to) }))) } function KE(t) { const e = new Set; for (const n of t) { if (typeof n == "string" && jE[n]) { for (const t of jE[n]) { e.add(t) } } else { e.add(n) } } return Array.from(e) } function YE(t, e, n, i) { return i.createRange(QE(t, e, n, true, i), QE(t, e, n, false, i)) } function QE(t, e, n, i, o) { let r = t.textNode || (i ? t.nodeBefore : t.nodeAfter); let s = null; while (r && r.getAttribute(e) == n) { s = r; r = i ? r.previousSibling : r.nextSibling } return s ? o.createPositionAt(s, i ? "before" : "after") : t } function ZE(t, e, n, i) { const o = t.editing.view; const r = new Set; o.document.registerPostFixer((o => { const s = t.model.document.selection; let a = false; if (s.hasAttribute(e)) { const c = YE(s.getFirstPosition(), e, s.getAttribute(e), t.model); const l = t.editing.mapper.toViewRange(c); for (const t of l.getItems()) { if (t.is("element", n) && !t.hasClass(i)) { o.addClass(i, t); r.add(t); a = true } } } return a })); t.conversion.for("editingDowncast").add((t => { t.on("insert", e, { priority: "highest" }); t.on("remove", e, { priority: "highest" }); t.on("attribute", e, { priority: "highest" }); t.on("selection", e, { priority: "highest" }); function e() { o.change((t => { for (const e of r.values()) { t.removeClass(i, e); r.delete(e) } })) } })) } function* JE(t, e) { for (const n of e) { if (n && t.getAttributeProperties(n[0]).copyOnEnter) { yield n } } } class XE extends _l { execute() { this.editor.model.change((t => { this.enterBlock(t); this.fire("afterExecute", { writer: t }) })) } enterBlock(t) { const e = this.editor.model; const n = e.document.selection; const i = e.schema; const o = n.isCollapsed; const r = n.getFirstRange(); const s = r.start.parent; const a = r.end.parent; if (i.isLimit(s) || i.isLimit(a)) { if (!o && s == a) { e.deleteContent(n) } return false } if (o) { const e = JE(t.model.schema, n.getAttributes()); tD(t, r.start); t.setSelectionAttribute(e); return true } else { const i = !(r.start.isAtStart && r.end.isAtEnd); const o = s == a; e.deleteContent(n, { leaveUnmerged: i }); if (i) { if (o) { tD(t, n.focus); return true } else { t.setSelection(a, 0) } } } return false } } function tD(t, e) { t.split(e); t.setSelection(e.parent.nextSibling, 0) } const eD = { insertParagraph: { isSoft: false }, insertLineBreak: { isSoft: true } }; class nD extends yg { constructor(t) { super(t); const e = this.document; let n = false; e.on("keydown", ((t, e) => { n = e.shiftKey })); e.on("beforeinput", ((i, o) => { if (!this.isEnabled) { return } let s = o.inputType; if (r.isSafari && n && s == "insertParagraph") { s = "insertLineBreak" } const a = o.domEvent; const c = eD[s]; if (!c) { return } const l = new ch(e, "enter", o.targetRanges[0]); e.fire(l, new Dg(t, a, { isSoft: c.isSoft })); if (l.stop.called) { i.stop() } })) } observe() { } stopObserving() { } } class iD extends wl { static get pluginName() { return "Enter" } init() { const t = this.editor; const e = t.editing.view; const n = e.document; e.addObserver(nD); t.commands.add("enter", new XE(t)); this.listenTo(n, "enter", ((i, o) => { if (!n.isComposing) { o.preventDefault() } if (o.isSoft) { return } t.execute("enter"); e.scrollToTheSelection() }), { priority: "low" }) } } class oD extends _l { execute() { const t = this.editor.model; const e = t.document; t.change((n => { sD(t, n, e.selection); this.fire("afterExecute", { writer: n }) })) } refresh() { const t = this.editor.model; const e = t.document; this.isEnabled = rD(t.schema, e.selection) } } function rD(t, e) { if (e.rangeCount > 1) { return false } const n = e.anchor; if (!n || !t.checkChild(n, "softBreak")) { return false } const i = e.getFirstRange(); const o = i.start.parent; const r = i.end.parent; if ((cD(o, t) || cD(r, t)) && o !== r) { return false } return true } function sD(t, e, n) { const i = n.isCollapsed; const o = n.getFirstRange(); const r = o.start.parent; const s = o.end.parent; const a = r == s; if (i) { const i = JE(t.schema, n.getAttributes()); aD(t, e, o.end); e.removeSelectionAttribute(n.getAttributeKeys()); e.setSelectionAttribute(i) } else { const i = !(o.start.isAtStart && o.end.isAtEnd); t.deleteContent(n, { leaveUnmerged: i }); if (a) { aD(t, e, n.focus) } else { if (i) { e.setSelection(s, 0) } } } } function aD(t, e, n) { const i = e.createElement("softBreak"); t.insertContent(i, n); e.setSelection(i, "after") } function cD(t, e) { if (t.is("rootElement")) { return false } return e.isLimit(t) || cD(t.parent, e) } class lD extends wl { static get pluginName() { return "ShiftEnter" } init() { const t = this.editor; const e = t.model.schema; const n = t.conversion; const i = t.editing.view; const o = i.document; e.register("softBreak", { allowWhere: "$text", isInline: true }); n.for("upcast").elementToElement({ model: "softBreak", view: "br" }); n.for("downcast").elementToElement({ model: "softBreak", view: (t, { writer: e }) => e.createEmptyElement("br") }); i.addObserver(nD); t.commands.add("shiftEnter", new oD(t)); this.listenTo(o, "enter", ((e, n) => { if (!o.isComposing) { n.preventDefault() } if (!n.isSoft) { return } t.execute("shiftEnter"); i.scrollToTheSelection() }), { priority: "low" }) } } class dD extends (U()) { constructor() { super(...arguments); this._stack = [] } add(t, e) { const n = this._stack; const i = n[0]; this._insertDescriptor(t); const o = n[0]; if (i !== o && !uD(i, o)) { this.fire("change:top", { oldDescriptor: i, newDescriptor: o, writer: e }) } } remove(t, e) { const n = this._stack; const i = n[0]; this._removeDescriptor(t); const o = n[0]; if (i !== o && !uD(i, o)) { this.fire("change:top", { oldDescriptor: i, newDescriptor: o, writer: e }) } } _insertDescriptor(t) { const e = this._stack; const n = e.findIndex((e => e.id === t.id)); if (uD(t, e[n])) { return } if (n > -1) { e.splice(n, 1) } let i = 0; while (e[i] && hD(e[i], t)) { i++ } e.splice(i, 0, t) } _removeDescriptor(t) { const e = this._stack; const n = e.findIndex((e => e.id === t)); if (n > -1) { e.splice(n, 1) } } } function uD(t, e) { return t && e && t.priority == e.priority && gD(t.classes) == gD(e.classes) } function hD(t, e) { if (t.priority > e.priority) { return true } else if (t.priority < e.priority) { return false } return gD(t.classes) > gD(e.classes) } function gD(t) { return Array.isArray(t) ? t.sort().join(",") : t } const mD = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>'; const fD = "ck-widget"; const pD = "ck-widget_selected"; function bD(t) { if (!t.is("element")) { return false } return !!t.getCustomProperty("widget") } function kD(t, e, n = {}) { if (!t.is("containerElement")) { throw new I("widget-to-widget-wrong-element-type", null, { element: t }) } e.setAttribute("contenteditable", "false", t); e.addClass(fD, t); e.setCustomProperty("widget", true, t); t.getFillerOffset = DD; e.setCustomProperty("widgetLabel", [], t); if (n.label) { CD(t, n.label) } if (n.hasSelectionHandle) { SD(t, e) } _D(t, e); return t } function wD(t, e, n) { if (e.classes) { n.addClass($c(e.classes), t) } if (e.attributes) { for (const i in e.attributes) { n.setAttribute(i, e.attributes[i], t) } } } function AD(t, e, n) { if (e.classes) { n.removeClass($c(e.classes), t) } if (e.attributes) { for (const i in e.attributes) { n.removeAttribute(i, t) } } } function _D(t, e, n = wD, i = AD) { const o = new dD; o.on("change:top", ((e, o) => { if (o.oldDescriptor) { i(t, o.oldDescriptor, o.writer) } if (o.newDescriptor) { n(t, o.newDescriptor, o.writer) } })); const r = (t, e, n) => o.add(e, n); const s = (t, e, n) => o.remove(e, n); e.setCustomProperty("addHighlight", r, t); e.setCustomProperty("removeHighlight", s, t) } function CD(t, e) { const n = t.getCustomProperty("widgetLabel"); n.push(e) } function vD(t) { const e = t.getCustomProperty("widgetLabel"); return e.reduce(((t, e) => { if (typeof e === "function") { return t ? t + ". " + e() : e() } else { return t ? t + ". " + e : e } }), "") } function yD(t, e, n = {}) { e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t); e.setAttribute("role", "textbox", t); if (n.label) { e.setAttribute("aria-label", n.label, t) } e.setAttribute("contenteditable", t.isReadOnly ? "false" : "true", t); t.on("change:isReadOnly", ((n, i, o) => { e.setAttribute("contenteditable", o ? "false" : "true", t) })); t.on("change:isFocused", ((n, i, o) => { if (o) { e.addClass("ck-editor__nested-editable_focused", t) } else { e.removeClass("ck-editor__nested-editable_focused", t) } })); _D(t, e); return t } function xD(t, e) { const n = t.getSelectedElement(); if (n) { const i = ND(t); if (i) { return e.createRange(e.createPositionAt(n, i)) } } return Sw(t, e) } function ED(t, e) { return (n, i) => { const { mapper: o, viewPosition: r } = i; const s = o.findMappedViewAncestor(r); if (!e(s)) { return } const a = o.toModelElement(s); i.modelPosition = t.createPositionAt(a, r.isAtStart ? "before" : "after") } } function DD() { return null } function SD(t, e) { const n = e.createUIElement("div", { class: "ck ck-widget__selection-handle" }, (function (t) { const e = this.toDomElement(t); const n = new mC; n.set("content", mD); n.render(); e.appendChild(n.element); return e })); e.insert(e.createPositionAt(t, 0), n); e.addClass(["ck-widget_with-selection-handle"], t) } const TD = "widget-type-around"; function ID(t, e, n) { return !!t && bD(t) && !n.isInline(e) } function MD(t) { return t.closest(".ck-widget__type-around__button") } function BD(t) { return t.classList.contains("ck-widget__type-around__button_before") ? "before" : "after" } function LD(t, e) { const n = t.closest(".ck-widget"); return e.mapDomToView(n) } function ND(t) { return t.getAttribute(TD) } const zD = '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>'; var PD = n(5137); var OD = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; OD.insert = "head"; OD.singleton = true; var RD = Sl()(PD.Z, OD); const VD = PD.Z.locals || {}; const jD = ["before", "after"]; const FD = (new DOMParser).parseFromString(zD, "image/svg+xml").firstChild; const HD = "ck-widget__type-around_disabled"; class UD extends wl { constructor() { super(...arguments); this._currentFakeCaretModelElement = null } static get pluginName() { return "WidgetTypeAround" } static get requires() { return [iD, xE] } init() { const t = this.editor; const e = t.editing.view; this.on("change:isEnabled", ((n, i, o) => { e.change((t => { for (const n of e.document.roots) { if (o) { t.removeClass(HD, n) } else { t.addClass(HD, n) } } })); if (!o) { t.model.change((t => { t.removeSelectionAttribute(TD) })) } })); this._enableTypeAroundUIInjection(); this._enableInsertingParagraphsOnButtonClick(); this._enableInsertingParagraphsOnEnterKeypress(); this._enableInsertingParagraphsOnTypingKeystroke(); this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(); this._enableDeleteIntegration(); this._enableInsertContentIntegration(); this._enableInsertObjectIntegration(); this._enableDeleteContentIntegration() } destroy() { super.destroy(); this._currentFakeCaretModelElement = null } _insertParagraph(t, e) { const n = this.editor; const i = n.editing.view; const o = n.model.schema.getAttributesWithProperty(t, "copyOnReplace", true); n.execute("insertParagraph", { position: n.model.createPositionAt(t, e), attributes: o }); i.focus(); i.scrollToTheSelection() } _listenToIfEnabled(t, e, n, i) { this.listenTo(t, e, ((...t) => { if (this.isEnabled) { n(...t) } }), i) } _insertParagraphAccordingToFakeCaretPosition() { const t = this.editor; const e = t.model; const n = e.document.selection; const i = ND(n); if (!i) { return false } const o = n.getSelectedElement(); this._insertParagraph(o, i); return true } _enableTypeAroundUIInjection() { const t = this.editor; const e = t.model.schema; const n = t.locale.t; const i = { before: n("Insert paragraph before block"), after: n("Insert paragraph after block") }; t.editing.downcastDispatcher.on("insert", ((t, o, r) => { const s = r.mapper.toViewElement(o.item); if (!s) { return } if (ID(s, o.item, e)) { WD(r.writer, i, s); const t = s.getCustomProperty("widgetLabel"); t.push((() => this.isEnabled ? n("Press Enter to type after or press Shift + Enter to type before the widget") : "")) } }), { priority: "low" }) } _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() { const t = this.editor; const e = t.model; const n = e.document.selection; const i = e.schema; const o = t.editing.view; this._listenToIfEnabled(o.document, "arrowKey", ((t, e) => { this._handleArrowKeyPress(t, e) }), { context: [bD, "$text"], priority: "high" }); this._listenToIfEnabled(n, "change:range", ((e, n) => { if (!n.directChange) { return } t.model.change((t => { t.removeSelectionAttribute(TD) })) })); this._listenToIfEnabled(e.document, "change:data", (() => { const e = n.getSelectedElement(); if (e) { const n = t.editing.mapper.toViewElement(e); if (ID(n, e, i)) { return } } t.model.change((t => { t.removeSelectionAttribute(TD) })) })); this._listenToIfEnabled(t.editing.downcastDispatcher, "selection", ((t, e, n) => { const o = n.writer; if (this._currentFakeCaretModelElement) { const t = n.mapper.toViewElement(this._currentFakeCaretModelElement); if (t) { o.removeClass(jD.map(r), t); this._currentFakeCaretModelElement = null } } const s = e.selection.getSelectedElement(); if (!s) { return } const a = n.mapper.toViewElement(s); if (!ID(a, s, i)) { return } const c = ND(e.selection); if (!c) { return } o.addClass(r(c), a); this._currentFakeCaretModelElement = s })); this._listenToIfEnabled(t.ui.focusTracker, "change:isFocused", ((e, n, i) => { if (!i) { t.model.change((t => { t.removeSelectionAttribute(TD) })) } })); function r(t) { return `ck-widget_type-around_show-fake-caret_${t}` } } _handleArrowKeyPress(t, e) { const n = this.editor; const i = n.model; const o = i.document.selection; const r = i.schema; const s = n.editing.view; const a = e.keyCode; const c = Wc(a, n.locale.contentLanguageDirection); const l = s.document.selection.getSelectedElement(); const d = n.editing.mapper.toModelElement(l); let u; if (ID(l, d, r)) { u = this._handleArrowKeyPressOnSelectedWidget(c) } else if (o.isCollapsed) { u = this._handleArrowKeyPressWhenSelectionNextToAWidget(c) } else if (!e.shiftKey) { u = this._handleArrowKeyPressWhenNonCollapsedSelection(c) } if (u) { e.preventDefault(); t.stop() } } _handleArrowKeyPressOnSelectedWidget(t) { const e = this.editor; const n = e.model; const i = n.document.selection; const o = ND(i); return n.change((e => { if (o) { const n = o === (t ? "after" : "before"); if (!n) { e.removeSelectionAttribute(TD); return true } } else { e.setSelectionAttribute(TD, t ? "after" : "before"); return true } return false })) } _handleArrowKeyPressWhenSelectionNextToAWidget(t) { const e = this.editor; const n = e.model; const i = n.schema; const o = e.plugins.get("Widget"); const r = o._getObjectElementNextToSelection(t); const s = e.editing.mapper.toViewElement(r); if (ID(s, r, i)) { n.change((e => { o._setSelectionOverElement(r); e.setSelectionAttribute(TD, t ? "before" : "after") })); return true } return false } _handleArrowKeyPressWhenNonCollapsedSelection(t) { const e = this.editor; const n = e.model; const i = n.schema; const o = e.editing.mapper; const r = n.document.selection; const s = t ? r.getLastPosition().nodeBefore : r.getFirstPosition().nodeAfter; const a = o.toViewElement(s); if (ID(a, s, i)) { n.change((e => { e.setSelection(s, "on"); e.setSelectionAttribute(TD, t ? "after" : "before") })); return true } return false } _enableInsertingParagraphsOnButtonClick() { const t = this.editor; const e = t.editing.view; this._listenToIfEnabled(e.document, "mousedown", ((n, i) => { const o = MD(i.domTarget); if (!o) { return } const r = BD(o); const s = LD(o, e.domConverter); const a = t.editing.mapper.toModelElement(s); this._insertParagraph(a, r); i.preventDefault(); n.stop() })) } _enableInsertingParagraphsOnEnterKeypress() { const t = this.editor; const e = t.model.document.selection; const n = t.editing.view; this._listenToIfEnabled(n.document, "enter", ((n, i) => { if (n.eventPhase != "atTarget") { return } const o = e.getSelectedElement(); const r = t.editing.mapper.toViewElement(o); const s = t.model.schema; let a; if (this._insertParagraphAccordingToFakeCaretPosition()) { a = true } else if (ID(r, o, s)) { this._insertParagraph(o, i.isSoft ? "before" : "after"); a = true } if (a) { i.preventDefault(); n.stop() } }), { context: bD }) } _enableInsertingParagraphsOnTypingKeystroke() { const t = this.editor; const e = t.editing.view.document; this._listenToIfEnabled(e, "insertText", ((t, n) => { if (this._insertParagraphAccordingToFakeCaretPosition()) { n.selection = e.selection } }), { priority: "high" }); if (r.isAndroid) { this._listenToIfEnabled(e, "keydown", ((t, e) => { if (e.keyCode == 229) { this._insertParagraphAccordingToFakeCaretPosition() } })) } else { this._listenToIfEnabled(e, "compositionstart", (() => { this._insertParagraphAccordingToFakeCaretPosition() }), { priority: "high" }) } } _enableDeleteIntegration() { const t = this.editor; const e = t.editing.view; const n = t.model; const i = n.schema; this._listenToIfEnabled(e.document, "delete", ((e, o) => { if (e.eventPhase != "atTarget") { return } const r = ND(n.document.selection); if (!r) { return } const s = o.direction; const a = n.document.selection.getSelectedElement(); const c = r === "before"; const l = s == "forward"; const d = c === l; if (d) { t.execute("delete", { selection: n.createSelection(a, "on") }) } else { const e = i.getNearestSelectionRange(n.createPositionAt(a, r), s); if (e) { if (!e.isCollapsed) { n.change((n => { n.setSelection(e); t.execute(l ? "deleteForward" : "delete") })) } else { const o = n.createSelection(e.start); n.modifySelection(o, { direction: s }); if (!o.focus.isEqual(e.start)) { n.change((n => { n.setSelection(e); t.execute(l ? "deleteForward" : "delete") })) } else { const t = $D(i, e.start.parent); n.deleteContent(n.createSelection(t, "on"), { doNotAutoparagraph: true }) } } } } o.preventDefault(); e.stop() }), { context: bD }) } _enableInsertContentIntegration() { const t = this.editor; const e = this.editor.model; const n = e.document.selection; this._listenToIfEnabled(t.model, "insertContent", ((t, [i, o]) => { if (o && !o.is("documentSelection")) { return } const r = ND(n); if (!r) { return } t.stop(); return e.change((t => { const o = n.getSelectedElement(); const s = e.createPositionAt(o, r); const a = t.createSelection(s); const c = e.insertContent(i, a); t.setSelection(a); return c })) }), { priority: "high" }) } _enableInsertObjectIntegration() { const t = this.editor; const e = this.editor.model; const n = e.document.selection; this._listenToIfEnabled(t.model, "insertObject", ((t, e) => { const [, i, o = {}] = e; if (i && !i.is("documentSelection")) { return } const r = ND(n); if (!r) { return } o.findOptimalPosition = r; e[3] = o }), { priority: "high" }) } _enableDeleteContentIntegration() { const t = this.editor; const e = this.editor.model; const n = e.document.selection; this._listenToIfEnabled(t.model, "deleteContent", ((t, [e]) => { if (e && !e.is("documentSelection")) { return } const i = ND(n); if (i) { t.stop() } }), { priority: "high" }) } } function WD(t, e, n) { const i = t.createUIElement("div", { class: "ck ck-reset_all ck-widget__type-around" }, (function (t) { const n = this.toDomElement(t); qD(n, e); GD(n); return n })); t.insert(t.createPositionAt(n, "end"), i) } function qD(t, e) { for (const n of jD) { const i = new P_({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__button", `ck-widget__type-around__button_${n}`], title: e[n], "aria-hidden": "true" }, children: [t.ownerDocument.importNode(FD, true)] }); t.appendChild(i.render()) } } function GD(t) { const e = new P_({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__fake-caret"] } }); t.appendChild(e.render()) } function $D(t, e) { let n = e; for (const i of e.getAncestors({ parentFirst: true })) { if (i.childCount > 1 || t.isLimit(i)) { break } n = i } return n } function KD(t) { const e = t.model; return (n, i) => { const o = i.keyCode == Pc.arrowup; const r = i.keyCode == Pc.arrowdown; const s = i.shiftKey; const a = e.document.selection; if (!o && !r) { return } const c = r; if (s && XD(a, c)) { return } const l = YD(t, a, c); if (!l) { return } if (l.isCollapsed) { if (a.isCollapsed) { return } else if (s) { return } } if (l.isCollapsed || JD(t, l, c)) { e.change((t => { const n = c ? l.end : l.start; if (s) { const i = e.createSelection(a.anchor); i.setFocus(n); t.setSelection(i) } else { t.setSelection(n) } })); n.stop(); i.preventDefault(); i.stopPropagation() } } } function YD(t, e, n) { const i = t.model; if (n) { const t = e.isCollapsed ? e.focus : e.getLastPosition(); const n = QD(i, t, "forward"); if (!n) { return null } const o = i.createRange(t, n); const r = ZD(i.schema, o, "backward"); if (r) { return i.createRange(t, r) } return null } else { const t = e.isCollapsed ? e.focus : e.getFirstPosition(); const n = QD(i, t, "backward"); if (!n) { return null } const o = i.createRange(n, t); const r = ZD(i.schema, o, "forward"); if (r) { return i.createRange(r, t) } return null } } function QD(t, e, n) { const i = t.schema; const o = t.createRangeIn(e.root); const r = n == "forward" ? "elementStart" : "elementEnd"; for (const { previousPosition: t, item: s, type: a } of o.getWalker({ startPosition: e, direction: n })) { if (i.isLimit(s) && !i.isInline(s)) { return t } if (a == r && i.isBlock(s)) { return null } } return null } function ZD(t, e, n) { const i = n == "backward" ? e.end : e.start; if (t.checkChild(i, "$text")) { return i } for (const { nextPosition: i } of e.getWalker({ direction: n })) { if (t.checkChild(i, "$text")) { return i } } return null } function JD(t, e, n) { const i = t.model; const o = t.view.domConverter; if (n) { const t = i.createSelection(e.start); i.modifySelection(t); if (!t.focus.isAtEnd && !e.start.isEqual(t.focus)) { e = i.createRange(t.focus, e.end) } } const r = t.mapper.toViewRange(e); const s = o.viewRangeToDom(r); const a = oc.getDomRangeRects(s); let c; for (const t of a) { if (c === undefined) { c = Math.round(t.bottom); continue } if (Math.round(t.top) >= c) { return false } c = Math.max(c, Math.round(t.bottom)) } return true } function XD(t, e) { return !t.isCollapsed && t.isBackward == e } var tS = n(6507); var eS = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; eS.insert = "head"; eS.singleton = true; var nS = Sl()(tS.Z, eS); const iS = tS.Z.locals || {}; class oS extends wl { constructor() { super(...arguments); this._previouslySelected = new Set } static get pluginName() { return "Widget" } static get requires() { return [UD, xE] } init() { const t = this.editor; const e = t.editing.view; const n = e.document; this.editor.editing.downcastDispatcher.on("selection", ((e, n, i) => { const o = i.writer; const r = n.selection; if (r.isCollapsed) { return } const s = r.getSelectedElement(); if (!s) { return } const a = t.editing.mapper.toViewElement(s); if (!bD(a)) { return } if (!i.consumable.consume(r, "selection")) { return } o.setSelection(o.createRangeOn(a), { fake: true, label: vD(a) }) })); this.editor.editing.downcastDispatcher.on("selection", ((t, e, n) => { this._clearPreviouslySelectedWidgets(n.writer); const i = n.writer; const o = i.document.selection; let r = null; for (const t of o.getRanges()) { for (const e of t) { const t = e.item; if (bD(t) && !sS(t, r)) { i.addClass(pD, t); this._previouslySelected.add(t); r = t } } } }), { priority: "low" }); e.addObserver(Hw); this.listenTo(n, "mousedown", ((...t) => this._onMousedown(...t))); this.listenTo(n, "arrowKey", ((...t) => { this._handleSelectionChangeOnArrowKeyPress(...t) }), { context: [bD, "$text"] }); this.listenTo(n, "arrowKey", ((...t) => { this._preventDefaultOnArrowKeyPress(...t) }), { context: "$root" }); this.listenTo(n, "arrowKey", KD(this.editor.editing), { context: "$text" }); this.listenTo(n, "delete", ((t, e) => { if (this._handleDelete(e.direction == "forward")) { e.preventDefault(); t.stop() } }), { context: "$root" }) } _onMousedown(t, e) { const n = this.editor; const i = n.editing.view; const o = i.document; let s = e.target; if (rS(s)) { if ((r.isSafari || r.isGecko) && e.domEvent.detail >= 3) { const t = n.editing.mapper; const i = s.is("attributeElement") ? s.findAncestor((t => !t.is("attributeElement"))) : s; const o = t.toModelElement(i); e.preventDefault(); this.editor.model.change((t => { t.setSelection(o, "in") })) } return } if (!bD(s)) { s = s.findAncestor(bD); if (!s) { return } } if (r.isAndroid) { e.preventDefault() } if (!o.isFocused) { i.focus() } const a = n.editing.mapper.toModelElement(s); this._setSelectionOverElement(a) } _handleSelectionChangeOnArrowKeyPress(t, e) { const n = e.keyCode; const i = this.editor.model; const o = i.schema; const r = i.document.selection; const s = r.getSelectedElement(); const a = Hc(n, this.editor.locale.contentLanguageDirection); const c = a == "down" || a == "right"; const l = a == "up" || a == "down"; if (s && o.isObject(s)) { const n = c ? r.getLastPosition() : r.getFirstPosition(); const s = o.getNearestSelectionRange(n, c ? "forward" : "backward"); if (s) { i.change((t => { t.setSelection(s) })); e.preventDefault(); t.stop() } return } if (!r.isCollapsed && !e.shiftKey) { const n = r.getFirstPosition(); const s = r.getLastPosition(); const a = n.nodeAfter; const l = s.nodeBefore; if (a && o.isObject(a) || l && o.isObject(l)) { i.change((t => { t.setSelection(c ? s : n) })); e.preventDefault(); t.stop() } return } if (!r.isCollapsed) { return } const d = this._getObjectElementNextToSelection(c); if (d && o.isObject(d)) { if (o.isInline(d) && l) { return } this._setSelectionOverElement(d); e.preventDefault(); t.stop() } } _preventDefaultOnArrowKeyPress(t, e) { const n = this.editor.model; const i = n.schema; const o = n.document.selection.getSelectedElement(); if (o && i.isObject(o)) { e.preventDefault(); t.stop() } } _handleDelete(t) { if (this.editor.isReadOnly) { return } const e = this.editor.model.document; const n = e.selection; if (!n.isCollapsed) { return } const i = this._getObjectElementNextToSelection(t); if (i) { this.editor.model.change((t => { let e = n.anchor.parent; while (e.isEmpty) { const n = e; e = n.parent; t.remove(n) } this._setSelectionOverElement(i) })); return true } } _setSelectionOverElement(t) { this.editor.model.change((e => { e.setSelection(e.createRangeOn(t)) })) } _getObjectElementNextToSelection(t) { const e = this.editor.model; const n = e.schema; const i = e.document.selection; const o = e.createSelection(i); e.modifySelection(o, { direction: t ? "forward" : "backward" }); if (o.isEqual(i)) { return null } const r = t ? o.focus.nodeBefore : o.focus.nodeAfter; if (!!r && n.isObject(r)) { return r } return null } _clearPreviouslySelectedWidgets(t) { for (const e of this._previouslySelected) { t.removeClass(pD, e) } this._previouslySelected.clear() } } function rS(t) { let e = t; while (e) { if (e.is("editableElement") && !e.is("rootElement")) { return true } if (bD(e)) { return false } e = e.parent } return false } function sS(t, e) { if (!e) { return false } return Array.from(t.getAncestors()).includes(e) } class aS extends wl { constructor() { super(...arguments); this._toolbarDefinitions = new Map } static get requires() { return [Xy] } static get pluginName() { return "WidgetToolbarRepository" } init() { const t = this.editor; if (t.plugins.has("BalloonToolbar")) { const e = t.plugins.get("BalloonToolbar"); this.listenTo(e, "show", (e => { if (dS(t.editing.view.document.selection)) { e.stop() } }), { priority: "high" }) } this._balloon = this.editor.plugins.get("ContextualBalloon"); this.on("change:isEnabled", (() => { this._updateToolbarsVisibility() })); this.listenTo(t.ui, "update", (() => { this._updateToolbarsVisibility() })); this.listenTo(t.ui.focusTracker, "change:isFocused", (() => { this._updateToolbarsVisibility() }), { priority: "low" }) } destroy() { super.destroy(); for (const t of this._toolbarDefinitions.values()) { t.view.destroy() } } register(t, { ariaLabel: e, items: n, getRelatedElement: i, balloonClassName: o = "ck-toolbar-container" }) { if (!n.length) { M("widget-toolbar-no-items", { toolbarId: t }); return } const r = this.editor; const s = r.t; const a = new cv(r.locale); a.ariaLabel = e || s("Widget toolbar"); if (this._toolbarDefinitions.has(t)) { throw new I("widget-toolbar-duplicated", this, { toolbarId: t }) } const c = { view: a, getRelatedElement: i, balloonClassName: o, itemsConfig: n, initialized: false }; r.ui.addToolbar(a, { isContextual: true, beforeFocus: () => { const t = i(r.editing.view.document.selection); if (t) { this._showToolbar(c, t) } }, afterBlur: () => { this._hideToolbar(c) } }); this._toolbarDefinitions.set(t, c) } _updateToolbarsVisibility() { let t = 0; let e = null; let n = null; for (const i of this._toolbarDefinitions.values()) { const o = i.getRelatedElement(this.editor.editing.view.document.selection); if (!this.isEnabled || !o) { if (this._isToolbarInBalloon(i)) { this._hideToolbar(i) } } else if (!this.editor.ui.focusTracker.isFocused) { if (this._isToolbarVisible(i)) { this._hideToolbar(i) } } else { const r = o.getAncestors().length; if (r > t) { t = r; e = o; n = i } } } if (n) { this._showToolbar(n, e) } } _hideToolbar(t) { this._balloon.remove(t.view); this.stopListening(this._balloon, "change:visibleView") } _showToolbar(t, e) { if (this._isToolbarVisible(t)) { cS(this.editor, e) } else if (!this._isToolbarInBalloon(t)) { if (!t.initialized) { t.initialized = true; t.view.fillFromConfig(t.itemsConfig, this.editor.ui.componentFactory) } this._balloon.add({ view: t.view, position: lS(this.editor, e), balloonClassName: t.balloonClassName }); this.listenTo(this._balloon, "change:visibleView", (() => { for (const t of this._toolbarDefinitions.values()) { if (this._isToolbarVisible(t)) { const e = t.getRelatedElement(this.editor.editing.view.document.selection); cS(this.editor, e) } } })) } } _isToolbarVisible(t) { return this._balloon.visibleView === t.view } _isToolbarInBalloon(t) { return this._balloon.hasView(t.view) } } function cS(t, e) { const n = t.plugins.get("ContextualBalloon"); const i = lS(t, e); n.updatePosition(i) } function lS(t, e) { const n = t.editing.view; const i = Gv.defaultPositions; return { target: n.domConverter.mapViewToDom(e), positions: [i.northArrowSouth, i.northArrowSouthWest, i.northArrowSouthEast, i.southArrowNorth, i.southArrowNorthWest, i.southArrowNorthEast, i.viewportStickyNorth] } } function dS(t) { const e = t.getSelectedElement(); return !!(e && bD(e)) } class uS extends (lt()) { constructor(t) { super(); this.set("activeHandlePosition", null); this.set("proposedWidthPercents", null); this.set("proposedWidth", null); this.set("proposedHeight", null); this.set("proposedHandleHostWidth", null); this.set("proposedHandleHostHeight", null); this._options = t; this._referenceCoordinates = null } get originalWidth() { return this._originalWidth } get originalHeight() { return this._originalHeight } get originalWidthPercents() { return this._originalWidthPercents } get aspectRatio() { return this._aspectRatio } begin(t, e, n) { const i = new oc(e); this.activeHandlePosition = fS(t); this._referenceCoordinates = gS(e, pS(this.activeHandlePosition)); this._originalWidth = i.width; this._originalHeight = i.height; this._aspectRatio = i.width / i.height; const o = n.style.width; if (o && o.match(/^\d+(\.\d*)?%$/)) { this._originalWidthPercents = parseFloat(o) } else { this._originalWidthPercents = hS(n, i) } } update(t) { this.proposedWidth = t.width; this.proposedHeight = t.height; this.proposedWidthPercents = t.widthPercents; this.proposedHandleHostWidth = t.handleHostWidth; this.proposedHandleHostHeight = t.handleHostHeight } } function hS(t, e) { const n = t.parentElement; let i = parseFloat(n.ownerDocument.defaultView.getComputedStyle(n).width); const o = 5; let r = 0; let s = n; while (isNaN(i)) { s = s.parentElement; if (++r > o) { return 0 } i = parseFloat(n.ownerDocument.defaultView.getComputedStyle(s).width) } return e.width / i * 100 } function gS(t, e) { const n = new oc(t); const i = e.split("-"); const o = { x: i[1] == "right" ? n.right : n.left, y: i[0] == "bottom" ? n.bottom : n.top }; o.x += t.ownerDocument.defaultView.scrollX; o.y += t.ownerDocument.defaultView.scrollY; return o } function mS(t) { return `ck-widget__resizer__handle-${t}` } function fS(t) { const e = ["top-left", "top-right", "bottom-right", "bottom-left"]; for (const n of e) { if (t.classList.contains(mS(n))) { return n } } } function pS(t) { const e = t.split("-"); const n = { top: "bottom", bottom: "top", left: "right", right: "left" }; return `${n[e[0]]}-${n[e[1]]}` } class bS extends N_ { constructor() { super(); const t = this.bindTemplate; this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-size-view", t.to("_viewPosition", (t => t ? `ck-orientation-${t}` : ""))], style: { display: t.if("_isVisible", "none", (t => !t)) } }, children: [{ text: t.to("_label") }] }) } _bindToState(t, e) { this.bind("_isVisible").to(e, "proposedWidth", e, "proposedHeight", ((t, e) => t !== null && e !== null)); this.bind("_label").to(e, "proposedHandleHostWidth", e, "proposedHandleHostHeight", e, "proposedWidthPercents", ((e, n, i) => { if (t.unit === "px") { return `${e}×${n}` } else { return `${i}%` } })); this.bind("_viewPosition").to(e, "activeHandlePosition", e, "proposedHandleHostWidth", e, "proposedHandleHostHeight", ((t, e, n) => e < 50 || n < 50 ? "above-center" : t)) } _dismiss() { this.unbind(); this._isVisible = false } } class kS extends (lt()) { constructor(t) { super(); this._viewResizerWrapper = null; this._options = t; this.set("isEnabled", true); this.set("isSelected", false); this.bind("isVisible").to(this, "isEnabled", this, "isSelected", ((t, e) => t && e)); this.decorate("begin"); this.decorate("cancel"); this.decorate("commit"); this.decorate("updateSize"); this.on("commit", (t => { if (!this.state.proposedWidth && !this.state.proposedWidthPercents) { this._cleanup(); t.stop() } }), { priority: "high" }) } get state() { return this._state } show() { const t = this._options.editor.editing.view; t.change((t => { t.removeClass("ck-hidden", this._viewResizerWrapper) })) } hide() { const t = this._options.editor.editing.view; t.change((t => { t.addClass("ck-hidden", this._viewResizerWrapper) })) } attach() { const t = this; const e = this._options.viewElement; const n = this._options.editor.editing.view; n.change((n => { const i = n.createUIElement("div", { class: "ck ck-reset_all ck-widget__resizer" }, (function (e) { const n = this.toDomElement(e); t._appendHandles(n); t._appendSizeUI(n); return n })); n.insert(n.createPositionAt(e, "end"), i); n.addClass("ck-widget_with-resizer", e); this._viewResizerWrapper = i; if (!this.isVisible) { this.hide() } })); this.on("change:isVisible", (() => { if (this.isVisible) { this.show(); this.redraw() } else { this.hide() } })) } begin(t) { this._state = new uS(this._options); this._sizeView._bindToState(this._options, this.state); this._initialViewWidth = this._options.viewElement.getStyle("width"); this.state.begin(t, this._getHandleHost(), this._getResizeHost()) } updateSize(t) { const e = this._proposeNewSize(t); const n = this._options.editor.editing.view; n.change((t => { const n = this._options.unit || "%"; const i = (n === "%" ? e.widthPercents : e.width) + n; t.setStyle("width", i, this._options.viewElement) })); const i = this._getHandleHost(); const o = new oc(i); const r = Math.round(o.width); const s = Math.round(o.height); const a = new oc(i); e.width = Math.round(a.width); e.height = Math.round(a.height); this.redraw(o); this.state.update({ ...e, handleHostWidth: r, handleHostHeight: s }) } commit() { const t = this._options.unit || "%"; const e = (t === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + t; this._options.editor.editing.view.change((() => { this._cleanup(); this._options.onCommit(e) })) } cancel() { this._cleanup() } destroy() { this.cancel() } redraw(t) { const e = this._domResizerWrapper; if (!_S(e)) { return } const n = e.parentElement; const i = this._getHandleHost(); const o = this._viewResizerWrapper; const r = [o.getStyle("width"), o.getStyle("height"), o.getStyle("left"), o.getStyle("top")]; let s; if (n.isSameNode(i)) { const e = t || new oc(i); s = [e.width + "px", e.height + "px", undefined, undefined] } else { s = [i.offsetWidth + "px", i.offsetHeight + "px", i.offsetLeft + "px", i.offsetTop + "px"] } if (_t(r, s) !== "same") { this._options.editor.editing.view.change((t => { t.setStyle({ width: s[0], height: s[1], left: s[2], top: s[3] }, o) })) } } containsHandle(t) { return this._domResizerWrapper.contains(t) } static isResizeHandle(t) { return t.classList.contains("ck-widget__resizer__handle") } _cleanup() { this._sizeView._dismiss(); const t = this._options.editor.editing.view; t.change((t => { t.setStyle("width", this._initialViewWidth, this._options.viewElement) })) } _proposeNewSize(t) { const e = this.state; const n = AS(t); const i = this._options.isCentered ? this._options.isCentered(this) : true; const o = { x: e._referenceCoordinates.x - (n.x + e.originalWidth), y: n.y - e.originalHeight - e._referenceCoordinates.y }; if (i && e.activeHandlePosition.endsWith("-right")) { o.x = n.x - (e._referenceCoordinates.x + e.originalWidth) } if (i) { o.x *= 2 } let r = Math.abs(e.originalWidth + o.x); let s = Math.abs(e.originalHeight + o.y); const a = r / e.aspectRatio > s ? "width" : "height"; if (a == "width") { s = r / e.aspectRatio } else { r = s * e.aspectRatio } return { width: Math.round(r), height: Math.round(s), widthPercents: Math.min(Math.round(e.originalWidthPercents / e.originalWidth * r * 100) / 100, 100) } } _getResizeHost() { const t = this._domResizerWrapper.parentElement; return this._options.getResizeHost(t) } _getHandleHost() { const t = this._domResizerWrapper.parentElement; return this._options.getHandleHost(t) } get _domResizerWrapper() { return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper) } _appendHandles(t) { const e = ["top-left", "top-right", "bottom-right", "bottom-left"]; for (const n of e) { t.appendChild(new P_({ tag: "div", attributes: { class: `ck-widget__resizer__handle ${wS(n)}` } }).render()) } } _appendSizeUI(t) { this._sizeView = new bS; this._sizeView.render(); t.appendChild(this._sizeView.element) } } function wS(t) { return `ck-widget__resizer__handle-${t}` } function AS(t) { return { x: t.pageX, y: t.pageY } } function _S(t) { return t && t.ownerDocument && t.ownerDocument.contains(t) } var CS = n(2263); var vS = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; vS.insert = "head"; vS.singleton = true; var yS = Sl()(CS.Z, vS); const xS = CS.Z.locals || {}; class ES extends wl { constructor() { super(...arguments); this._resizers = new Map } static get pluginName() { return "WidgetResize" } init() { const t = this.editor.editing; const e = Za.window.document; this.set("selectedResizer", null); this.set("_activeResizer", null); t.view.addObserver(Hw); this._observer = new (Ga()); this.listenTo(t.view.document, "mousedown", this._mouseDownListener.bind(this), { priority: "high" }); this._observer.listenTo(e, "mousemove", this._mouseMoveListener.bind(this)); this._observer.listenTo(e, "mouseup", this._mouseUpListener.bind(this)); this._redrawSelectedResizerThrottled = Sx((() => this.redrawSelectedResizer()), 200); this.editor.ui.on("update", this._redrawSelectedResizerThrottled); this.editor.model.document.on("change", (() => { for (const [t, e] of this._resizers) { if (!t.isAttached()) { this._resizers.delete(t); e.destroy() } } }), { priority: "lowest" }); this._observer.listenTo(Za.window, "resize", this._redrawSelectedResizerThrottled); const n = this.editor.editing.view.document.selection; n.on("change", (() => { const t = n.getSelectedElement(); const e = this.getResizerByViewElement(t) || null; if (e) { this.select(e) } else { this.deselect() } })) } redrawSelectedResizer() { if (this.selectedResizer && this.selectedResizer.isVisible) { this.selectedResizer.redraw() } } destroy() { super.destroy(); this._observer.stopListening(); for (const t of this._resizers.values()) { t.destroy() } this._redrawSelectedResizerThrottled.cancel() } select(t) { this.deselect(); this.selectedResizer = t; this.selectedResizer.isSelected = true } deselect() { if (this.selectedResizer) { this.selectedResizer.isSelected = false } this.selectedResizer = null } attachTo(t) { const e = new kS(t); const n = this.editor.plugins; e.attach(); if (n.has("WidgetToolbarRepository")) { const t = n.get("WidgetToolbarRepository"); e.on("begin", (() => { t.forceDisabled("resize") }), { priority: "lowest" }); e.on("cancel", (() => { t.clearForceDisabled("resize") }), { priority: "highest" }); e.on("commit", (() => { t.clearForceDisabled("resize") }), { priority: "highest" }) } this._resizers.set(t.viewElement, e); const i = this.editor.editing.view.document.selection; const o = i.getSelectedElement(); if (this.getResizerByViewElement(o) == e) { this.select(e) } return e } getResizerByViewElement(t) { return this._resizers.get(t) } _getResizerByHandle(t) { for (const e of this._resizers.values()) { if (e.containsHandle(t)) { return e } } } _mouseDownListener(t, e) { const n = e.domTarget; if (!kS.isResizeHandle(n)) { return } this._activeResizer = this._getResizerByHandle(n) || null; if (this._activeResizer) { this._activeResizer.begin(n); t.stop(); e.preventDefault() } } _mouseMoveListener(t, e) { if (this._activeResizer) { this._activeResizer.updateSize(e) } } _mouseUpListener() { if (this._activeResizer) { this._activeResizer.commit(); this._activeResizer = null } } } var DS = n(390); var SS = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; SS.insert = "head"; SS.singleton = true; var TS = Sl()(DS.Z, SS); const IS = DS.Z.locals || {}; class MS extends wl { static get pluginName() { return "DragDrop" } static get requires() { return [aE, oS] } init() { const t = this.editor; const e = t.editing.view; this._draggedRange = null; this._draggingUid = ""; this._draggableElement = null; this._updateDropMarkerThrottled = Sx((t => this._updateDropMarker(t)), 40); this._removeDropMarkerDelayed = VS((() => this._removeDropMarker()), 40); this._clearDraggableAttributesDelayed = VS((() => this._clearDraggableAttributes()), 40); e.addObserver(eE); e.addObserver(Hw); this._setupDragging(); this._setupContentInsertionIntegration(); this._setupClipboardInputIntegration(); this._setupDropMarker(); this._setupDraggableAttributeHandling(); this.listenTo(t, "change:isReadOnly", ((t, e, n) => { if (n) { this.forceDisabled("readOnlyMode") } else { this.clearForceDisabled("readOnlyMode") } })); this.on("change:isEnabled", ((t, e, n) => { if (!n) { this._finalizeDragging(false) } })); if (r.isAndroid) { this.forceDisabled("noAndroidSupport") } } destroy() { if (this._draggedRange) { this._draggedRange.detach(); this._draggedRange = null } this._updateDropMarkerThrottled.cancel(); this._removeDropMarkerDelayed.cancel(); this._clearDraggableAttributesDelayed.cancel(); return super.destroy() } _setupDragging() { const t = this.editor; const e = t.model; const n = e.document; const i = t.editing.view; const o = i.document; this.listenTo(o, "dragstart", ((i, r) => { const s = n.selection; if (r.target && r.target.is("editableElement")) { r.preventDefault(); return } const a = r.target ? jS(r.target) : null; if (a) { const n = t.editing.mapper.toModelElement(a); this._draggedRange = jf.fromRange(e.createRangeOn(n)); if (t.plugins.has("WidgetToolbarRepository")) { const e = t.plugins.get("WidgetToolbarRepository"); e.forceDisabled("dragDrop") } } else if (!o.selection.isCollapsed) { const t = o.selection.getSelectedElement(); if (!t || !bD(t)) { this._draggedRange = jf.fromRange(s.getFirstRange()) } } if (!this._draggedRange) { r.preventDefault(); return } this._draggingUid = x(); r.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy"; r.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid); const c = e.createSelection(this._draggedRange.toRange()); const l = t.data.toView(e.getSelectedContent(c)); o.fire("clipboardOutput", { dataTransfer: r.dataTransfer, content: l, method: "dragstart" }); if (!this.isEnabled) { this._draggedRange.detach(); this._draggedRange = null; this._draggingUid = "" } }), { priority: "low" }); this.listenTo(o, "dragend", ((t, e) => { this._finalizeDragging(!e.dataTransfer.isCanceled && e.dataTransfer.dropEffect == "move") }), { priority: "low" }); this.listenTo(o, "dragenter", (() => { if (!this.isEnabled) { return } i.focus() })); this.listenTo(o, "dragleave", (() => { this._removeDropMarkerDelayed() })); this.listenTo(o, "dragging", ((e, n) => { if (!this.isEnabled) { n.dataTransfer.dropEffect = "none"; return } this._removeDropMarkerDelayed.cancel(); const i = BS(t, n.targetRanges, n.target); if (!this._draggedRange) { n.dataTransfer.dropEffect = "copy" } if (!r.isGecko) { if (n.dataTransfer.effectAllowed == "copy") { n.dataTransfer.dropEffect = "copy" } else if (["all", "copyMove"].includes(n.dataTransfer.effectAllowed)) { n.dataTransfer.dropEffect = "move" } } if (i) { this._updateDropMarkerThrottled(i) } }), { priority: "low" }) } _setupClipboardInputIntegration() { const t = this.editor; const e = t.editing.view; const n = e.document; this.listenTo(n, "clipboardInput", ((e, n) => { if (n.method != "drop") { return } const i = BS(t, n.targetRanges, n.target); this._removeDropMarker(); if (!i) { this._finalizeDragging(false); e.stop(); return } if (this._draggedRange && this._draggingUid != n.dataTransfer.getData("application/ckeditor5-dragging-uid")) { this._draggedRange.detach(); this._draggedRange = null; this._draggingUid = "" } const o = RS(n.dataTransfer) == "move"; if (o && this._draggedRange && this._draggedRange.containsRange(i, true)) { this._finalizeDragging(false); e.stop(); return } n.targetRanges = [t.editing.mapper.toViewRange(i)] }), { priority: "high" }) } _setupContentInsertionIntegration() { const t = this.editor.plugins.get(aE); t.on("contentInsertion", ((t, e) => { if (!this.isEnabled || e.method !== "drop") { return } const n = e.targetRanges.map((t => this.editor.editing.mapper.toModelRange(t))); this.editor.model.change((t => t.setSelection(n))) }), { priority: "high" }); t.on("contentInsertion", ((t, e) => { if (!this.isEnabled || e.method !== "drop") { return } const n = RS(e.dataTransfer) == "move"; const i = !e.resultRange || !e.resultRange.isCollapsed; this._finalizeDragging(i && n) }), { priority: "lowest" }) } _setupDraggableAttributeHandling() { const t = this.editor; const e = t.editing.view; const n = e.document; this.listenTo(n, "mousedown", ((i, o) => { if (r.isAndroid || !o) { return } this._clearDraggableAttributesDelayed.cancel(); let s = jS(o.target); if (r.isBlink && !t.isReadOnly && !s && !n.selection.isCollapsed) { const t = n.selection.getSelectedElement(); if (!t || !bD(t)) { s = n.selection.editableElement } } if (s) { e.change((t => { t.setAttribute("draggable", "true", s) })); this._draggableElement = t.editing.mapper.toModelElement(s) } })); this.listenTo(n, "mouseup", (() => { if (!r.isAndroid) { this._clearDraggableAttributesDelayed() } })) } _clearDraggableAttributes() { const t = this.editor.editing; t.view.change((e => { if (this._draggableElement && this._draggableElement.root.rootName != "$graveyard") { e.removeAttribute("draggable", t.mapper.toViewElement(this._draggableElement)) } this._draggableElement = null })) } _setupDropMarker() { const t = this.editor; t.conversion.for("editingDowncast").markerToHighlight({ model: "drop-target", view: { classes: ["ck-clipboard-drop-target-range"] } }); t.conversion.for("editingDowncast").markerToElement({ model: "drop-target", view: (e, { writer: n }) => { const i = t.model.schema.checkChild(e.markerRange.start, "$text"); if (!i) { return } return n.createUIElement("span", { class: "ck ck-clipboard-drop-target-position" }, (function (t) { const e = this.toDomElement(t); e.append("⁠", t.createElement("span"), "⁠"); return e })) } }) } _updateDropMarker(t) { const e = this.editor; const n = e.model.markers; e.model.change((e => { if (n.has("drop-target")) { if (!n.get("drop-target").getRange().isEqual(t)) { e.updateMarker("drop-target", { range: t }) } } else { e.addMarker("drop-target", { range: t, usingOperation: false, affectsData: false }) } })) } _removeDropMarker() { const t = this.editor.model; this._removeDropMarkerDelayed.cancel(); this._updateDropMarkerThrottled.cancel(); if (t.markers.has("drop-target")) { t.change((t => { t.removeMarker("drop-target") })) } } _finalizeDragging(t) { const e = this.editor; const n = e.model; this._removeDropMarker(); this._clearDraggableAttributes(); if (e.plugins.has("WidgetToolbarRepository")) { const t = e.plugins.get("WidgetToolbarRepository"); t.clearForceDisabled("dragDrop") } this._draggingUid = ""; if (!this._draggedRange) { return } if (t && this.isEnabled) { n.deleteContent(n.createSelection(this._draggedRange), { doNotAutoparagraph: true }) } this._draggedRange.detach(); this._draggedRange = null } } function BS(t, e, n) { const i = t.model; const o = t.editing.mapper; let s = null; const a = e ? e[0].start : null; if (n.is("uiElement")) { n = n.parent } s = LS(t, n); if (s) { return s } const c = OS(t, n); const l = a ? o.toModelPosition(a) : null; if (!l) { return NS(t, c) } s = zS(t, l, c); if (s) { return s } s = i.schema.getNearestSelectionRange(l, r.isGecko ? "forward" : "backward"); if (s) { return s } return PS(t, l.parent) } function LS(t, e) { const n = t.model; const i = t.editing.mapper; if (bD(e)) { return n.createRangeOn(i.toModelElement(e)) } if (!e.is("editableElement")) { const t = e.findAncestor((t => bD(t) || t.is("editableElement"))); if (bD(t)) { return n.createRangeOn(i.toModelElement(t)) } } return null } function NS(t, e) { const n = t.model; const i = n.schema; const o = n.createPositionAt(e, 0); return i.getNearestSelectionRange(o, "forward") } function zS(t, e, n) { const i = t.model; if (!i.schema.checkChild(n, "$block")) { return null } const o = i.createPositionAt(n, 0); const r = e.path.slice(0, o.path.length); const s = i.createPositionFromPath(e.root, r); const a = s.nodeAfter; if (a && i.schema.isObject(a)) { return i.createRangeOn(a) } return null } function PS(t, e) { const n = t.model; let i = e; while (i) { if (n.schema.isObject(i)) { return n.createRangeOn(i) } i = i.parent } return null } function OS(t, e) { const n = t.editing.mapper; const i = t.editing.view; const o = n.toModelElement(e); if (o) { return o } const r = i.createPositionBefore(e); const s = n.findMappedViewAncestor(r); return n.toModelElement(s) } function RS(t) { if (r.isGecko) { return t.dropEffect } return ["all", "copyMove"].includes(t.effectAllowed) ? "move" : "copy" } function VS(t, e) { let n; function i(...o) { i.cancel(); n = setTimeout((() => t(...o)), e) } i.cancel = () => { clearTimeout(n) }; return i } function jS(t) { if (t.is("editableElement")) { return null } if (t.hasClass("ck-widget__selection-handle")) { return t.findAncestor(bD) } if (bD(t)) { return t } const e = t.findAncestor((t => bD(t) || t.is("editableElement"))); if (bD(e)) { return e } return null } class FS extends wl { static get pluginName() { return "PastePlainText" } static get requires() { return [aE] } init() { const t = this.editor; const e = t.model; const n = t.editing.view; const i = n.document; const o = e.document.selection; let r = false; n.addObserver(eE); this.listenTo(i, "keydown", ((t, e) => { r = e.shiftKey })); t.plugins.get(aE).on("contentInsertion", ((t, n) => { if (!r && !HS(n.content, e.schema)) { return } e.change((t => { const i = Array.from(o.getAttributes()).filter((([t]) => e.schema.getAttributeProperties(t).isFormatting)); if (!o.isCollapsed) { e.deleteContent(o, { doNotAutoparagraph: true }) } i.push(...o.getAttributes()); const r = t.createRangeIn(n.content); for (const e of r.getItems()) { if (e.is("$textProxy")) { t.setAttributes(i, e) } } })) })) } } function HS(t, e) { if (t.childCount > 1) { return false } const n = t.getChild(0); if (e.isObject(n)) { return false } return Array.from(n.getAttributeKeys()).length == 0 } class US extends wl { static get pluginName() { return "Clipboard" } static get requires() { return [aE, MS, FS] } } class WS extends _l { constructor(t) { super(t); this._stack = []; this._createdBatches = new WeakSet; this.refresh(); this.listenTo(t.data, "set", ((t, e) => { e[1] = { ...e[1] }; const n = e[1]; if (!n.batchType) { n.batchType = { isUndoable: false } } }), { priority: "high" }); this.listenTo(t.data, "set", ((t, e) => { const n = e[1]; if (!n.batchType.isUndoable) { this.clearStack() } })) } refresh() { this.isEnabled = this._stack.length > 0 } get createdBatches() { return this._createdBatches } addBatch(t) { const e = this.editor.model.document.selection; const n = { ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [], isBackward: e.isBackward }; this._stack.push({ batch: t, selection: n }); this.refresh() } clearStack() { this._stack = []; this.refresh() } _restoreSelection(t, e, n) { const i = this.editor.model; const o = i.document; const r = []; const s = t.map((t => t.getTransformedByOperations(n))); const a = s.flat(); for (const t of s) { const e = t.filter((t => t.root != o.graveyard)).filter((t => !GS(t, a))); if (!e.length) { continue } qS(e); r.push(e[0]) } if (r.length) { i.change((t => { t.setSelection(r, { backward: e }) })) } } _undo(t, e) { const n = this.editor.model; const i = n.document; this._createdBatches.add(e); const o = t.operations.slice().filter((t => t.isDocumentOperation)); o.reverse(); for (const t of o) { const o = t.baseVersion + 1; const r = Array.from(i.history.getOperations(o)); const s = Mk([t.getReversed()], r, { useRelations: true, document: this.editor.model.document, padWithNoOps: false, forceWeakRemove: true }); const a = s.operationsA; for (const o of a) { e.addOperation(o); n.applyOperation(o); i.history.setOperationAsUndone(t, o) } } } } function qS(t) { t.sort(((t, e) => t.start.isBefore(e.start) ? -1 : 1)); for (let e = 1; e < t.length; e++) { const n = t[e - 1]; const i = n.getJoined(t[e], true); if (i) { e--; t.splice(e, 2, i) } } } function GS(t, e) { return e.some((e => e !== t && e.containsRange(t, true))) } class $S extends WS { execute(t = null) { const e = t ? this._stack.findIndex((e => e.batch == t)) : this._stack.length - 1; const n = this._stack.splice(e, 1)[0]; const i = this.editor.model.createBatch({ isUndo: true }); this.editor.model.enqueueChange(i, (() => { this._undo(n.batch, i); const t = this.editor.model.document.history.getOperations(n.batch.baseVersion); this._restoreSelection(n.selection.ranges, n.selection.isBackward, t); this.fire("revert", n.batch, i) })); this.refresh() } } class KS extends WS { execute() { const t = this._stack.pop(); const e = this.editor.model.createBatch({ isUndo: true }); this.editor.model.enqueueChange(e, (() => { const n = t.batch.operations[t.batch.operations.length - 1]; const i = n.baseVersion + 1; const o = this.editor.model.document.history.getOperations(i); this._restoreSelection(t.selection.ranges, t.selection.isBackward, o); this._undo(t.batch, e) })); this.refresh() } } class YS extends wl { constructor() { super(...arguments); this._batchRegistry = new WeakSet } static get pluginName() { return "UndoEditing" } init() { const t = this.editor; this._undoCommand = new $S(t); this._redoCommand = new KS(t); t.commands.add("undo", this._undoCommand); t.commands.add("redo", this._redoCommand); this.listenTo(t.model, "applyOperation", ((t, e) => { const n = e[0]; if (!n.isDocumentOperation) { return } const i = n.batch; const o = this._redoCommand.createdBatches.has(i); const r = this._undoCommand.createdBatches.has(i); const s = this._batchRegistry.has(i); if (s) { return } this._batchRegistry.add(i); if (!i.isUndoable) { return } if (o) { this._undoCommand.addBatch(i) } else if (!r) { this._undoCommand.addBatch(i); this._redoCommand.clearStack() } }), { priority: "highest" }); this.listenTo(this._undoCommand, "revert", ((t, e, n) => { this._redoCommand.addBatch(n) })); t.keystrokes.set("CTRL+Z", "undo"); t.keystrokes.set("CTRL+Y", "redo"); t.keystrokes.set("CTRL+SHIFT+Z", "redo") } } const QS = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>'; const ZS = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>'; class JS extends wl { static get pluginName() { return "UndoUI" } init() { const t = this.editor; const e = t.locale; const n = t.t; const i = e.uiLanguageDirection == "ltr" ? QS : ZS; const o = e.uiLanguageDirection == "ltr" ? ZS : QS; this._addButton("undo", n("Undo"), "CTRL+Z", i); this._addButton("redo", n("Redo"), "CTRL+Y", o) } _addButton(t, e, n, i) { const o = this.editor; o.ui.componentFactory.add(t, (r => { const s = o.commands.get(t); const a = new wC(r); a.set({ label: e, icon: i, keystroke: n, tooltip: true }); a.bind("isEnabled").to(s, "isEnabled"); this.listenTo(a, "execute", (() => { o.execute(t); o.editing.view.focus() })); return a })) } } class XS extends wl { static get requires() { return [YS, JS] } static get pluginName() { return "Undo" } } function tT(t) { return t.createContainerElement("span", { class: "image-inline" }, t.createEmptyElement("img")) } function eT(t) { return t.createContainerElement("figure", { class: "image" }, [t.createEmptyElement("img"), t.createSlot("children")]) } function nT(t, e) { const n = t.plugins.get("ImageUtils"); const i = t.plugins.has("ImageInlineEditing") && t.plugins.has("ImageBlockEditing"); return t => { if (!n.isInlineImageView(t)) { return null } if (!i) { return o(t) } const r = t.getStyle("display") == "block" || t.findAncestor(n.isBlockImageView) ? "imageBlock" : "imageInline"; if (r !== e) { return null } return o(t) }; function o(t) { const e = { name: true }; if (t.hasAttribute("src")) { e.attributes = ["src"] } return e } } function iT(t, e) { const n = ol(e.getSelectedBlocks()); if (!n || t.isObject(n)) { return "imageBlock" } if (n.isEmpty && n.name != "listItem") { return "imageBlock" } return "imageInline" } class oT extends wl { static get pluginName() { return "ImageUtils" } isImage(t) { return this.isInlineImage(t) || this.isBlockImage(t) } isInlineImageView(t) { return !!t && t.is("element", "img") } isBlockImageView(t) { return !!t && t.is("element", "figure") && t.hasClass("image") } insertImage(t = {}, e = null, n = null) { const i = this.editor; const o = i.model; const r = o.document.selection; n = cT(i, e || r, n); t = { ...Object.fromEntries(r.getAttributes()), ...t }; for (const e in t) { if (!o.schema.checkAttribute(n, e)) { delete t[e] } } return o.change((i => { const r = i.createElement(n, t); o.insertObject(r, e, null, { setSelection: "on", findOptimalPosition: !e && n != "imageInline" ? "auto" : undefined }); if (r.parent) { return r } return null })) } getClosestSelectedImageWidget(t) { const e = t.getFirstPosition(); if (!e) { return null } const n = t.getSelectedElement(); if (n && this.isImageWidget(n)) { return n } let i = e.parent; while (i) { if (i.is("element") && this.isImageWidget(i)) { return i } i = i.parent } return null } getClosestSelectedImageElement(t) { const e = t.getSelectedElement(); return this.isImage(e) ? e : t.getFirstPosition().findAncestor("imageBlock") } isImageAllowed() { const t = this.editor.model; const e = t.document.selection; return rT(this.editor, e) && sT(e) } toImageWidget(t, e, n) { e.setCustomProperty("image", true, t); const i = () => { const e = this.findViewImgElement(t); const i = e.getAttribute("alt"); return i ? `${i} ${n}` : n }; return kD(t, e, { label: i }) } isImageWidget(t) { return !!t.getCustomProperty("image") && bD(t) } isBlockImage(t) { return !!t && t.is("element", "imageBlock") } isInlineImage(t) { return !!t && t.is("element", "imageInline") } findViewImgElement(t) { if (this.isInlineImageView(t)) { return t } const e = this.editor.editing.view; for (const { item: n } of e.createRangeIn(t)) { if (this.isInlineImageView(n)) { return n } } } } function rT(t, e) { const n = cT(t, e, null); if (n == "imageBlock") { const n = aT(e, t.model); if (t.model.schema.checkChild(n, "imageBlock")) { return true } } else if (t.model.schema.checkChild(e.focus, "imageInline")) { return true } return false } function sT(t) { return [...t.focus.getAncestors()].every((t => !t.is("element", "imageBlock"))) } function aT(t, e) { const n = xD(t, e); const i = n.start.parent; if (i.isEmpty && !i.is("element", "$root")) { return i.parent } return i } function cT(t, e, n) { const i = t.model.schema; const o = t.config.get("image.insert.type"); if (!t.plugins.has("ImageBlockEditing")) { return "imageInline" } if (!t.plugins.has("ImageInlineEditing")) { return "imageBlock" } if (n) { return n } if (o === "inline") { return "imageInline" } if (o === "block") { return "imageBlock" } if (e.is("selection")) { return iT(i, e) } return i.checkChild(e, "imageInline") ? "imageInline" : "imageBlock" } const lT = new RegExp(String(/^(http(s)?:\/\/)?[\w-]+\.[\w.~:/[\]@!$&'()*+,;=%-]+/.source + /\.(jpg|jpeg|png|gif|ico|webp|JPG|JPEG|PNG|GIF|ICO|WEBP)/.source + /(\?[\w.~:/[\]@!$&'()*+,;=%-]*)?/.source + /(#[\w.~:/[\]@!$&'()*+,;=%-]*)?$/.source)); class dT extends wl { static get requires() { return [US, oT, XS, xE] } static get pluginName() { return "AutoImage" } constructor(t) { super(t); this._timeoutId = null; this._positionToInsert = null } init() { const t = this.editor; const e = t.model.document; const n = t.plugins.get("ClipboardPipeline"); this.listenTo(n, "inputTransformation", (() => { const t = e.selection.getFirstRange(); const n = Vk.fromPosition(t.start); n.stickiness = "toPrevious"; const i = Vk.fromPosition(t.end); i.stickiness = "toNext"; e.once("change:data", (() => { this._embedImageBetweenPositions(n, i); n.detach(); i.detach() }), { priority: "high" }) })); t.commands.get("undo").on("execute", (() => { if (this._timeoutId) { Za.window.clearTimeout(this._timeoutId); this._positionToInsert.detach(); this._timeoutId = null; this._positionToInsert = null } }), { priority: "high" }) } _embedImageBetweenPositions(t, e) { const n = this.editor; const i = new jf(t, e); const o = i.getWalker({ ignoreElementEnd: true }); const r = Object.fromEntries(n.model.document.selection.getAttributes()); const s = this.editor.plugins.get("ImageUtils"); let a = ""; for (const t of o) { if (t.item.is("$textProxy")) { a += t.item.data } } a = a.trim(); if (!a.match(lT)) { i.detach(); return } this._positionToInsert = Vk.fromPosition(t); this._timeoutId = setTimeout((() => { const t = n.commands.get("insertImage"); if (!t.isEnabled) { i.detach(); return } n.model.change((t => { this._timeoutId = null; t.remove(i); i.detach(); let e; if (this._positionToInsert.root.rootName !== "$graveyard") { e = this._positionToInsert.toPosition() } s.insertImage({ ...r, src: a }, e); this._positionToInsert.detach(); this._positionToInsert = null })); const e = n.plugins.get("Delete"); e.requestUndoOnBackspace() }), 100) } } function uT(t, e, n, i) { let o; let r = null; if (typeof i == "function") { o = i } else { r = t.commands.get(i); o = () => { t.execute(i) } } t.model.document.on("change:data", ((s, a) => { if (r && !r.isEnabled || !e.isEnabled) { return } const c = ol(t.model.document.selection.getRanges()); if (!c.isCollapsed) { return } if (a.isUndo || !a.isLocal) { return } const l = Array.from(t.model.document.differ.getChanges()); const d = l[0]; if (l.length != 1 || d.type !== "insert" || d.name != "$text" || d.length != 1) { return } const u = d.position.parent; if (u.is("element", "codeBlock")) { return } if (u.is("element", "listItem") && typeof i !== "function" && !["numberedList", "bulletedList", "todoList"].includes(i)) { return } if (r && r.value === true) { return } const h = u.getChild(0); const g = t.model.createRangeOn(h); if (!g.containsRange(c) && !c.end.isEqual(g.end)) { return } const m = n.exec(h.data.substr(0, c.end.offset)); if (!m) { return } t.model.enqueueChange((e => { const n = e.createPositionAt(u, 0); const i = e.createPositionAt(u, m[0].length); const r = new jf(n, i); const s = o({ match: m }); if (s !== false) { e.remove(r); const n = t.model.document.selection.getFirstRange(); const i = e.createRangeIn(u); if (u.isEmpty && !i.isEqual(n) && !i.containsRange(n, true)) { e.remove(u) } } r.detach(); t.model.enqueueChange((() => { const e = t.plugins.get("Delete"); e.requestUndoOnBackspace() })) })) })) } function hT(t, e, n, i) { let o; let r; if (n instanceof RegExp) { o = n } else { r = n } r = r || (t => { let e; const n = []; const i = []; while ((e = o.exec(t)) !== null) { if (e && e.length < 4) { break } let { index: t, 1: o, 2: r, 3: s } = e; const a = o + r + s; t += e[0].length - a.length; const c = [t, t + o.length]; const l = [t + o.length + r.length, t + o.length + r.length + s.length]; n.push(c); n.push(l); i.push([t + o.length, t + o.length + r.length]) } return { remove: n, format: i } }); t.model.document.on("change:data", ((n, o) => { if (o.isUndo || !o.isLocal || !e.isEnabled) { return } const s = t.model; const a = s.document.selection; if (!a.isCollapsed) { return } const c = Array.from(s.document.differ.getChanges()); const l = c[0]; if (c.length != 1 || l.type !== "insert" || l.name != "$text" || l.length != 1) { return } const d = a.focus; const u = d.parent; const { text: h, range: g } = mT(s.createRange(s.createPositionAt(u, 0), d), s); const m = r(h); const f = gT(g.start, m.format, s); const p = gT(g.start, m.remove, s); if (!(f.length && p.length)) { return } s.enqueueChange((e => { const n = i(e, f); if (n === false) { return } for (const t of p.reverse()) { e.remove(t) } s.enqueueChange((() => { const e = t.plugins.get("Delete"); e.requestUndoOnBackspace() })) })) })) } function gT(t, e, n) { return e.filter((t => t[0] !== undefined && t[1] !== undefined)).map((e => n.createRange(t.getShiftedBy(e[0]), t.getShiftedBy(e[1])))) } function mT(t, e) { let n = t.start; const i = Array.from(t.getItems()).reduce(((t, i) => { if (!(i.is("$text") || i.is("$textProxy")) || i.getAttribute("code")) { n = e.createPositionAfter(i); return "" } return t + i.data }), ""); return { text: i, range: e.createRange(n, t.end) } } class fT extends wl { static get requires() { return [xE] } static get pluginName() { return "Autoformat" } afterInit() { this._addListAutoformats(); this._addBasicStylesAutoformats(); this._addHeadingAutoformats(); this._addBlockQuoteAutoformats(); this._addCodeBlockAutoformats(); this._addHorizontalLineAutoformats() } _addListAutoformats() { const t = this.editor.commands; if (t.get("bulletedList")) { uT(this.editor, this, /^[*-]\s$/, "bulletedList") } if (t.get("numberedList")) { uT(this.editor, this, /^1[.|)]\s$/, "numberedList") } if (t.get("todoList")) { uT(this.editor, this, /^\[\s?\]\s$/, "todoList") } if (t.get("checkTodoList")) { uT(this.editor, this, /^\[\s?x\s?\]\s$/, (() => { this.editor.execute("todoList"); this.editor.execute("checkTodoList") })) } } _addBasicStylesAutoformats() { const t = this.editor.commands; if (t.get("bold")) { const t = pT(this.editor, "bold"); hT(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, t); hT(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, t) } if (t.get("italic")) { const t = pT(this.editor, "italic"); hT(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, t); hT(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, t) } if (t.get("code")) { const t = pT(this.editor, "code"); hT(this.editor, this, /(`)([^`]+)(`)$/g, t) } if (t.get("strikethrough")) { const t = pT(this.editor, "strikethrough"); hT(this.editor, this, /(~~)([^~]+)(~~)$/g, t) } } _addHeadingAutoformats() { const t = this.editor.commands.get("heading"); if (t) { t.modelElements.filter((t => t.match(/^heading[1-6]$/))).forEach((e => { const n = e[7]; const i = new RegExp(`^(#{${n}})\\s$`); uT(this.editor, this, i, (() => { if (!t.isEnabled || t.value === e) { return false } this.editor.execute("heading", { value: e }) })) })) } } _addBlockQuoteAutoformats() { if (this.editor.commands.get("blockQuote")) { uT(this.editor, this, /^>\s$/, "blockQuote") } } _addCodeBlockAutoformats() { const t = this.editor; const e = t.model.document.selection; if (t.commands.get("codeBlock")) { uT(t, this, /^```$/, (() => { if (e.getFirstPosition().parent.is("element", "listItem")) { return false } this.editor.execute("codeBlock", { usePreviousLanguageChoice: true }) })) } } _addHorizontalLineAutoformats() { if (this.editor.commands.get("horizontalLine")) { uT(this.editor, this, /^---$/, "horizontalLine") } } } function pT(t, e) { return (n, i) => { const o = t.commands.get(e); if (!o.isEnabled) { return false } const r = t.model.schema.getValidRanges(i, e); for (const t of r) { n.setAttribute(e, true, t) } n.removeSelectionAttribute(e) } } function bT(t, e, n) { var i = t.length; n = n === undefined ? i : n; return !e && n >= i ? t : Fd(t, e, n) } const kT = bT; var wT = "\\ud800-\\udfff", AT = "\\u0300-\\u036f", _T = "\\ufe20-\\ufe2f", CT = "\\u20d0-\\u20ff", vT = AT + _T + CT, yT = "\\ufe0e\\ufe0f"; var xT = "\\u200d"; var ET = RegExp("[" + xT + wT + vT + yT + "]"); function DT(t) { return ET.test(t) } const ST = DT; function TT(t) { return t.split("") } const IT = TT; var MT = "\\ud800-\\udfff", BT = "\\u0300-\\u036f", LT = "\\ufe20-\\ufe2f", NT = "\\u20d0-\\u20ff", zT = BT + LT + NT, PT = "\\ufe0e\\ufe0f"; var OT = "[" + MT + "]", RT = "[" + zT + "]", VT = "\\ud83c[\\udffb-\\udfff]", jT = "(?:" + RT + "|" + VT + ")", FT = "[^" + MT + "]", HT = "(?:\\ud83c[\\udde6-\\uddff]){2}", UT = "[\\ud800-\\udbff][\\udc00-\\udfff]", WT = "\\u200d"; var qT = jT + "?", GT = "[" + PT + "]?", $T = "(?:" + WT + "(?:" + [FT, HT, UT].join("|") + ")" + GT + qT + ")*", KT = GT + qT + $T, YT = "(?:" + [FT + RT + "?", RT, HT, UT, OT].join("|") + ")"; var QT = RegExp(VT + "(?=" + VT + ")|" + YT + KT, "g"); function ZT(t) { return t.match(QT) || [] } const JT = ZT; function XT(t) { return ST(t) ? JT(t) : IT(t) } const tI = XT; function eI(t) { return function (e) { e = Id(e); var n = ST(e) ? tI(e) : undefined; var i = n ? n[0] : e.charAt(0); var o = n ? kT(n, 1).join("") : e.slice(1); return i[t]() + o } } const nI = eI; var iI = nI("toUpperCase"); const oI = iI; const rI = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g; const sI = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i; const aI = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i; const cI = /^((\w+:(\/{2,})?)|(\W))/i; const lI = "Ctrl+K"; function dI(t) { return t.is("attributeElement") && !!t.getCustomProperty("link") } function uI(t, { writer: e }) { const n = e.createAttributeElement("a", { href: t }, { priority: 5 }); e.setCustomProperty("link", true, n); return n } function hI(t) { const e = String(t); return gI(e) ? e : "#" } function gI(t) { const e = t.replace(rI, ""); return !!e.match(sI) } function mI(t, e) { const n = { "Open in a new tab": t("Open in a new tab"), Downloadable: t("Downloadable") }; e.forEach((t => { if ("label" in t && n[t.label]) { t.label = n[t.label] } return t })); return e } function fI(t) { const e = []; if (t) { for (const [n, i] of Object.entries(t)) { const t = Object.assign({}, i, { id: `link${oI(n)}` }); e.push(t) } } return e } function pI(t, e) { if (!t) { return false } return e.checkAttribute(t.name, "linkHref") } function bI(t) { return aI.test(t) } function kI(t, e) { const n = bI(t) ? "mailto:" : e; const i = !!n && !wI(t); return t && i ? n + t : t } function wI(t) { return cI.test(t) } function AI(t) { window.open(t, "_blank", "noopener") } const _I = 4; const CI = new RegExp("(^|\\s)" + "(" + "(" + "(?:(?:(?:https?|ftp):)?\\/\\/)" + "(?:\\S+(?::\\S*)?@)?" + "(?:" + "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" + "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" + "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" + "|" + "(" + "((?!www\\.)|(www\\.))" + "(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+" + "(?:[a-z\\u00a1-\\uffff]{2,63})" + ")" + ")" + "(?::\\d{2,5})?" + "(?:[/?#]\\S*)?" + ")" + "|" + "(" + "(www.|(\\S+@))" + "((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+" + "(?:[a-z\\u00a1-\\uffff]{2,63})" + ")" + ")$", "i"); const vI = 2; class yI extends wl { static get requires() { return [xE] } static get pluginName() { return "AutoLink" } init() { const t = this.editor; const e = t.model.document.selection; e.on("change:range", (() => { this.isEnabled = !e.anchor.parent.is("element", "codeBlock") })); this._enableTypingHandling() } afterInit() { this._enableEnterHandling(); this._enableShiftEnterHandling() } _enableTypingHandling() { const t = this.editor; const e = new SE(t.model, (t => { if (!xI(t)) { return } const e = EI(t.substr(0, t.length - 1)); if (e) { return { url: e } } })); e.on("matched:data", ((e, n) => { const { batch: i, range: o, url: r } = n; if (!i.isTyping) { return } const s = o.end.getShiftedBy(-1); const a = s.getShiftedBy(-r.length); const c = t.model.createRange(a, s); this._applyAutoLink(r, c) })); e.bind("isEnabled").to(this) } _enableEnterHandling() { const t = this.editor; const e = t.model; const n = t.commands.get("enter"); if (!n) { return } n.on("execute", (() => { const t = e.document.selection.getFirstPosition(); if (!t.parent.previousSibling) { return } const n = e.createRangeIn(t.parent.previousSibling); this._checkAndApplyAutoLinkOnRange(n) })) } _enableShiftEnterHandling() { const t = this.editor; const e = t.model; const n = t.commands.get("shiftEnter"); if (!n) { return } n.on("execute", (() => { const t = e.document.selection.getFirstPosition(); const n = e.createRange(e.createPositionAt(t.parent, 0), t.getShiftedBy(-1)); this._checkAndApplyAutoLinkOnRange(n) })) } _checkAndApplyAutoLinkOnRange(t) { const e = this.editor.model; const { text: n, range: i } = DE(t, e); const o = EI(n); if (o) { const t = e.createRange(i.end.getShiftedBy(-o.length), i.end); this._applyAutoLink(o, t) } } _applyAutoLink(t, e) { const n = this.editor.model; const i = this.editor.config.get("link.defaultProtocol"); const o = kI(t, i); if (!this.isEnabled || !DI(e, n) || !wI(o) || SI(e)) { return } this._persistAutoLink(o, e) } _persistAutoLink(t, e) { const n = this.editor.model; const i = this.editor.plugins.get("Delete"); n.enqueueChange((o => { o.setAttribute("linkHref", t, e); n.enqueueChange((() => { i.requestUndoOnBackspace() })) })) } } function xI(t) { return t.length > _I && t[t.length - 1] === " " && t[t.length - 2] !== " " } function EI(t) { const e = CI.exec(t); return e ? e[vI] : null } function DI(t, e) { return e.schema.checkAttributeInSelection(e.createSelection(t), "linkHref") } function SI(t) { const e = t.start.nodeAfter; return !!e && e.hasAttribute("linkHref") } class TI extends wl { static get pluginName() { return "Autosave" } static get requires() { return [HA] } constructor(t) { super(t); this._action = null; const e = t.config.get("autosave") || {}; const n = e.waitingTime || 1e3; this.set("state", "synchronized"); this._debouncedSave = Yg(this._save.bind(this), n); this._lastDocumentVersion = t.model.document.version; this._savePromise = null; this._domEmitter = new (Ga()); this._config = e; this._pendingActions = t.plugins.get(HA); this._makeImmediateSave = false } init() { const t = this.editor; const e = t.model.document; this.listenTo(t, "ready", (() => { this.listenTo(e, "change:data", ((t, e) => { if (!this._saveCallbacks.length) { return } if (!e.isLocal) { return } if (this.state === "synchronized") { this.state = "waiting"; this._setPendingAction() } if (this.state === "waiting") { this._debouncedSave() } })) })); this.listenTo(t, "destroy", (() => this._flush()), { priority: "highest" }); this._domEmitter.listenTo(window, "beforeunload", ((t, e) => { if (this._pendingActions.hasAny) { e.returnValue = this._pendingActions.first.message } })) } destroy() { this._domEmitter.stopListening(); super.destroy() } save() { this._debouncedSave.cancel(); return this._save() } _flush() { this._debouncedSave.flush() } _save() { if (this._savePromise) { this._makeImmediateSave = this.editor.model.document.version > this._lastDocumentVersion; return this._savePromise } this._setPendingAction(); this.state = "saving"; this._lastDocumentVersion = this.editor.model.document.version; this._savePromise = Promise.resolve().then((() => Promise.all(this._saveCallbacks.map((t => t(this.editor)))))).finally((() => { this._savePromise = null })).then((() => { if (this._makeImmediateSave) { this._makeImmediateSave = false; return this._save() } else { if (this.editor.model.document.version > this._lastDocumentVersion) { this.state = "waiting"; this._debouncedSave() } else { this.state = "synchronized"; this._pendingActions.remove(this._action); this._action = null } } })).catch((t => { this.state = "error"; this.state = "saving"; this._debouncedSave(); throw t })); return this._savePromise } _setPendingAction() { const t = this.editor.t; if (!this._action) { this._action = this._pendingActions.add(t("Saving changes")) } } get _saveCallbacks() { const t = []; if (this.adapter && this.adapter.save) { t.push(this.adapter.save) } if (this._config.save) { t.push(this._config.save) } return t } } class II extends _l { refresh() { this.value = this._getValue(); this.isEnabled = this._checkEnabled() } execute(t = {}) { const e = this.editor.model; const n = e.schema; const i = e.document.selection; const o = Array.from(i.getSelectedBlocks()); const r = t.forceValue === undefined ? !this.value : t.forceValue; e.change((t => { if (!r) { this._removeQuote(t, o.filter(MI)) } else { const e = o.filter((t => MI(t) || LI(n, t))); this._applyQuote(t, e) } })) } _getValue() { const t = this.editor.model.document.selection; const e = ol(t.getSelectedBlocks()); return !!(e && MI(e)) } _checkEnabled() { if (this.value) { return true } const t = this.editor.model.document.selection; const e = this.editor.model.schema; const n = ol(t.getSelectedBlocks()); if (!n) { return false } return LI(e, n) } _removeQuote(t, e) { BI(t, e).reverse().forEach((e => { if (e.start.isAtStart && e.end.isAtEnd) { t.unwrap(e.start.parent); return } if (e.start.isAtStart) { const n = t.createPositionBefore(e.start.parent); t.move(e, n); return } if (!e.end.isAtEnd) { t.split(e.end) } const n = t.createPositionAfter(e.end.parent); t.move(e, n) })) } _applyQuote(t, e) { const n = []; BI(t, e).reverse().forEach((e => { let i = MI(e.start); if (!i) { i = t.createElement("blockQuote"); t.wrap(e, i) } n.push(i) })); n.reverse().reduce(((e, n) => { if (e.nextSibling == n) { t.merge(t.createPositionAfter(e)); return e } return n })) } } function MI(t) { return t.parent.name == "blockQuote" ? t.parent : null } function BI(t, e) { let n; let i = 0; const o = []; while (i < e.length) { const r = e[i]; const s = e[i + 1]; if (!n) { n = t.createPositionBefore(r) } if (!s || r.nextSibling != s) { o.push(t.createRange(n, t.createPositionAfter(r))); n = null } i++ } return o } function LI(t, e) { const n = t.checkChild(e.parent, "blockQuote"); const i = t.checkChild(["$root", "blockQuote"], e); return n && i } class NI extends wl { static get pluginName() { return "BlockQuoteEditing" } static get requires() { return [iD, xE] } init() { const t = this.editor; const e = t.model.schema; t.commands.add("blockQuote", new II(t)); e.register("blockQuote", { inheritAllFrom: "$container" }); t.conversion.elementToElement({ model: "blockQuote", view: "blockquote" }); t.model.document.registerPostFixer((n => { const i = t.model.document.differ.getChanges(); for (const t of i) { if (t.type == "insert") { const i = t.position.nodeAfter; if (!i) { continue } if (i.is("element", "blockQuote") && i.isEmpty) { n.remove(i); return true } else if (i.is("element", "blockQuote") && !e.checkChild(t.position, i)) { n.unwrap(i); return true } else if (i.is("element")) { const t = n.createRangeIn(i); for (const i of t.getItems()) { if (i.is("element", "blockQuote") && !e.checkChild(n.createPositionBefore(i), i)) { n.unwrap(i); return true } } } } else if (t.type == "remove") { const e = t.position.parent; if (e.is("element", "blockQuote") && e.isEmpty) { n.remove(e); return true } } } return false })); const n = this.editor.editing.view.document; const i = t.model.document.selection; const o = t.commands.get("blockQuote"); this.listenTo(n, "enter", ((e, n) => { if (!i.isCollapsed || !o.value) { return } const r = i.getLastPosition().parent; if (r.isEmpty) { t.execute("blockQuote"); t.editing.view.scrollToTheSelection(); n.preventDefault(); e.stop() } }), { context: "blockquote" }); this.listenTo(n, "delete", ((e, n) => { if (n.direction != "backward" || !i.isCollapsed || !o.value) { return } const r = i.getLastPosition().parent; if (r.isEmpty && !r.previousSibling) { t.execute("blockQuote"); t.editing.view.scrollToTheSelection(); n.preventDefault(); e.stop() } }), { context: "blockquote" }) } } var zI = n(636); var PI = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; PI.insert = "head"; PI.singleton = true; var OI = Sl()(zI.Z, PI); const RI = zI.Z.locals || {}; class VI extends wl { static get pluginName() { return "BlockQuoteUI" } init() { const t = this.editor; const e = t.t; t.ui.componentFactory.add("blockQuote", (n => { const i = t.commands.get("blockQuote"); const o = new wC(n); o.set({ label: e("Block quote"), icon: v_.quote, tooltip: true, isToggleable: true }); o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"); this.listenTo(o, "execute", (() => { t.execute("blockQuote"); t.editing.view.focus() })); return o })) } } class jI extends wl { static get requires() { return [NI, VI] } static get pluginName() { return "BlockQuote" } } class FI extends _l { constructor(t, e) { super(t); this.attributeKey = e } refresh() { const t = this.editor.model; const e = t.document; this.value = this._getValueFromFirstAllowedNode(); this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey) } execute(t = {}) { const e = this.editor.model; const n = e.document; const i = n.selection; const o = t.forceValue === undefined ? !this.value : t.forceValue; e.change((t => { if (i.isCollapsed) { if (o) { t.setSelectionAttribute(this.attributeKey, true) } else { t.removeSelectionAttribute(this.attributeKey) } } else { const n = e.schema.getValidRanges(i.getRanges(), this.attributeKey); for (const e of n) { if (o) { t.setAttribute(this.attributeKey, o, e) } else { t.removeAttribute(this.attributeKey, e) } } } })) } _getValueFromFirstAllowedNode() { const t = this.editor.model; const e = t.schema; const n = t.document.selection; if (n.isCollapsed) { return n.hasAttribute(this.attributeKey) } for (const t of n.getRanges()) { for (const n of t.getItems()) { if (e.checkAttribute(n, this.attributeKey)) { return n.hasAttribute(this.attributeKey) } } } return false } } const HI = "bold"; class UI extends wl { static get pluginName() { return "BoldEditing" } init() { const t = this.editor; t.model.schema.extend("$text", { allowAttributes: HI }); t.model.schema.setAttributeProperties(HI, { isFormatting: true, copyOnEnter: true }); t.conversion.attributeToElement({ model: HI, view: "strong", upcastAlso: ["b", t => { const e = t.getStyle("font-weight"); if (!e) { return null } if (e == "bold" || Number(e) >= 600) { return { name: true, styles: ["font-weight"] } } return null }] }); t.commands.add(HI, new FI(t, HI)); t.keystrokes.set("CTRL+B", HI) } } const WI = "bold"; class qI extends wl { static get pluginName() { return "BoldUI" } init() { const t = this.editor; const e = t.t; t.ui.componentFactory.add(WI, (n => { const i = t.commands.get(WI); const o = new wC(n); o.set({ label: e("Bold"), icon: v_.bold, keystroke: "CTRL+B", tooltip: true, isToggleable: true }); o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"); this.listenTo(o, "execute", (() => { t.execute(WI); t.editing.view.focus() })); return o })) } } class GI extends wl { static get requires() { return [UI, qI] } static get pluginName() { return "Bold" } } const $I = "code"; const KI = "ck-code_selected"; class YI extends wl { static get pluginName() { return "CodeEditing" } static get requires() { return [TE] } init() { const t = this.editor; t.model.schema.extend("$text", { allowAttributes: $I }); t.model.schema.setAttributeProperties($I, { isFormatting: true, copyOnEnter: false }); t.conversion.attributeToElement({ model: $I, view: "code", upcastAlso: { styles: { "word-wrap": "break-word" } } }); t.commands.add($I, new FI(t, $I)); t.plugins.get(TE).registerAttribute($I); ZE(t, $I, "code", KI) } } const QI = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 5.7 5.2 3.9v1.3l-5.6 4c-.1.2-.3.2-.5.2-.3-.1-.6-.7-.6-1l.3-.4 4.7-3.5L11.5 7l-.2-.2c-.1-.3-.1-.6 0-.8.2-.2.5-.4.8-.4a.8.8 0 0 1 .4.1zm-5.2 0L2 9.6v1.3l5.6 4c.1.2.3.2.5.2.3-.1.7-.7.6-1 0-.1 0-.3-.2-.4l-5-3.5L8.2 7l.2-.2c.1-.3.1-.6 0-.8-.2-.2-.5-.4-.8-.4a.8.8 0 0 0-.3.1z"/></svg>'; var ZI = n(8180); var JI = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; JI.insert = "head"; JI.singleton = true; var XI = Sl()(ZI.Z, JI); const tM = ZI.Z.locals || {}; const eM = "code"; class nM extends wl { static get pluginName() { return "CodeUI" } init() { const t = this.editor; const e = t.t; t.ui.componentFactory.add(eM, (n => { const i = t.commands.get(eM); const o = new wC(n); o.set({ label: e("Code"), icon: QI, tooltip: true, isToggleable: true }); o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"); this.listenTo(o, "execute", (() => { t.execute(eM); t.editing.view.focus() })); return o })) } } class iM extends wl { static get requires() { return [YI, nM] } static get pluginName() { return "Code" } } function oM(t) { const e = t.t; const n = t.config.get("codeBlock.languages"); for (const t of n) { if (t.label === "Plain text") { t.label = e("Plain text") } if (t.class === undefined) { t.class = `language-${t.language}` } } return n } function rM(t, e, n) { const i = {}; for (const o of t) { if (e === "class") { const t = o[e].split(" ").shift(); i[t] = o[n] } else { i[o[e]] = o[n] } } return i } function sM(t) { return t.data.match(/^(\s*)/)[0] } function aM(t, e) { const n = t.createDocumentFragment(); const i = e.split("\n"); const o = i.reduce(((e, n, o) => { e.push(n); if (o < i.length - 1) { e.push(t.createElement("br")) } return e }), []); t.appendChild(o, n); return n } function cM(t) { const e = t.document.selection; const n = []; if (e.isCollapsed) { return [e.anchor] } const i = e.getFirstRange().getWalker({ ignoreElementEnd: true, direction: "backward" }); for (const { item: e } of i) { if (!e.is("$textProxy")) { continue } const { parent: i, startOffset: o } = e.textNode; if (!i.is("element", "codeBlock")) { continue } const r = sM(e.textNode); const s = t.createPositionAt(i, o + r.length); n.push(s) } return n } function lM(t) { const e = ol(t.getSelectedBlocks()); return !!e && e.is("element", "codeBlock") } function dM(t, e) { if (e.is("rootElement") || t.isLimit(e)) { return false } return t.checkChild(e.parent, "codeBlock") } class uM extends _l { constructor(t) { super(t); this._lastLanguage = null } refresh() { this.value = this._getValue(); this.isEnabled = this._checkEnabled() } execute(t = {}) { const e = this.editor; const n = e.model; const i = n.document.selection; const o = oM(e); const r = o[0]; const s = Array.from(i.getSelectedBlocks()); const a = t.forceValue == undefined ? !this.value : t.forceValue; const c = hM(t, this._lastLanguage, r.language); n.change((t => { if (a) { this._applyCodeBlock(t, s, c) } else { this._removeCodeBlock(t, s) } })) } _getValue() { const t = this.editor.model.document.selection; const e = ol(t.getSelectedBlocks()); const n = !!(e && e.is("element", "codeBlock")); return n ? e.getAttribute("language") : false } _checkEnabled() { if (this.value) { return true } const t = this.editor.model.document.selection; const e = this.editor.model.schema; const n = ol(t.getSelectedBlocks()); if (!n) { return false } return dM(e, n) } _applyCodeBlock(t, e, n) { this._lastLanguage = n; const i = this.editor.model.schema; const o = e.filter((t => dM(i, t))); for (const e of o) { t.rename(e, "codeBlock"); t.setAttribute("language", n, e); i.removeDisallowedAttributes([e], t); Array.from(e.getChildren()).filter((t => !i.checkChild(e, t))).forEach((e => t.remove(e))) } o.reverse().forEach(((e, n) => { const i = o[n + 1]; if (e.previousSibling === i) { t.appendElement("softBreak", i); t.merge(t.createPositionBefore(e)) } })) } _removeCodeBlock(t, e) { const n = e.filter((t => t.is("element", "codeBlock"))); for (const e of n) { const n = t.createRangeOn(e); for (const e of Array.from(n.getItems()).reverse()) { if (e.is("element", "softBreak") && e.parent.is("element", "codeBlock")) { const { position: n } = t.split(t.createPositionBefore(e)); const i = n.nodeAfter; t.rename(i, "paragraph"); t.removeAttribute("language", i); t.remove(e) } } t.rename(e, "paragraph"); t.removeAttribute("language", e) } } } function hM(t, e, n) { if (t.language) { return t.language } if (t.usePreviousLanguageChoice && e) { return e } return n } class gM extends _l { constructor(t) { super(t); this._indentSequence = t.config.get("codeBlock.indentSequence") } refresh() { this.isEnabled = this._checkEnabled() } execute() { const t = this.editor; const e = t.model; e.change((t => { const n = cM(e); for (const i of n) { const n = t.createText(this._indentSequence); e.insertContent(n, i) } })) } _checkEnabled() { if (!this._indentSequence) { return false } return lM(this.editor.model.document.selection) } } class mM extends _l { constructor(t) { super(t); this._indentSequence = t.config.get("codeBlock.indentSequence") } refresh() { this.isEnabled = this._checkEnabled() } execute() { const t = this.editor; const e = t.model; e.change((() => { const t = cM(e); for (const n of t) { const t = fM(e, n, this._indentSequence); if (t) { e.deleteContent(e.createSelection(t)) } } })) } _checkEnabled() { if (!this._indentSequence) { return false } const t = this.editor.model; if (!lM(t.document.selection)) { return false } return cM(t).some((e => fM(t, e, this._indentSequence))) } } function fM(t, e, n) { const i = pM(e); if (!i) { return null } const o = sM(i); const r = o.lastIndexOf(n); if (r + n.length !== o.length) { return null } if (r === -1) { return null } const { parent: s, startOffset: a } = i; return t.createRange(t.createPositionAt(s, a + r), t.createPositionAt(s, a + r + n.length)) } function pM(t) { let e = t.parent.getChild(t.index); if (!e || e.is("element", "softBreak")) { e = t.nodeBefore } if (!e || e.is("element", "softBreak")) { return null } return e } function bM(t, e, n = false) { const i = rM(e, "language", "class"); const o = rM(e, "language", "label"); return (e, r, s) => { const { writer: a, mapper: c, consumable: l } = s; if (!l.consume(r.item, "insert")) { return } const d = r.item.getAttribute("language"); const u = c.toViewPosition(t.createPositionBefore(r.item)); const h = {}; if (n) { h["data-language"] = o[d]; h.spellcheck = "false" } const g = i[d] ? { class: i[d] } : undefined; const m = a.createContainerElement("code", g); const f = a.createContainerElement("pre", h, m); a.insert(u, f); c.bindElements(r.item, m) } } function kM(t) { return (e, n, i) => { if (n.item.parent.name !== "codeBlock") { return } const { writer: o, mapper: r, consumable: s } = i; if (!s.consume(n.item, "insert")) { return } const a = r.toViewPosition(t.createPositionBefore(n.item)); o.insert(a, o.createText("\n")) } } function wM(t, e) { const n = rM(e, "class", "language"); const i = e[0].language; return (t, e, o) => { const r = e.viewItem; const s = r.parent; if (!s || !s.is("element", "pre")) { return } if (e.modelCursor.findAncestor("codeBlock")) { return } const { consumable: a, writer: c } = o; if (!a.test(r, { name: true })) { return } const l = c.createElement("codeBlock"); const d = [...r.getClassNames()]; if (!d.length) { d.push("") } for (const t of d) { const e = n[t]; if (e) { c.setAttribute("language", e, l); break } } if (!l.hasAttribute("language")) { c.setAttribute("language", i, l) } o.convertChildren(r, l); if (!o.safeInsert(l, e.modelCursor)) { return } a.consume(r, { name: true }); o.updateConversionResult(l, e) } } function AM() { return (t, e, { consumable: n, writer: i }) => { let o = e.modelCursor; if (!n.test(e.viewItem)) { return } if (!o.findAncestor("codeBlock")) { return } n.consume(e.viewItem); const r = e.viewItem.data; const s = r.split("\n").map((t => i.createText(t))); const a = s[s.length - 1]; for (const t of s) { i.insert(t, o); o = o.getShiftedBy(t.offsetSize); if (t !== a) { const t = i.createElement("softBreak"); i.insert(t, o); o = i.createPositionAfter(t) } } e.modelRange = i.createRange(e.modelCursor, o); e.modelCursor = o } } function _M() { return (t, e, { consumable: n }) => { const i = e.viewItem; if (i.findAncestor("pre")) { return } const o = Array.from(i.getChildren()); const r = o.find((t => t.is("element", "code"))); if (!r) { return } for (const t of o) { if (t === r || !t.is("$text")) { continue } n.consume(t, { name: true }) } } } const CM = "paragraph"; class vM extends wl { static get pluginName() { return "CodeBlockEditing" } static get requires() { return [lD] } constructor(t) { super(t); t.config.define("codeBlock", { languages: [{ language: "plaintext", label: "Plain text" }, { language: "c", label: "C" }, { language: "cs", label: "C#" }, { language: "cpp", label: "C++" }, { language: "css", label: "CSS" }, { language: "diff", label: "Diff" }, { language: "html", label: "HTML" }, { language: "java", label: "Java" }, { language: "javascript", label: "JavaScript" }, { language: "php", label: "PHP" }, { language: "python", label: "Python" }, { language: "ruby", label: "Ruby" }, { language: "typescript", label: "TypeScript" }, { language: "xml", label: "XML" }], indentSequence: "\t" }) } init() { const t = this.editor; const e = t.model.schema; const n = t.model; const i = t.editing.view; const o = t.plugins.has("DocumentListEditing"); const r = oM(t); t.commands.add("codeBlock", new uM(t)); t.commands.add("indentCodeBlock", new gM(t)); t.commands.add("outdentCodeBlock", new mM(t)); this.listenTo(i.document, "tab", ((e, n) => { const i = n.shiftKey ? "outdentCodeBlock" : "indentCodeBlock"; const o = t.commands.get(i); if (!o.isEnabled) { return } t.execute(i); n.stopPropagation(); n.preventDefault(); e.stop() }), { context: "pre" }); e.register("codeBlock", { allowWhere: "$block", allowChildren: "$text", isBlock: true, allowAttributes: ["language"] }); e.addAttributeCheck(((t, e) => { const n = t.endsWith("codeBlock") && e.startsWith("list") && e !== "list"; if (o && n) { return true } if (t.endsWith("codeBlock $text")) { return false } })); t.model.schema.addChildCheck(((t, e) => { if (t.endsWith("codeBlock") && e.isObject) { return false } })); t.editing.downcastDispatcher.on("insert:codeBlock", bM(n, r, true)); t.data.downcastDispatcher.on("insert:codeBlock", bM(n, r)); t.data.downcastDispatcher.on("insert:softBreak", kM(n), { priority: "high" }); t.data.upcastDispatcher.on("element:code", wM(i, r)); t.data.upcastDispatcher.on("text", AM()); t.data.upcastDispatcher.on("element:pre", _M(), { priority: "high" }); this.listenTo(t.editing.view.document, "clipboardInput", ((e, i) => { let o = n.createRange(n.document.selection.anchor); if (i.targetRanges) { o = t.editing.mapper.toModelRange(i.targetRanges[0]) } if (!o.start.parent.is("element", "codeBlock")) { return } const r = i.dataTransfer.getData("text/plain"); const s = new Uw(t.editing.view.document); i.content = aM(s, r) })); this.listenTo(n, "getSelectedContent", ((t, [i]) => { const o = i.anchor; if (i.isCollapsed || !o.parent.is("element", "codeBlock") || !o.hasSameParentAs(i.focus)) { return } n.change((n => { const r = t.return; if (o.parent.is("element") && (r.childCount > 1 || i.containsEntireContent(o.parent))) { const e = n.createElement("codeBlock", o.parent.getAttributes()); n.append(r, e); const i = n.createDocumentFragment(); n.append(e, i); t.return = i; return } const s = r.getChild(0); if (e.checkAttribute(s, "code")) { n.setAttribute("code", true, s) } })) })) } afterInit() { const t = this.editor; const e = t.commands; const n = e.get("indent"); const i = e.get("outdent"); if (n) { n.registerChildCommand(e.get("indentCodeBlock"), { priority: "highest" }) } if (i) { i.registerChildCommand(e.get("outdentCodeBlock")) } this.listenTo(t.editing.view.document, "enter", ((e, n) => { const i = t.model.document.selection.getLastPosition().parent; if (!i.is("element", "codeBlock")) { return } if (!xM(t, n.isSoft) && !EM(t, n.isSoft)) { yM(t) } n.preventDefault(); e.stop() }), { context: "pre" }) } } function yM(t) { const e = t.model; const n = e.document; const i = n.selection.getLastPosition(); const o = i.nodeBefore || i.textNode; let r; if (o && o.is("$text")) { r = sM(o) } t.model.change((e => { t.execute("shiftEnter"); if (r) { e.insertText(r, n.selection.anchor) } })) } function xM(t, e) { const n = t.model; const i = n.document; const o = t.editing.view; const r = i.selection.getLastPosition(); const s = r.nodeAfter; if (e || !i.selection.isCollapsed || !r.isAtStart) { return false } if (!SM(s)) { return false } t.model.change((e => { t.execute("enter"); const n = i.selection.anchor.parent.previousSibling; e.rename(n, CM); e.setSelection(n, "in"); t.model.schema.removeDisallowedAttributes([n], e); e.remove(s) })); o.scrollToTheSelection(); return true } function EM(t, e) { const n = t.model; const i = n.document; const o = t.editing.view; const r = i.selection.getLastPosition(); const s = r.nodeBefore; let a; if (e || !i.selection.isCollapsed || !r.isAtEnd || !s || !s.previousSibling) { return false } if (SM(s) && SM(s.previousSibling)) { a = n.createRange(n.createPositionBefore(s.previousSibling), n.createPositionAfter(s)) } else if (DM(s) && SM(s.previousSibling) && SM(s.previousSibling.previousSibling)) { a = n.createRange(n.createPositionBefore(s.previousSibling.previousSibling), n.createPositionAfter(s)) } else if (DM(s) && SM(s.previousSibling) && DM(s.previousSibling.previousSibling) && s.previousSibling.previousSibling && SM(s.previousSibling.previousSibling.previousSibling)) { a = n.createRange(n.createPositionBefore(s.previousSibling.previousSibling.previousSibling), n.createPositionAfter(s)) } else { return false } t.model.change((e => { e.remove(a); t.execute("enter"); const n = i.selection.anchor.parent; e.rename(n, CM); t.model.schema.removeDisallowedAttributes([n], e) })); o.scrollToTheSelection(); return true } function DM(t) { return t && t.is("$text") && !t.data.match(/\S/) } function SM(t) { return t && t.is("element", "softBreak") } const TM = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.87 12.61a.75.75 0 0 1-.089.976l-.085.07-3.154 2.254 3.412 2.414a.75.75 0 0 1 .237.95l-.057.095a.75.75 0 0 1-.95.237l-.096-.058-4.272-3.022-.003-1.223 4.01-2.867a.75.75 0 0 1 1.047.174zm2.795-.231.095.057 4.011 2.867-.003 1.223-4.272 3.022-.095.058a.75.75 0 0 1-.88-.151l-.07-.086-.058-.095a.75.75 0 0 1 .15-.88l.087-.07 3.412-2.414-3.154-2.253-.085-.071a.75.75 0 0 1 .862-1.207zM16 0a2 2 0 0 1 2 2v9.354l-.663-.492-.837-.001V2a.5.5 0 0 0-.5-.5H2a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h3.118L7.156 19H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h14zM5.009 15l.003 1H3v-1h2.009zm2.188-2-1.471 1H5v-1h2.197zM10 11v.095L8.668 12H7v-1h3zm4-2v1H7V9h7zm0-2v1H7V7h7zm-4-2v1H5V5h5zM6 3v1H3V3h3z"/></svg>'; var IM = n(9085); var MM = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; MM.insert = "head"; MM.singleton = true; var BM = Sl()(IM.Z, MM); const LM = IM.Z.locals || {}; class NM extends wl { static get pluginName() { return "CodeBlockUI" } init() { const t = this.editor; const e = t.t; const n = t.ui.componentFactory; const i = oM(t); n.add("codeBlock", (n => { const o = t.commands.get("codeBlock"); const r = Dv(n, YC); const s = r.buttonView; s.set({ label: e("Insert code block"), tooltip: true, icon: TM, isToggleable: true }); s.bind("isOn").to(o, "value", (t => !!t)); s.on("execute", (() => { t.execute("codeBlock", { usePreviousLanguageChoice: true }); t.editing.view.focus() })); r.on("execute", (e => { t.execute("codeBlock", { language: e.source._codeBlockLanguage, forceValue: true }); t.editing.view.focus() })); r.class = "ck-code-block-dropdown"; r.bind("isEnabled").to(o); Iv(r, (() => this._getLanguageListItemDefinitions(i))); return r })) } _getLanguageListItemDefinitions(t) { const e = this.editor; const n = e.commands.get("codeBlock"); const i = new il; for (const e of t) { const t = { type: "button", model: new Fy({ _codeBlockLanguage: e.language, label: e.label, withText: true }) }; t.model.bind("isOn").to(n, "value", (e => e === t.model._codeBlockLanguage)); i.add(t) } return i } } class zM extends wl { static get requires() { return [vM, NM] } static get pluginName() { return "CodeBlock" } } function PM(t, e, n, i) { if (e) { RM(t, e, i) } if (n) { OM(t, n, i) } } function OM(t, e, n) { if (e.attributes) { for (const [i, o] of Object.entries(e.attributes)) { t.setAttribute(i, o, n) } } if (e.styles) { t.setStyle(e.styles, n) } if (e.classes) { t.addClass(e.classes, n) } } function RM(t, e, n) { if (e.attributes) { for (const [i] of Object.entries(e.attributes)) { t.removeAttribute(i, n) } } if (e.styles) { for (const i of Object.keys(e.styles)) { t.removeStyle(i, n) } } if (e.classes) { t.removeClass(e.classes, n) } } function VM(t, e) { const n = Xf(t); let i = "attributes"; for (i in e) { if (i == "classes") { n[i] = Array.from(new Set([...t[i] || [], ...e[i]])) } else { n[i] = { ...t[i], ...e[i] } } } return n } function jM({ model: t }) { return (e, n) => n.writer.createElement(t, { htmlContent: e.getCustomProperty("$rawContent") }) } function FM(t, { view: e, isInline: n }) { const i = t.t; return (t, { writer: o }) => { const r = i("HTML object"); const s = HM(e, t, o); const a = t.getAttribute("htmlAttributes"); o.addClass("html-object-embed__content", s); if (a) { OM(o, a, s) } const c = o.createContainerElement(n ? "span" : "div", { class: "html-object-embed", "data-html-object-embed-label": r }, s); return kD(c, o, { label: r }) } } function HM(t, e, n) { return n.createRawElement(t, null, ((t, n) => { n.setContentOf(t, e.getAttribute("htmlContent")) })) } function UM({ view: t, model: e }, n) { return i => { i.on(`element:${t}`, ((t, i, o) => { let r = n.processViewAttributes(i.viewItem, o); if (!r && !o.consumable.test(i.viewItem, { name: true })) { return } r = r || {}; o.consumable.consume(i.viewItem, { name: true }); if (!i.modelRange) { i = Object.assign(i, o.convertChildren(i.viewItem, i.modelCursor)) } for (const t of i.modelRange.getItems()) { if (o.schema.checkAttribute(t, e)) { const n = t.getAttribute(e); const i = VM(r, n || {}); o.writer.setAttribute(e, i, t) } } }), { priority: "low" }) } } function WM({ priority: t, view: e }) { return (n, i) => { if (!n) { return } const { writer: o } = i; const r = o.createAttributeElement(e, null, { priority: t }); OM(o, n, r); return r } } function qM({ view: t }, e) { return n => { n.on(`element:${t}`, ((t, n, i) => { if (!n.modelRange || n.modelRange.isCollapsed) { return } const o = e.processViewAttributes(n.viewItem, i); if (o) { i.writer.setAttribute("htmlAttributes", o, n.modelRange) } }), { priority: "low" }) } } function GM({ model: t }) { return e => { e.on(`attribute:htmlAttributes:${t}`, ((t, e, n) => { if (!n.consumable.consume(e.item, t.name)) { return } const { attributeOldValue: i, attributeNewValue: o } = e; const r = n.writer; const s = n.mapper.toViewElement(e.item); PM(r, i, o, s) })) } } const $M = { block: [{ model: "codeBlock", view: "pre" }, { model: "paragraph", view: "p" }, { model: "blockQuote", view: "blockquote" }, { model: "listItem", view: "li" }, { model: "pageBreak", view: "div" }, { model: "rawHtml", view: "div" }, { model: "table", view: "table" }, { model: "tableRow", view: "tr" }, { model: "tableCell", view: "td" }, { model: "tableCell", view: "th" }, { model: "tableColumnGroup", view: "colgroup" }, { model: "tableColumn", view: "col" }, { model: "caption", view: "caption" }, { model: "caption", view: "figcaption" }, { model: "imageBlock", view: "img" }, { model: "imageInline", view: "img" }, { model: "htmlP", view: "p", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlBlockquote", view: "blockquote", modelSchema: { inheritAllFrom: "$container" } }, { model: "htmlTable", view: "table", modelSchema: { allowWhere: "$block", isBlock: true } }, { model: "htmlTbody", view: "tbody", modelSchema: { allowIn: "htmlTable", isBlock: false } }, { model: "htmlThead", view: "thead", modelSchema: { allowIn: "htmlTable", isBlock: false } }, { model: "htmlTfoot", view: "tfoot", modelSchema: { allowIn: "htmlTable", isBlock: false } }, { model: "htmlCaption", view: "caption", modelSchema: { allowIn: "htmlTable", allowChildren: "$text", isBlock: false } }, { model: "htmlColgroup", view: "colgroup", modelSchema: { allowIn: "htmlTable", allowChildren: "col", isBlock: false } }, { model: "htmlCol", view: "col", modelSchema: { allowIn: "htmlColgroup", isBlock: false } }, { model: "htmlTr", view: "tr", modelSchema: { allowIn: ["htmlTable", "htmlThead", "htmlTbody"], isLimit: true } }, { model: "htmlTd", view: "td", modelSchema: { allowIn: "htmlTr", allowContentOf: "$container", isLimit: true, isBlock: false } }, { model: "htmlTh", view: "th", modelSchema: { allowIn: "htmlTr", allowContentOf: "$container", isLimit: true, isBlock: false } }, { model: "htmlFigure", view: "figure", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlFigcaption", view: "figcaption", modelSchema: { allowIn: "htmlFigure", allowChildren: "$text", isBlock: false } }, { model: "htmlAddress", view: "address", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlAside", view: "aside", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlMain", view: "main", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlDetails", view: "details", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlSummary", view: "summary", modelSchema: { allowChildren: "$text", allowIn: "htmlDetails", isBlock: false } }, { model: "htmlDiv", view: "div", paragraphLikeModel: "htmlDivParagraph", modelSchema: { inheritAllFrom: "$container" } }, { model: "htmlFieldset", view: "fieldset", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlLegend", view: "legend", modelSchema: { allowIn: "htmlFieldset", allowChildren: "$text" } }, { model: "htmlHeader", view: "header", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlFooter", view: "footer", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlForm", view: "form", modelSchema: { inheritAllFrom: "$container", isBlock: true } }, { model: "htmlHgroup", view: "hgroup", modelSchema: { allowChildren: ["htmlH1", "htmlH2", "htmlH3", "htmlH4", "htmlH5", "htmlH6"], isBlock: false } }, { model: "htmlH1", view: "h1", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH2", view: "h2", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH3", view: "h3", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH4", view: "h4", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH5", view: "h5", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH6", view: "h6", modelSchema: { inheritAllFrom: "$block" } }, { model: "$htmlList", modelSchema: { allowWhere: "$container", allowChildren: ["$htmlList", "htmlLi"], isBlock: false } }, { model: "htmlDir", view: "dir", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlMenu", view: "menu", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlUl", view: "ul", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlOl", view: "ol", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlLi", view: "li", modelSchema: { allowIn: "$htmlList", allowChildren: "$text", isBlock: false } }, { model: "htmlPre", view: "pre", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlArticle", view: "article", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlSection", view: "section", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlNav", view: "nav", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlDivDl", view: "div", modelSchema: { allowChildren: ["htmlDt", "htmlDd"], allowIn: "htmlDl" } }, { model: "htmlDl", view: "dl", modelSchema: { allowWhere: "$container", allowChildren: ["htmlDt", "htmlDd", "htmlDivDl"], isBlock: false } }, { model: "htmlDt", view: "dt", modelSchema: { allowChildren: "$block", isBlock: false } }, { model: "htmlDd", view: "dd", modelSchema: { allowChildren: "$block", isBlock: false } }, { model: "htmlCenter", view: "center", modelSchema: { inheritAllFrom: "$container", isBlock: false } }], inline: [{ model: "htmlAcronym", view: "acronym", attributeProperties: { copyOnEnter: true } }, { model: "htmlTt", view: "tt", attributeProperties: { copyOnEnter: true } }, { model: "htmlFont", view: "font", attributeProperties: { copyOnEnter: true } }, { model: "htmlTime", view: "time", attributeProperties: { copyOnEnter: true } }, { model: "htmlVar", view: "var", attributeProperties: { copyOnEnter: true } }, { model: "htmlBig", view: "big", attributeProperties: { copyOnEnter: true } }, { model: "htmlSmall", view: "small", attributeProperties: { copyOnEnter: true } }, { model: "htmlSamp", view: "samp", attributeProperties: { copyOnEnter: true } }, { model: "htmlQ", view: "q", attributeProperties: { copyOnEnter: true } }, { model: "htmlOutput", view: "output", attributeProperties: { copyOnEnter: true } }, { model: "htmlKbd", view: "kbd", attributeProperties: { copyOnEnter: true } }, { model: "htmlBdi", view: "bdi", attributeProperties: { copyOnEnter: true } }, { model: "htmlBdo", view: "bdo", attributeProperties: { copyOnEnter: true } }, { model: "htmlAbbr", view: "abbr", attributeProperties: { copyOnEnter: true } }, { model: "htmlA", view: "a", priority: 5, coupledAttribute: "linkHref", attributeProperties: { copyOnEnter: true } }, { model: "htmlStrong", view: "strong", coupledAttribute: "bold", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlB", view: "b", coupledAttribute: "bold", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlI", view: "i", coupledAttribute: "italic", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlEm", view: "em", coupledAttribute: "italic", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlS", view: "s", coupledAttribute: "strikethrough", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlDel", view: "del", coupledAttribute: "strikethrough", attributeProperties: { copyOnEnter: true } }, { model: "htmlIns", view: "ins", attributeProperties: { copyOnEnter: true } }, { model: "htmlU", view: "u", coupledAttribute: "underline", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlSub", view: "sub", coupledAttribute: "subscript", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlSup", view: "sup", coupledAttribute: "superscript", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlCode", view: "code", coupledAttribute: "code", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlMark", view: "mark", attributeProperties: { copyOnEnter: true } }, { model: "htmlSpan", view: "span", attributeProperties: { copyOnEnter: true } }, { model: "htmlCite", view: "cite", attributeProperties: { copyOnEnter: true } }, { model: "htmlLabel", view: "label", attributeProperties: { copyOnEnter: true } }, { model: "htmlDfn", view: "dfn", attributeProperties: { copyOnEnter: true } }, { model: "htmlObject", view: "object", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlIframe", view: "iframe", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlInput", view: "input", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlButton", view: "button", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlTextarea", view: "textarea", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlSelect", view: "select", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlVideo", view: "video", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlEmbed", view: "embed", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlOembed", view: "oembed", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlAudio", view: "audio", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlImg", view: "img", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlCanvas", view: "canvas", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlMeter", view: "meter", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlProgress", view: "progress", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlScript", view: "script", modelSchema: { allowWhere: ["$text", "$block"], isInline: true } }, { model: "htmlStyle", view: "style", modelSchema: { allowWhere: ["$text", "$block"], isInline: true } }, { model: "htmlCustomElement", view: "$customElement", modelSchema: { allowWhere: ["$text", "$block"], isInline: true } }] }; var KM = zu((function (t, e, n, i) { uu(t, e, n, i) })); const YM = KM; class QM extends wl { constructor(t) { super(t); this._definitions = new Map } static get pluginName() { return "DataSchema" } init() { for (const t of $M.block) { this.registerBlockElement(t) } for (const t of $M.inline) { this.registerInlineElement(t) } } registerBlockElement(t) { this._definitions.set(t.model, { ...t, isBlock: true }) } registerInlineElement(t) { this._definitions.set(t.model, { ...t, isInline: true }) } extendBlockElement(t) { this._extendDefinition({ ...t, isBlock: true }) } extendInlineElement(t) { this._extendDefinition({ ...t, isInline: true }) } getDefinitionsForView(t, e = false) { const n = new Set; for (const i of this._getMatchingViewDefinitions(t)) { if (e) { for (const t of this._getReferences(i.model)) { n.add(t) } } n.add(i) } return n } _getMatchingViewDefinitions(t) { return Array.from(this._definitions.values()).filter((e => e.view && ZM(t, e.view))) } *_getReferences(t) { const { modelSchema: e } = this._definitions.get(t); if (!e) { return } const n = ["inheritAllFrom", "inheritTypesFrom", "allowWhere", "allowContentOf", "allowAttributesOf"]; for (const i of n) { for (const n of $c(e[i] || [])) { const e = this._definitions.get(n); if (n !== t && e) { yield* this._getReferences(e.model); yield e } } } } _extendDefinition(t) { const e = this._definitions.get(t.model); const n = YM({}, e, t, ((t, e) => Array.isArray(t) ? t.concat(e) : undefined)); this._definitions.set(t.model, n) } } function ZM(t, e) { if (typeof t === "string") { return t === e } if (t instanceof RegExp) { return t.test(e) } return false } function JM(t, e, n, i) { var o = t.length, r = n + (i ? 1 : -1); while (i ? r-- : ++r < o) { if (e(t[r], r, t)) { return r } } return -1 } const XM = JM; function tB(t) { return t !== t } const eB = tB; function nB(t, e, n) { var i = n - 1, o = t.length; while (++i < o) { if (t[i] === e) { return i } } return -1 } const iB = nB; function oB(t, e, n) { return e === e ? iB(t, e, n) : XM(t, eB, n) } const rB = oB; function sB(t, e, n, i) { var o = n - 1, r = t.length; while (++o < r) { if (i(t[o], e)) { return o } } return -1 } const aB = sB; var cB = Array.prototype; var lB = cB.splice; function dB(t, e, n, i) { var o = i ? aB : rB, r = -1, s = e.length, a = t; if (t === e) { e = ar(e) } if (n) { a = vd(t, mo(n)) } while (++r < s) { var c = 0, l = e[r], d = n ? n(l) : l; while ((c = o(a, d, c, i)) > -1) { if (a !== t) { lB.call(a, c, 1) } lB.call(t, c, 1) } } return t } const uB = dB; function hB(t, e) { return t && t.length && e && e.length ? uB(t, e) : t } const gB = hB; var mB = Mu(gB); const fB = mB; var pB = n(8468); var bB = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; bB.insert = "head"; bB.singleton = true; var kB = Sl()(pB.Z, bB); const wB = pB.Z.locals || {}; class AB extends wl { constructor(t) { super(t); this._dataSchema = t.plugins.get("DataSchema"); this._allowedAttributes = new Yl; this._disallowedAttributes = new Yl; this._allowedElements = new Set; this._disallowedElements = new Set; this._dataInitialized = false; this._coupledAttributes = null; this._registerElementsAfterInit(); this._registerElementHandlers(); this._registerModelPostFixer() } static get pluginName() { return "DataFilter" } static get requires() { return [QM, oS] } loadAllowedConfig(t) { for (const e of t) { const t = e.name || /[\s\S]+/; const n = DB(e); this.allowElement(t); n.forEach((t => this.allowAttributes(t))) } } loadDisallowedConfig(t) { for (const e of t) { const t = e.name || /[\s\S]+/; const n = DB(e); if (n.length == 0) { this.disallowElement(t) } else { n.forEach((t => this.disallowAttributes(t))) } } } allowElement(t) { for (const e of this._dataSchema.getDefinitionsForView(t, true)) { if (this._allowedElements.has(e)) { continue } this._allowedElements.add(e); if (this._dataInitialized) { this.editor.data.once("set", (() => { this._fireRegisterEvent(e) }), { priority: D.get("highest") + 1 }) } this._coupledAttributes = null } } disallowElement(t) { for (const e of this._dataSchema.getDefinitionsForView(t, false)) { this._disallowedElements.add(e.view) } } allowAttributes(t) { this._allowedAttributes.add(t) } disallowAttributes(t) { this._disallowedAttributes.add(t) } processViewAttributes(t, e) { _B(t, e, this._disallowedAttributes); return _B(t, e, this._allowedAttributes) } _registerElementsAfterInit() { this.editor.data.on("init", (() => { this._dataInitialized = true; for (const t of this._allowedElements) { this._fireRegisterEvent(t) } }), { priority: D.get("highest") + 1 }) } _registerElementHandlers() { this.on("register", ((t, e) => { const n = this.editor.model.schema; if (e.isObject && !n.isRegistered(e.model)) { this._registerObjectElement(e) } else if (e.isBlock) { this._registerBlockElement(e) } else if (e.isInline) { this._registerInlineElement(e) } else { throw new I("data-filter-invalid-definition", null, e) } t.stop() }), { priority: "lowest" }) } _registerModelPostFixer() { const t = this.editor.model; t.document.registerPostFixer((e => { const n = t.document.differ.getChanges(); let i = false; const o = this._getCoupledAttributesMap(); for (const t of n) { if (t.type != "attribute" || t.attributeNewValue !== null) { continue } const n = o.get(t.attributeKey); if (!n) { continue } for (const { item: o } of t.range.getWalker({ shallow: true })) { for (const t of n) { if (o.hasAttribute(t)) { e.removeAttribute(t, o); i = true } } } } return i })) } _getCoupledAttributesMap() { if (this._coupledAttributes) { return this._coupledAttributes } this._coupledAttributes = new Map; for (const t of this._allowedElements) { if (t.coupledAttribute && t.model) { const e = this._coupledAttributes.get(t.coupledAttribute); if (e) { e.push(t.model) } else { this._coupledAttributes.set(t.coupledAttribute, [t.model]) } } } return this._coupledAttributes } _fireRegisterEvent(t) { if (t.view && this._disallowedElements.has(t.view)) { return } this.fire(t.view ? `register:${t.view}` : "register", t) } _registerObjectElement(t) { const e = this.editor; const n = e.model.schema; const i = e.conversion; const { view: o, model: r } = t; n.register(r, t.modelSchema); if (!o) { return } n.extend(t.model, { allowAttributes: ["htmlAttributes", "htmlContent"] }); e.data.registerRawContentMatcher({ name: o }); i.for("upcast").elementToElement({ view: o, model: jM(t), converterPriority: D.get("low") + 1 }); i.for("upcast").add(qM(t, this)); i.for("editingDowncast").elementToStructure({ model: { name: r, attributes: ["htmlAttributes"] }, view: FM(e, t) }); i.for("dataDowncast").elementToElement({ model: r, view: (t, { writer: e }) => HM(o, t, e) }); i.for("dataDowncast").add(GM(t)) } _registerBlockElement(t) { const e = this.editor; const n = e.model.schema; const i = e.conversion; const { view: o, model: r } = t; if (!n.isRegistered(t.model)) { n.register(t.model, t.modelSchema); if (!o) { return } i.for("upcast").elementToElement({ model: r, view: o, converterPriority: D.get("low") + 1 }); i.for("downcast").elementToElement({ model: r, view: o }) } if (!o) { return } n.extend(t.model, { allowAttributes: "htmlAttributes" }); i.for("upcast").add(qM(t, this)); i.for("downcast").add(GM(t)) } _registerInlineElement(t) { const e = this.editor; const n = e.model.schema; const i = e.conversion; const o = t.model; n.extend("$text", { allowAttributes: o }); if (t.attributeProperties) { n.setAttributeProperties(o, t.attributeProperties) } i.for("upcast").add(UM(t, this)); i.for("downcast").attributeToElement({ model: o, view: WM(t) }) } } function _B(t, e, n) { const i = CB(t, e, n); const { attributes: o, styles: r, classes: s } = yB(i); const a = {}; if (o.size) { for (const t of o) { if (!SB(t)) { o.delete(t) } } } if (o.size) { a.attributes = xB(o, (e => t.getAttribute(e))) } if (r.size) { a.styles = xB(r, (e => t.getStyle(e))) } if (s.size) { a.classes = Array.from(s) } if (!Object.keys(a).length) { return null } return a } function CB(t, { consumable: e }, n) { const i = n.matchAll(t) || []; const o = []; for (const n of i) { vB(e, t, n); delete n.match.name; e.consume(t, n.match); o.push(n) } return o } function vB(t, e, n) { for (const i of ["attributes", "classes", "styles"]) { const o = n.match[i]; if (!o) { continue } for (const n of Array.from(o)) { if (!t.test(e, { [i]: [n] })) { fB(o, n) } } } } function yB(t) { const e = { attributes: new Set, classes: new Set, styles: new Set }; for (const n of t) { for (const t in e) { const i = n.match[t] || []; i.forEach((n => e[t].add(n))) } } return e } function xB(t, e) { const n = {}; for (const i of t) { const t = e(i); if (t !== undefined) { n[i] = e(i) } } return n } function EB(t, e) { const { name: n } = t; const i = t[e]; if (de(i)) { return Object.entries(i).map((([t, i]) => ({ name: n, [e]: { [t]: i } }))) } if (Array.isArray(i)) { return i.map((t => ({ name: n, [e]: [t] }))) } return [t] } function DB(t) { const { name: e, attributes: n, classes: i, styles: o } = t; const r = []; if (n) { r.push(...EB({ name: e, attributes: n }, "attributes")) } if (i) { r.push(...EB({ name: e, classes: i }, "classes")) } if (o) { r.push(...EB({ name: e, styles: o }, "styles")) } return r } function SB(t) { try { document.createAttribute(t) } catch (t) { return false } return true } class TB extends _l { constructor(t) { super(t); this.affectsData = false } execute() { const t = this.editor.model; const e = t.document.selection; let n = t.schema.getLimitElement(e); if (e.containsEntireContent(n) || !IB(t.schema, n)) { do { n = n.parent; if (!n) { return } } while (!IB(t.schema, n)) } t.change((t => { t.setSelection(n, "in") })) } } function IB(t, e) { return t.isLimit(e) && (t.checkChild(e, "$text") || t.checkChild(e, "paragraph")) } const MB = Vc("Ctrl+A"); class BB extends wl { static get pluginName() { return "SelectAllEditing" } init() { const t = this.editor; const e = t.editing.view; const n = e.document; t.commands.add("selectAll", new TB(t)); this.listenTo(n, "keydown", ((e, n) => { if (Rc(n) === MB) { t.execute("selectAll"); n.preventDefault() } })) } } const LB = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>'; class NB extends wl { static get pluginName() { return "SelectAllUI" } init() { const t = this.editor; t.ui.componentFactory.add("selectAll", (e => { const n = t.commands.get("selectAll"); const i = new wC(e); const o = e.t; i.set({ label: o("Select all"), icon: LB, keystroke: "Ctrl+A", tooltip: true }); i.bind("isEnabled").to(n, "isEnabled"); this.listenTo(i, "execute", (() => { t.execute("selectAll"); t.editing.view.focus() })); return i })) } } class zB extends wl { static get requires() { return [BB, NB] } static get pluginName() { return "SelectAll" } } class PB extends wl { static get requires() { return [US, iD, zB, lD, EE, XS] } static get pluginName() { return "Essentials" } } class OB extends _l { refresh() { const t = this.editor.model; const e = t.document; const n = ol(e.selection.getSelectedBlocks()); this.value = !!n && n.is("element", "paragraph"); this.isEnabled = !!n && RB(n, t.schema) } execute(t = {}) { const e = this.editor.model; const n = e.document; e.change((i => { const o = (t.selection || n.selection).getSelectedBlocks(); for (const t of o) { if (!t.is("element", "paragraph") && RB(t, e.schema)) { i.rename(t, "paragraph") } } })) } } function RB(t, e) { return e.checkChild(t.parent, "paragraph") && !e.isObject(t) } class VB extends _l { execute(t) { const e = this.editor.model; const n = t.attributes; let i = t.position; e.change((t => { const o = t.createElement("paragraph"); if (n) { e.schema.setAllowedAttributes(o, n, t) } if (!e.schema.checkChild(i.parent, o)) { const n = e.schema.findAllowedParent(i, o); if (!n) { return } i = t.split(i, n).position } e.insertContent(o, i); t.setSelection(o, "in") })) } } class jB extends wl { static get pluginName() { return "Paragraph" } init() { const t = this.editor; const e = t.model; t.commands.add("paragraph", new OB(t)); t.commands.add("insertParagraph", new VB(t)); e.schema.register("paragraph", { inheritAllFrom: "$block" }); t.conversion.elementToElement({ model: "paragraph", view: "p" }); t.conversion.for("upcast").elementToElement({ model: (t, { writer: e }) => { if (!jB.paragraphLikeElements.has(t.name)) { return null } if (t.isEmpty) { return null } return e.createElement("paragraph") }, view: /.+/, converterPriority: "low" }) } } jB.paragraphLikeElements = new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"]); const FB = v_.paragraph; class HB extends (null && Plugin) { static get requires() { return [Paragraph] } init() { const t = this.editor; const e = t.t; t.ui.componentFactory.add("paragraph", (n => { const i = new ButtonView(n); const o = t.commands.get("paragraph"); i.label = e("Paragraph"); i.icon = FB; i.tooltip = true; i.isToggleable = true; i.bind("isEnabled").to(o); i.bind("isOn").to(o, "value"); i.on("execute", (() => { t.execute("paragraph") })); return i })) } } class UB extends _l { constructor(t, e) { super(t); this.modelElements = e } refresh() { const t = ol(this.editor.model.document.selection.getSelectedBlocks()); this.value = !!t && this.modelElements.includes(t.name) && t.name; this.isEnabled = !!t && this.modelElements.some((e => WB(t, e, this.editor.model.schema))) } execute(t) { const e = this.editor.model; const n = e.document; const i = t.value; e.change((t => { const o = Array.from(n.selection.getSelectedBlocks()).filter((t => WB(t, i, e.schema))); for (const e of o) { if (!e.is("element", i)) { t.rename(e, i) } } })) } } function WB(t, e, n) { return n.checkChild(t.parent, e) && !n.isObject(t) } const qB = "paragraph"; class GB extends wl { static get pluginName() { return "HeadingEditing" } constructor(t) { super(t); t.config.define("heading", { options: [{ model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" }, { model: "heading1", view: "h2", title: "Heading 1", class: "ck-heading_heading1" }, { model: "heading2", view: "h3", title: "Heading 2", class: "ck-heading_heading2" }, { model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3" }] }) } static get requires() { return [jB] } init() { const t = this.editor; const e = t.config.get("heading.options"); const n = []; for (const i of e) { if (i.model === "paragraph") { continue } t.model.schema.register(i.model, { inheritAllFrom: "$block" }); t.conversion.elementToElement(i); n.push(i.model) } this._addDefaultH1Conversion(t); t.commands.add("heading", new UB(t, n)) } afterInit() { const t = this.editor; const e = t.commands.get("enter"); const n = t.config.get("heading.options"); if (e) { this.listenTo(e, "afterExecute", ((e, i) => { const o = t.model.document.selection.getFirstPosition().parent; const r = n.some((t => o.is("element", t.model))); if (r && !o.is("element", qB) && o.childCount === 0) { i.writer.rename(o, qB) } })) } } _addDefaultH1Conversion(t) { t.conversion.for("upcast").elementToElement({ model: "heading1", view: "h1", converterPriority: D.get("low") + 1 }) } } function $B(t) { const e = t.t; const n = { Paragraph: e("Paragraph"), "Heading 1": e("Heading 1"), "Heading 2": e("Heading 2"), "Heading 3": e("Heading 3"), "Heading 4": e("Heading 4"), "Heading 5": e("Heading 5"), "Heading 6": e("Heading 6") }; return t.config.get("heading.options").map((t => { const e = n[t.title]; if (e && e != t.title) { t.title = e } return t })) } var KB = n(3230); var YB = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; YB.insert = "head"; YB.singleton = true; var QB = Sl()(KB.Z, YB); const ZB = KB.Z.locals || {}; class JB extends wl { static get pluginName() { return "HeadingUI" } init() { const t = this.editor; const e = t.t; const n = $B(t); const i = e("Choose heading"); const o = e("Heading"); t.ui.componentFactory.add("heading", (e => { const r = {}; const s = new il; const a = t.commands.get("heading"); const c = t.commands.get("paragraph"); const l = [a]; for (const t of n) { const e = { type: "button", model: new Fy({ label: t.title, class: t.class, withText: true }) }; if (t.model === "paragraph") { e.model.bind("isOn").to(c, "value"); e.model.set("commandName", "paragraph"); l.push(c) } else { e.model.bind("isOn").to(a, "value", (e => e === t.model)); e.model.set({ commandName: "heading", commandValue: t.model }) } s.add(e); r[t.model] = t.title } const d = Dv(e); Iv(d, s); d.buttonView.set({ isOn: false, withText: true, tooltip: o }); d.extendTemplate({ attributes: { class: ["ck-heading-dropdown"] } }); d.bind("isEnabled").toMany(l, "isEnabled", ((...t) => t.some((t => t)))); d.buttonView.bind("label").to(a, "value", c, "value", ((t, e) => { const n = t || e && "paragraph"; if (typeof n === "boolean") { return i } if (!r[n]) { return i } return r[n] })); this.listenTo(d, "execute", (e => { const { commandName: n, commandValue: i } = e.source; t.execute(n, i ? { value: i } : undefined); t.editing.view.focus() })); return d })) } } class XB extends wl { static get requires() { return [GB, JB] } static get pluginName() { return "Heading" } } class tL extends _l { refresh() { const t = this.editor.model; const e = t.document; this.value = e.selection.getAttribute("highlight"); this.isEnabled = t.schema.checkAttributeInSelection(e.selection, "highlight") } execute(t = {}) { const e = this.editor.model; const n = e.document; const i = n.selection; const o = t.value; e.change((t => { if (i.isCollapsed) { const e = i.getFirstPosition(); if (i.hasAttribute("highlight")) { const n = t => t.item.hasAttribute("highlight") && t.item.getAttribute("highlight") === this.value; const i = e.getLastMatchingPosition(n, { direction: "backward" }); const r = e.getLastMatchingPosition(n); const s = t.createRange(i, r); if (!o || this.value === o) { if (!e.isEqual(r)) { t.removeAttribute("highlight", s) } t.removeSelectionAttribute("highlight") } else { if (!e.isEqual(r)) { t.setAttribute("highlight", o, s) } t.setSelectionAttribute("highlight", o) } } else if (o) { t.setSelectionAttribute("highlight", o) } } else { const n = e.schema.getValidRanges(i.getRanges(), "highlight"); for (const e of n) { if (o) { t.setAttribute("highlight", o, e) } else { t.removeAttribute("highlight", e) } } } })) } } class eL extends wl { static get pluginName() { return "HighlightEditing" } constructor(t) { super(t); t.config.define("highlight", { options: [{ model: "yellowMarker", class: "marker-yellow", title: "Yellow marker", color: "var(--ck-highlight-marker-yellow)", type: "marker" }, { model: "greenMarker", class: "marker-green", title: "Green marker", color: "var(--ck-highlight-marker-green)", type: "marker" }, { model: "pinkMarker", class: "marker-pink", title: "Pink marker", color: "var(--ck-highlight-marker-pink)", type: "marker" }, { model: "blueMarker", class: "marker-blue", title: "Blue marker", color: "var(--ck-highlight-marker-blue)", type: "marker" }, { model: "redPen", class: "pen-red", title: "Red pen", color: "var(--ck-highlight-pen-red)", type: "pen" }, { model: "greenPen", class: "pen-green", title: "Green pen", color: "var(--ck-highlight-pen-green)", type: "pen" }] }) } init() { const t = this.editor; t.model.schema.extend("$text", { allowAttributes: "highlight" }); const e = t.config.get("highlight.options"); t.conversion.attributeToElement(nL(e)); t.commands.add("highlight", new tL(t)) } } function nL(t) { const e = { model: { key: "highlight", values: [] }, view: {} }; for (const n of t) { e.model.values.push(n.model); e.view[n.model] = { name: "mark", classes: n.class } } return e } const iL = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.798 1.59 3.002 12.875l1.895 1.852 2.521 1.402 6.997-12.194z"/><path d="m2.556 16.727.234-.348c-.297-.151-.462-.293-.498-.426-.036-.137.002-.416.115-.837.094-.25.15-.449.169-.595a4.495 4.495 0 0 0 0-.725c-.209-.621-.303-1.041-.284-1.26.02-.218.178-.506.475-.862l6.77-9.414c.539-.91 1.605-.85 3.199.18 1.594 1.032 2.188 1.928 1.784 2.686l-5.877 10.36c-.158.412-.333.673-.526.782-.193.108-.604.179-1.232.21-.362.131-.608.237-.738.318-.13.081-.305.238-.526.47-.293.265-.504.397-.632.397-.096 0-.27-.075-.524-.226l-.31.41-1.6-1.12zm-.279.415 1.575 1.103-.392.515H1.19l1.087-1.618zm8.1-13.656-4.953 6.9L8.75 12.57l4.247-7.574c.175-.25-.188-.647-1.092-1.192-.903-.546-1.412-.652-1.528-.32zM8.244 18.5 9.59 17h9.406v1.5H8.245z"/></svg>'; const oL = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.126 2.268 2.002 13.874l1.895 1.852 2.521 1.402L14.47 5.481l-1.543-2.568-2.801-.645z"/><path d="m4.5 18.088-2.645-1.852-.04-2.95-.006-.005.006-.008v-.025l.011.008L8.73 2.97c.165-.233.356-.417.567-.557l-1.212.308L4.604 7.9l-.83-.558 3.694-5.495 2.708-.69 1.65 1.145.046.018.85-1.216 2.16 1.512-.856 1.222c.828.967 1.144 2.141.432 3.158L7.55 17.286l.006.005-3.055.797H4.5zm-.634.166-1.976.516-.026-1.918 2.002 1.402zM9.968 3.817l-.006-.004-6.123 9.184 3.277 2.294 6.108-9.162.005.003c.317-.452-.16-1.332-1.064-1.966-.891-.624-1.865-.776-2.197-.349zM8.245 18.5 9.59 17h9.406v1.5H8.245z"/></svg>'; var rL = n(713); var sL = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; sL.insert = "head"; sL.singleton = true; var aL = Sl()(rL.Z, sL); const cL = rL.Z.locals || {}; class lL extends wl { get localizedOptionTitles() { const t = this.editor.t; return { "Yellow marker": t("Yellow marker"), "Green marker": t("Green marker"), "Pink marker": t("Pink marker"), "Blue marker": t("Blue marker"), "Red pen": t("Red pen"), "Green pen": t("Green pen") } } static get pluginName() { return "HighlightUI" } init() { const t = this.editor.config.get("highlight.options"); for (const e of t) { this._addHighlighterButton(e) } this._addRemoveHighlightButton(); this._addDropdown(t) } _addRemoveHighlightButton() { const t = this.editor.t; const e = this.editor.commands.get("highlight"); this._addButton("removeHighlight", t("Remove highlight"), v_.eraser, null, (t => { t.bind("isEnabled").to(e, "isEnabled") })) } _addHighlighterButton(t) { const e = this.editor.commands.get("highlight"); this._addButton("highlight:" + t.model, t.title, uL(t.type), t.model, n); function n(n) { n.bind("isEnabled").to(e, "isEnabled"); n.bind("isOn").to(e, "value", (e => e === t.model)); n.iconView.fillColor = t.color; n.isToggleable = true } } _addButton(t, e, n, i, o) { const r = this.editor; r.ui.componentFactory.add(t, (t => { const s = new wC(t); const a = this.localizedOptionTitles[e] ? this.localizedOptionTitles[e] : e; s.set({ label: a, icon: n, tooltip: true }); s.on("execute", (() => { r.execute("highlight", { value: i }); r.editing.view.focus() })); o(s); return s })) } _addDropdown(t) { const e = this.editor; const n = e.t; const i = e.ui.componentFactory; const o = t[0]; const r = t.reduce(((t, e) => { t[e.model] = e; return t }), {}); i.add("highlight", (s => { const a = e.commands.get("highlight"); const c = Dv(s, YC); const l = c.buttonView; l.set({ label: n("Highlight"), tooltip: true, lastExecuted: o.model, commandValue: o.model, isToggleable: true }); l.bind("icon").to(a, "value", (t => uL(u(t, "type")))); l.bind("color").to(a, "value", (t => u(t, "color"))); l.bind("commandValue").to(a, "value", (t => u(t, "model"))); l.bind("isOn").to(a, "value", (t => !!t)); l.delegate("execute").to(c); const d = () => { const e = t.map((t => { const e = i.create("highlight:" + t.model); this.listenTo(e, "execute", (() => { c.buttonView.set({ lastExecuted: t.model }) })); return e })); e.push(new JC); e.push(i.create("removeHighlight")); return e }; c.bind("isEnabled").to(a, "isEnabled"); Sv(c, d, { enableActiveItemFocusOnDropdownOpen: true, ariaLabel: n("Text highlight toolbar") }); dL(c); l.on("execute", (() => { e.execute("highlight", { value: l.commandValue }) })); this.listenTo(c, "execute", (() => { e.editing.view.focus() })); function u(t, e) { const n = !t || t === l.lastExecuted ? l.lastExecuted : t; return r[n][e] } return c })) } } function dL(t) { const e = t.buttonView.actionView; e.iconView.bind("fillColor").to(t.buttonView, "color") } function uL(t) { return t === "marker" ? iL : oL } class hL extends wl { static get requires() { return [eL, lL] } static get pluginName() { return "Highlight" } } class gL extends _l { refresh() { const t = this.editor.model; const e = t.schema; const n = t.document.selection; this.isEnabled = mL(n, e, t) } execute() { const t = this.editor.model; t.change((e => { const n = e.createElement("horizontalLine"); t.insertObject(n, null, null, { setSelection: "after" }) })) } } function mL(t, e, n) { const i = fL(t, n); return e.checkChild(i, "horizontalLine") } function fL(t, e) { const n = xD(t, e); const i = n.start.parent; if (i.isEmpty && !i.is("element", "$root")) { return i.parent } return i } var pL = n(2536); var bL = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; bL.insert = "head"; bL.singleton = true; var kL = Sl()(pL.Z, bL); const wL = pL.Z.locals || {}; class AL extends wl { static get pluginName() { return "HorizontalLineEditing" } init() { const t = this.editor; const e = t.model.schema; const n = t.t; const i = t.conversion; e.register("horizontalLine", { inheritAllFrom: "$blockObject" }); i.for("dataDowncast").elementToElement({ model: "horizontalLine", view: (t, { writer: e }) => e.createEmptyElement("hr") }); i.for("editingDowncast").elementToStructure({ model: "horizontalLine", view: (t, { writer: e }) => { const i = n("Horizontal line"); const o = e.createContainerElement("div", null, e.createEmptyElement("hr")); e.addClass("ck-horizontal-line", o); e.setCustomProperty("hr", true, o); return _L(o, e, i) } }); i.for("upcast").elementToElement({ view: "hr", model: "horizontalLine" }); t.commands.add("horizontalLine", new gL(t)) } } function _L(t, e, n) { e.setCustomProperty("horizontalLine", true, t); return kD(t, e, { label: n }) } const CL = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 9h16v2H2z"/></svg>'; class vL extends wl { static get pluginName() { return "HorizontalLineUI" } init() { const t = this.editor; const e = t.t; t.ui.componentFactory.add("horizontalLine", (n => { const i = t.commands.get("horizontalLine"); const o = new wC(n); o.set({ label: e("Horizontal line"), icon: CL, tooltip: true }); o.bind("isEnabled").to(i, "isEnabled"); this.listenTo(o, "execute", (() => { t.execute("horizontalLine"); t.editing.view.focus() })); return o })) } } class yL extends wl { static get requires() { return [AL, vL, oS] } static get pluginName() { return "HorizontalLine" } } class xL extends _l { refresh() { const t = this.editor; const e = t.plugins.get("ImageUtils"); const n = e.getClosestSelectedImageElement(this.editor.model.document.selection); this.isEnabled = !!n; if (this.isEnabled && n.hasAttribute("alt")) { this.value = n.getAttribute("alt") } else { this.value = false } } execute(t) { const e = this.editor; const n = e.plugins.get("ImageUtils"); const i = e.model; const o = n.getClosestSelectedImageElement(i.document.selection); i.change((e => { e.setAttribute("alt", t.newValue, o) })) } } class EL extends wl { static get requires() { return [oT] } static get pluginName() { return "ImageTextAlternativeEditing" } init() { this.editor.commands.add("imageTextAlternative", new xL(this.editor)) } } var DL = n(6831); var SL = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; SL.insert = "head"; SL.singleton = true; var TL = Sl()(DL.Z, SL); const IL = DL.Z.locals || {}; var ML = n(1590); var BL = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; BL.insert = "head"; BL.singleton = true; var LL = Sl()(ML.Z, BL); const NL = ML.Z.locals || {}; class zL extends N_ { constructor(t) { super(t); const e = this.locale.t; this.focusTracker = new rl; this.keystrokes = new sl; this.labeledInput = this._createLabeledInputView(); this.saveButtonView = this._createButton(e("Save"), v_.check, "ck-button-save"); this.saveButtonView.type = "submit"; this.cancelButtonView = this._createButton(e("Cancel"), v_.cancel, "ck-button-cancel", "cancel"); this._focusables = new S_; this._focusCycler = new QC({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }); this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-text-alternative-form", "ck-responsive-form"], tabindex: "-1" }, children: [this.labeledInput, this.saveButtonView, this.cancelButtonView] }) } render() { super.render(); this.keystrokes.listenTo(this.element); E_({ view: this });[this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((t => { this._focusables.add(t); this.focusTracker.add(t.element) })) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } _createButton(t, e, n, i) { const o = new wC(this.locale); o.set({ label: t, icon: e, tooltip: true }); o.extendTemplate({ attributes: { class: n } }); if (i) { o.delegate("execute").to(this, i) } return o } _createLabeledInputView() { const t = this.locale.t; const e = new Py(this.locale, Oy); e.label = t("Text alternative"); return e } } function PL(t) { const e = t.plugins.get("ContextualBalloon"); const n = t.plugins.get("ImageUtils"); if (n.getClosestSelectedImageWidget(t.editing.view.document.selection)) { const n = OL(t); e.updatePosition(n) } } function OL(t) { const e = t.editing.view; const n = Gv.defaultPositions; const i = t.plugins.get("ImageUtils"); return { target: e.domConverter.mapViewToDom(i.getClosestSelectedImageWidget(e.document.selection)), positions: [n.northArrowSouth, n.northArrowSouthWest, n.northArrowSouthEast, n.southArrowNorth, n.southArrowNorthWest, n.southArrowNorthEast, n.viewportStickyNorth] } } class RL extends wl { static get requires() { return [Xy] } static get pluginName() { return "ImageTextAlternativeUI" } init() { this._createButton() } destroy() { super.destroy(); if (this._form) { this._form.destroy() } } _createButton() { const t = this.editor; const e = t.t; t.ui.componentFactory.add("imageTextAlternative", (n => { const i = t.commands.get("imageTextAlternative"); const o = new wC(n); o.set({ label: e("Change image text alternative"), icon: v_.lowVision, tooltip: true }); o.bind("isEnabled").to(i, "isEnabled"); o.bind("isOn").to(i, "value", (t => !!t)); this.listenTo(o, "execute", (() => { this._showForm() })); return o })) } _createForm() { const t = this.editor; const e = t.editing.view; const n = e.document; const i = t.plugins.get("ImageUtils"); this._balloon = this.editor.plugins.get("ContextualBalloon"); this._form = new (x_(zL))(t.locale); this._form.render(); this.listenTo(this._form, "submit", (() => { t.execute("imageTextAlternative", { newValue: this._form.labeledInput.fieldView.element.value }); this._hideForm(true) })); this.listenTo(this._form, "cancel", (() => { this._hideForm(true) })); this._form.keystrokes.set("Esc", ((t, e) => { this._hideForm(true); e() })); this.listenTo(t.ui, "update", (() => { if (!i.getClosestSelectedImageWidget(n.selection)) { this._hideForm(true) } else if (this._isVisible) { PL(t) } })); y_({ emitter: this._form, activator: () => this._isVisible, contextElements: () => [this._balloon.view.element], callback: () => this._hideForm() }) } _showForm() { if (this._isVisible) { return } if (!this._form) { this._createForm() } const t = this.editor; const e = t.commands.get("imageTextAlternative"); const n = this._form.labeledInput; this._form.disableCssTransitions(); if (!this._isInBalloon) { this._balloon.add({ view: this._form, position: OL(t) }) } n.fieldView.value = n.fieldView.element.value = e.value || ""; this._form.labeledInput.fieldView.select(); this._form.enableCssTransitions() } _hideForm(t = false) { if (!this._isInBalloon) { return } if (this._form.focusTracker.isFocused) { this._form.saveButtonView.focus() } this._balloon.remove(this._form); if (t) { this.editor.editing.view.focus() } } get _isVisible() { return !!this._balloon && this._balloon.visibleView === this._form } get _isInBalloon() { return !!this._balloon && this._balloon.hasView(this._form) } } class VL extends wl { static get requires() { return [EL, RL] } static get pluginName() { return "ImageTextAlternative" } } function jL(t) { const e = (e, n, i) => { if (!i.consumable.test(n.viewItem, { name: true, classes: "image" })) { return } const o = t.findViewImgElement(n.viewItem); if (!o || !i.consumable.test(o, { name: true })) { return } i.consumable.consume(n.viewItem, { name: true, classes: "image" }); const r = i.convertItem(o, n.modelCursor); const s = ol(r.modelRange.getItems()); if (!s) { i.consumable.revert(n.viewItem, { name: true, classes: "image" }); return } i.convertChildren(n.viewItem, s); i.updateConversionResult(s, n) }; return t => { t.on("element:figure", e) } } function FL(t) { const e = ["srcset", "media", "type", "sizes"]; const n = (n, i, o) => { const r = i.viewItem; if (!o.consumable.test(r, { name: true })) { return } const s = new Map; for (const t of r.getChildren()) { if (t.is("element", "source")) { const n = {}; for (const i of e) { if (t.hasAttribute(i)) { if (o.consumable.test(t, { attributes: i })) { n[i] = t.getAttribute(i) } } } if (Object.keys(n).length) { s.set(t, n) } } } const a = t.findViewImgElement(r); if (!a) { return } let c = i.modelCursor.parent; if (!c.is("element", "imageBlock")) { const t = o.convertItem(a, i.modelCursor); i.modelRange = t.modelRange; i.modelCursor = t.modelCursor; c = first(t.modelRange.getItems()) } o.consumable.consume(r, { name: true }); for (const [t, e] of s) { o.consumable.consume(t, { attributes: Object.keys(e) }) } if (s.size) { o.writer.setAttribute("sources", Array.from(s.values()), c) } o.convertChildren(r, c) }; return t => { t.on("element:picture", n) } } function HL(t, e) { const n = (e, n, i) => { if (!i.consumable.consume(n.item, e.name)) { return } const o = i.writer; const r = i.mapper.toViewElement(n.item); const s = t.findViewImgElement(r); if (n.attributeNewValue === null) { const t = n.attributeOldValue; if (t && t.data) { o.removeAttribute("srcset", s); o.removeAttribute("sizes", s); if (t.width) { o.removeAttribute("width", s) } } } else { const t = n.attributeNewValue; if (t && t.data) { o.setAttribute("srcset", t.data, s); o.setAttribute("sizes", "100vw", s); if (t.width) { o.setAttribute("width", t.width, s) } } } }; return t => { t.on(`attribute:srcset:${e}`, n) } } function UL(t) { const e = (e, n, i) => { if (!i.consumable.consume(n.item, e.name)) { return } const o = i.writer; const r = i.mapper.toViewElement(n.item); const s = t.findViewImgElement(r); const a = n.attributeNewValue; if (a && a.length) { const t = o.createContainerElement("picture", null, a.map((t => o.createEmptyElement("source", t)))); const e = []; let n = s.parent; while (n && n.is("attributeElement")) { const t = n.parent; o.unwrap(o.createRangeOn(s), n); e.unshift(n); n = t } o.insert(o.createPositionBefore(s), t); o.move(o.createRangeOn(s), o.createPositionAt(t, "end")); for (const n of e) { o.wrap(o.createRangeOn(t), n) } } else if (s.parent.is("element", "picture")) { const t = s.parent; o.move(o.createRangeOn(s), o.createPositionBefore(t)); o.remove(t) } }; return t => { t.on("attribute:sources:imageBlock", e); t.on("attribute:sources:imageInline", e) } } function WL(t, e, n) { const i = (e, n, i) => { if (!i.consumable.consume(n.item, e.name)) { return } const o = i.writer; const r = i.mapper.toViewElement(n.item); const s = t.findViewImgElement(r); o.setAttribute(n.attributeKey, n.attributeNewValue || "", s) }; return t => { t.on(`attribute:${n}:${e}`, i) } } class qL extends yg { observe(t) { this.listenTo(t, "load", ((t, e) => { const n = e.target; if (this.checkShouldIgnoreEventFromTarget(n)) { return } if (n.tagName == "IMG") { this._fireEvents(e) } }), { useCapture: true }) } stopObserving(t) { this.stopListening(t) } _fireEvents(t) { if (this.isEnabled) { this.document.fire("layoutChanged"); this.document.fire("imageLoaded", t) } } } class GL extends _l { constructor(t) { super(t); const e = t.config.get("image.insert.type"); if (!t.plugins.has("ImageBlockEditing")) { if (e === "block") { M("image-block-plugin-required") } } if (!t.plugins.has("ImageInlineEditing")) { if (e === "inline") { M("image-inline-plugin-required") } } } refresh() { const t = this.editor.plugins.get("ImageUtils"); this.isEnabled = t.isImageAllowed() } execute(t) { const e = $c(t.source); const n = this.editor.model.document.selection; const i = this.editor.plugins.get("ImageUtils"); const o = Object.fromEntries(n.getAttributes()); e.forEach(((t, e) => { const r = n.getSelectedElement(); if (typeof t === "string") { t = { src: t } } if (e && r && i.isImage(r)) { const e = this.editor.model.createPositionAfter(r); i.insertImage({ ...t, ...o }, e) } else { i.insertImage({ ...t, ...o }) } })) } } class $L extends _l { refresh() { const t = this.editor; const e = t.plugins.get("ImageUtils"); const n = this.editor.model.document.selection.getSelectedElement(); this.isEnabled = e.isImage(n); this.value = this.isEnabled ? n.getAttribute("src") : null } execute(t) { const e = this.editor.model.document.selection.getSelectedElement(); this.editor.model.change((n => { n.setAttribute("src", t.source, e); n.removeAttribute("srcset", e); n.removeAttribute("sizes", e) })) } } class KL extends wl { static get requires() { return [oT] } static get pluginName() { return "ImageEditing" } init() { const t = this.editor; const e = t.conversion; t.editing.view.addObserver(qL); e.for("upcast").attributeToAttribute({ view: { name: "img", key: "alt" }, model: "alt" }).attributeToAttribute({ view: { name: "img", key: "srcset" }, model: { key: "srcset", value: t => { const e = { data: t.getAttribute("srcset") }; if (t.hasAttribute("width")) { e.width = t.getAttribute("width") } return e } } }); const n = new GL(t); const i = new $L(t); t.commands.add("insertImage", n); t.commands.add("replaceImageSource", i); t.commands.add("imageInsert", n) } } class YL extends _l { constructor(t, e) { super(t); this._modelElementName = e } refresh() { const t = this.editor; const e = t.plugins.get("ImageUtils"); const n = e.getClosestSelectedImageElement(this.editor.model.document.selection); if (this._modelElementName === "imageBlock") { this.isEnabled = e.isInlineImage(n) } else { this.isEnabled = e.isBlockImage(n) } } execute() { const t = this.editor; const e = this.editor.model; const n = t.plugins.get("ImageUtils"); const i = n.getClosestSelectedImageElement(e.document.selection); const o = Object.fromEntries(i.getAttributes()); if (!o.src && !o.uploadId) { return null } return e.change((t => { const r = Array.from(e.markers).filter((t => t.getRange().containsItem(i))); const s = n.insertImage(o, e.createSelection(i, "on"), this._modelElementName); if (!s) { return null } const a = t.createRangeOn(s); for (const e of r) { const n = e.getRange(); const i = n.root.rootName != "$graveyard" ? n.getJoined(a, true) : a; t.updateMarker(e, { range: i }) } return { oldElement: i, newElement: s } })) } } class QL extends wl { static get requires() { return [KL, oT, aE] } static get pluginName() { return "ImageBlockEditing" } init() { const t = this.editor; const e = t.model.schema; e.register("imageBlock", { inheritAllFrom: "$blockObject", allowAttributes: ["alt", "src", "srcset"] }); this._setupConversion(); if (t.plugins.has("ImageInlineEditing")) { t.commands.add("imageTypeBlock", new YL(this.editor, "imageBlock")); this._setupClipboardIntegration() } } _setupConversion() { const t = this.editor; const e = t.t; const n = t.conversion; const i = t.plugins.get("ImageUtils"); n.for("dataDowncast").elementToStructure({ model: "imageBlock", view: (t, { writer: e }) => eT(e) }); n.for("editingDowncast").elementToStructure({ model: "imageBlock", view: (t, { writer: n }) => i.toImageWidget(eT(n), n, e("image widget")) }); n.for("downcast").add(WL(i, "imageBlock", "src")).add(WL(i, "imageBlock", "alt")).add(HL(i, "imageBlock")); n.for("upcast").elementToElement({ view: nT(t, "imageBlock"), model: (t, { writer: e }) => e.createElement("imageBlock", t.hasAttribute("src") ? { src: t.getAttribute("src") } : undefined) }).add(jL(i)) } _setupClipboardIntegration() { const t = this.editor; const e = t.model; const n = t.editing.view; const i = t.plugins.get("ImageUtils"); const o = t.plugins.get("ClipboardPipeline"); this.listenTo(o, "inputTransformation", ((o, r) => { const s = Array.from(r.content.getChildren()); let a; if (!s.every(i.isInlineImageView)) { return } if (r.targetRanges) { a = t.editing.mapper.toModelRange(r.targetRanges[0]) } else { a = e.document.selection.getFirstRange() } const c = e.createSelection(a); if (iT(e.schema, c) === "imageBlock") { const t = new Uw(n.document); const e = s.map((e => t.createElement("figure", { class: "image" }, e))); r.content = t.createDocumentFragment(e) } })) } } var ZL = n(9048); var JL = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; JL.insert = "head"; JL.singleton = true; var XL = Sl()(ZL.Z, JL); const tN = ZL.Z.locals || {}; class eN extends wl { static get requires() { return [QL, oS, VL] } static get pluginName() { return "ImageBlock" } } class nN extends wl { static get requires() { return [KL, oT, aE] } static get pluginName() { return "ImageInlineEditing" } init() { const t = this.editor; const e = t.model.schema; e.register("imageInline", { inheritAllFrom: "$inlineObject", allowAttributes: ["alt", "src", "srcset"] }); e.addChildCheck(((t, e) => { if (t.endsWith("caption") && e.name === "imageInline") { return false } })); this._setupConversion(); if (t.plugins.has("ImageBlockEditing")) { t.commands.add("imageTypeInline", new YL(this.editor, "imageInline")); this._setupClipboardIntegration() } } _setupConversion() { const t = this.editor; const e = t.t; const n = t.conversion; const i = t.plugins.get("ImageUtils"); n.for("dataDowncast").elementToElement({ model: "imageInline", view: (t, { writer: e }) => e.createEmptyElement("img") }); n.for("editingDowncast").elementToStructure({ model: "imageInline", view: (t, { writer: n }) => i.toImageWidget(tT(n), n, e("image widget")) }); n.for("downcast").add(WL(i, "imageInline", "src")).add(WL(i, "imageInline", "alt")).add(HL(i, "imageInline")); n.for("upcast").elementToElement({ view: nT(t, "imageInline"), model: (t, { writer: e }) => e.createElement("imageInline", t.hasAttribute("src") ? { src: t.getAttribute("src") } : undefined) }) } _setupClipboardIntegration() { const t = this.editor; const e = t.model; const n = t.editing.view; const i = t.plugins.get("ImageUtils"); const o = t.plugins.get("ClipboardPipeline"); this.listenTo(o, "inputTransformation", ((o, r) => { const s = Array.from(r.content.getChildren()); let a; if (!s.every(i.isBlockImageView)) { return } if (r.targetRanges) { a = t.editing.mapper.toModelRange(r.targetRanges[0]) } else { a = e.document.selection.getFirstRange() } const c = e.createSelection(a); if (iT(e.schema, c) === "imageInline") { const t = new Uw(n.document); const e = s.map((e => { if (e.childCount === 1) { Array.from(e.getAttributes()).forEach((n => t.setAttribute(...n, i.findViewImgElement(e)))); return e.getChild(0) } else { return e } })); r.content = t.createDocumentFragment(e) } })) } } class iN extends wl { static get requires() { return [nN, oS, VL] } static get pluginName() { return "ImageInline" } } class oN extends wl { static get requires() { return [eN, iN] } static get pluginName() { return "Image" } } class rN extends _l { refresh() { const t = this.editor; const e = t.plugins.get("ImageCaptionUtils"); const n = t.plugins.get("ImageUtils"); if (!t.plugins.has(QL)) { this.isEnabled = false; this.value = false; return } const i = t.model.document.selection; const o = i.getSelectedElement(); if (!o) { const t = e.getCaptionFromModelSelection(i); this.isEnabled = !!t; this.value = !!t; return } this.isEnabled = n.isImage(o); if (!this.isEnabled) { this.value = false } else { this.value = !!e.getCaptionFromImageModelElement(o) } } execute(t = {}) { const { focusCaptionOnShow: e } = t; this.editor.model.change((t => { if (this.value) { this._hideImageCaption(t) } else { this._showImageCaption(t, e) } })) } _showImageCaption(t, e) { const n = this.editor.model; const i = n.document.selection; const o = this.editor.plugins.get("ImageCaptionEditing"); const r = this.editor.plugins.get("ImageUtils"); let s = i.getSelectedElement(); const a = o._getSavedCaption(s); if (r.isInlineImage(s)) { this.editor.execute("imageTypeBlock"); s = i.getSelectedElement() } const c = a || t.createElement("caption"); t.append(c, s); if (e) { t.setSelection(c, "in") } } _hideImageCaption(t) { const e = this.editor; const n = e.model.document.selection; const i = e.plugins.get("ImageCaptionEditing"); const o = e.plugins.get("ImageCaptionUtils"); let r = n.getSelectedElement(); let s; if (r) { s = o.getCaptionFromImageModelElement(r) } else { s = o.getCaptionFromModelSelection(n); r = s.parent } i._saveCaption(r, s); t.setSelection(r, "on"); t.remove(s) } } class sN extends wl { static get pluginName() { return "ImageCaptionUtils" } static get requires() { return [oT] } getCaptionFromImageModelElement(t) { for (const e of t.getChildren()) { if (!!e && e.is("element", "caption")) { return e } } return null } getCaptionFromModelSelection(t) { const e = this.editor.plugins.get("ImageUtils"); const n = t.getFirstPosition().findAncestor("caption"); if (!n) { return null } if (e.isBlockImage(n.parent)) { return n } return null } matchImageCaptionViewElement(t) { const e = this.editor.plugins.get("ImageUtils"); if (t.name == "figcaption" && e.isBlockImageView(t.parent)) { return { name: true } } return null } } class aN extends wl { static get requires() { return [oT, sN] } static get pluginName() { return "ImageCaptionEditing" } constructor(t) { super(t); this._savedCaptionsMap = new WeakMap } init() { const t = this.editor; const e = t.model.schema; if (!e.isRegistered("caption")) { e.register("caption", { allowIn: "imageBlock", allowContentOf: "$block", isLimit: true }) } else { e.extend("caption", { allowIn: "imageBlock" }) } t.commands.add("toggleImageCaption", new rN(this.editor)); this._setupConversion(); this._setupImageTypeCommandsIntegration(); this._registerCaptionReconversion() } _setupConversion() { const t = this.editor; const e = t.editing.view; const n = t.plugins.get("ImageUtils"); const i = t.plugins.get("ImageCaptionUtils"); const o = t.t; t.conversion.for("upcast").elementToElement({ view: t => i.matchImageCaptionViewElement(t), model: "caption" }); t.conversion.for("dataDowncast").elementToElement({ model: "caption", view: (t, { writer: e }) => { if (!n.isBlockImage(t.parent)) { return null } return e.createContainerElement("figcaption") } }); t.conversion.for("editingDowncast").elementToElement({ model: "caption", view: (t, { writer: i }) => { if (!n.isBlockImage(t.parent)) { return null } const r = i.createEditableElement("figcaption"); i.setCustomProperty("imageCaption", true, r); Nl({ view: e, element: r, text: o("Enter image caption"), keepOnFocus: true }); const s = t.parent.getAttribute("alt"); const a = s ? o("Caption for image: %0", [s]) : o("Caption for the image"); return yD(r, i, { label: a }) } }) } _setupImageTypeCommandsIntegration() { const t = this.editor; const e = t.plugins.get("ImageUtils"); const n = t.plugins.get("ImageCaptionUtils"); const i = t.commands.get("imageTypeInline"); const o = t.commands.get("imageTypeBlock"); const r = t => { if (!t.return) { return } const { oldElement: i, newElement: o } = t.return; if (!i) { return } if (e.isBlockImage(i)) { const t = n.getCaptionFromImageModelElement(i); if (t) { this._saveCaption(o, t); return } } const r = this._getSavedCaption(i); if (r) { this._saveCaption(o, r) } }; if (i) { this.listenTo(i, "execute", r, { priority: "low" }) } if (o) { this.listenTo(o, "execute", r, { priority: "low" }) } } _getSavedCaption(t) { const e = this._savedCaptionsMap.get(t); return e ? gf.fromJSON(e) : null } _saveCaption(t, e) { this._savedCaptionsMap.set(t, e.toJSON()) } _registerCaptionReconversion() { const t = this.editor; const e = t.model; const n = t.plugins.get("ImageUtils"); const i = t.plugins.get("ImageCaptionUtils"); e.document.on("change:data", (() => { const o = e.document.differ.getChanges(); for (const e of o) { if (e.attributeKey !== "alt") { continue } const o = e.range.start.nodeAfter; if (n.isBlockImage(o)) { const e = i.getCaptionFromImageModelElement(o); if (!e) { return } t.editing.reconvertItem(e) } } })) } } class cN extends wl { static get requires() { return [sN] } static get pluginName() { return "ImageCaptionUI" } init() { const t = this.editor; const e = t.editing.view; const n = t.plugins.get("ImageCaptionUtils"); const i = t.t; t.ui.componentFactory.add("toggleImageCaption", (o => { const r = t.commands.get("toggleImageCaption"); const s = new wC(o); s.set({ icon: v_.caption, tooltip: true, isToggleable: true }); s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"); s.bind("label").to(r, "value", (t => t ? i("Toggle caption off") : i("Toggle caption on"))); this.listenTo(s, "execute", (() => { t.execute("toggleImageCaption", { focusCaptionOnShow: true }); const i = n.getCaptionFromModelSelection(t.model.document.selection); if (i) { const n = t.editing.mapper.toViewElement(i); e.scrollToTheSelection(); e.change((t => { t.addClass("image__caption_highlighted", n) })) } t.editing.view.focus() })); return s })) } } var lN = n(8662); var dN = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; dN.insert = "head"; dN.singleton = true; var uN = Sl()(lN.Z, dN); const hN = lN.Z.locals || {}; class gN extends wl { static get requires() { return [aN, cN] } static get pluginName() { return "ImageCaption" } } class mN extends _l { refresh() { const t = this.editor; const e = t.plugins.get("ImageUtils"); const n = e.getClosestSelectedImageElement(t.model.document.selection); this.isEnabled = !!n; if (!n || !n.hasAttribute("width")) { this.value = null } else { this.value = { width: n.getAttribute("width"), height: null } } } execute(t) { const e = this.editor; const n = e.model; const i = e.plugins.get("ImageUtils"); const o = i.getClosestSelectedImageElement(n.document.selection); this.value = { width: t.width, height: null }; if (o) { n.change((e => { e.setAttribute("width", t.width, o) })) } } } class fN extends wl { static get requires() { return [oT] } static get pluginName() { return "ImageResizeEditing" } constructor(t) { super(t); t.config.define("image", { resizeUnit: "%", resizeOptions: [{ name: "resizeImage:original", value: null, icon: "original" }, { name: "resizeImage:25", value: "25", icon: "small" }, { name: "resizeImage:50", value: "50", icon: "medium" }, { name: "resizeImage:75", value: "75", icon: "large" }] }) } init() { const t = this.editor; const e = new mN(t); this._registerSchema(); this._registerConverters("imageBlock"); this._registerConverters("imageInline"); t.commands.add("resizeImage", e); t.commands.add("imageResize", e) } _registerSchema() { if (this.editor.plugins.has("ImageBlockEditing")) { this.editor.model.schema.extend("imageBlock", { allowAttributes: "width" }) } if (this.editor.plugins.has("ImageInlineEditing")) { this.editor.model.schema.extend("imageInline", { allowAttributes: "width" }) } } _registerConverters(t) { const e = this.editor; e.conversion.for("downcast").add((e => e.on(`attribute:width:${t}`, ((t, e, n) => { if (!n.consumable.consume(e.item, t.name)) { return } const i = n.writer; const o = n.mapper.toViewElement(e.item); if (e.attributeNewValue !== null) { i.setStyle("width", e.attributeNewValue, o); i.addClass("image_resized", o) } else { i.removeStyle("width", o); i.removeClass("image_resized", o) } })))); e.conversion.for("upcast").attributeToAttribute({ view: { name: t === "imageBlock" ? "figure" : "img", styles: { width: /.+/ } }, model: { key: "width", value: t => t.getStyle("width") } }) } } const pN = { small: v_.objectSizeSmall, medium: v_.objectSizeMedium, large: v_.objectSizeLarge, original: v_.objectSizeFull }; class bN extends wl { static get requires() { return [fN] } static get pluginName() { return "ImageResizeButtons" } constructor(t) { super(t); this._resizeUnit = t.config.get("image.resizeUnit") } init() { const t = this.editor; const e = t.config.get("image.resizeOptions"); const n = t.commands.get("resizeImage"); this.bind("isEnabled").to(n); for (const t of e) { this._registerImageResizeButton(t) } this._registerImageResizeDropdown(e) } _registerImageResizeButton(t) { const e = this.editor; const { name: n, value: i, icon: o } = t; const r = i ? i + this._resizeUnit : null; e.ui.componentFactory.add(n, (n => { const i = new wC(n); const s = e.commands.get("resizeImage"); const a = this._getOptionLabelValue(t, true); if (!pN[o]) { throw new I("imageresizebuttons-missing-icon", e, t) } i.set({ label: a, icon: pN[o], tooltip: a, isToggleable: true }); i.bind("isEnabled").to(this); i.bind("isOn").to(s, "value", kN(r)); this.listenTo(i, "execute", (() => { e.execute("resizeImage", { width: r }) })); return i })) } _registerImageResizeDropdown(t) { const e = this.editor; const n = e.t; const i = t.find((t => !t.value)); const o = o => { const r = e.commands.get("resizeImage"); const s = Dv(o, WC); const a = s.buttonView; a.set({ tooltip: n("Resize image"), commandValue: i.value, icon: pN.medium, isToggleable: true, label: this._getOptionLabelValue(i), withText: true, class: "ck-resize-image-button" }); a.bind("label").to(r, "value", (t => { if (t && t.width) { return t.width } else { return this._getOptionLabelValue(i) } })); s.bind("isEnabled").to(this); Iv(s, (() => this._getResizeDropdownListItemDefinitions(t, r)), { ariaLabel: n("Image resize list") }); this.listenTo(s, "execute", (t => { e.execute(t.source.commandName, { width: t.source.commandValue }); e.editing.view.focus() })); return s }; e.ui.componentFactory.add("resizeImage", o); e.ui.componentFactory.add("imageResize", o) } _getOptionLabelValue(t, e = false) { const n = this.editor.t; if (t.label) { return t.label } else if (e) { if (t.value) { return n("Resize image to %0", t.value + this._resizeUnit) } else { return n("Resize image to the original size") } } else { if (t.value) { return t.value + this._resizeUnit } else { return n("Original") } } } _getResizeDropdownListItemDefinitions(t, e) { const n = new il; t.map((t => { const i = t.value ? t.value + this._resizeUnit : null; const o = { type: "button", model: new Fy({ commandName: "resizeImage", commandValue: i, label: this._getOptionLabelValue(t), withText: true, icon: null }) }; o.model.bind("isOn").to(e, "value", kN(i)); n.add(o) })); return n } } function kN(t) { return e => { const n = e; if (t === null && n === t) { return true } return n !== null && n.width === t } } const wN = "figure.image.ck-widget > img," + "figure.image.ck-widget > picture > img," + "figure.image.ck-widget > a > img," + "figure.image.ck-widget > a > picture > img," + "span.image-inline.ck-widget > img," + "span.image-inline.ck-widget > picture > img"; const AN = /(image|image-inline)/; const _N = "image_resized"; class CN extends wl { static get requires() { return [ES] } static get pluginName() { return "ImageResizeHandles" } init() { const t = this.editor.commands.get("resizeImage"); this.bind("isEnabled").to(t); this._setupResizerCreator() } _setupResizerCreator() { const t = this.editor; const e = t.editing.view; e.addObserver(qL); this.listenTo(e.document, "imageLoaded", ((n, i) => { if (!i.target.matches(wN)) { return } const o = t.editing.view.domConverter; const r = o.domToView(i.target); const s = r.findAncestor({ classes: AN }); let a = this.editor.plugins.get(ES).getResizerByViewElement(s); if (a) { a.redraw(); return } const c = t.editing.mapper; const l = c.toModelElement(s); a = t.plugins.get(ES).attachTo({ unit: t.config.get("image.resizeUnit"), modelElement: l, viewElement: s, editor: t, getHandleHost(t) { return t.querySelector("img") }, getResizeHost() { return o.mapViewToDom(c.toViewElement(l.parent)) }, isCentered() { const t = l.getAttribute("imageStyle"); return !t || t == "block" || t == "alignCenter" }, onCommit(n) { e.change((t => { t.removeClass(_N, s) })); t.execute("resizeImage", { width: n }) } }); a.on("updateSize", (() => { if (!s.hasClass(_N)) { e.change((t => { t.addClass(_N, s) })) } })); a.bind("isEnabled").to(this) })) } } var vN = n(1043); var yN = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; yN.insert = "head"; yN.singleton = true; var xN = Sl()(vN.Z, yN); const EN = vN.Z.locals || {}; class DN extends wl { static get requires() { return [fN, CN, bN] } static get pluginName() { return "ImageResize" } } class SN extends _l { constructor(t, e) { super(t); this._defaultStyles = { imageBlock: false, imageInline: false }; this._styles = new Map(e.map((t => { if (t.isDefault) { for (const e of t.modelElements) { this._defaultStyles[e] = t.name } } return [t.name, t] }))) } refresh() { const t = this.editor; const e = t.plugins.get("ImageUtils"); const n = e.getClosestSelectedImageElement(this.editor.model.document.selection); this.isEnabled = !!n; if (!this.isEnabled) { this.value = false } else if (n.hasAttribute("imageStyle")) { this.value = n.getAttribute("imageStyle") } else { this.value = this._defaultStyles[n.name] } } execute(t = {}) { const e = this.editor; const n = e.model; const i = e.plugins.get("ImageUtils"); n.change((e => { const o = t.value; let r = i.getClosestSelectedImageElement(n.document.selection); if (o && this.shouldConvertImageType(o, r)) { this.editor.execute(i.isBlockImage(r) ? "imageTypeInline" : "imageTypeBlock"); r = i.getClosestSelectedImageElement(n.document.selection) } if (!o || this._styles.get(o).isDefault) { e.removeAttribute("imageStyle", r) } else { e.setAttribute("imageStyle", o, r) } })) } shouldConvertImageType(t, e) { const n = this._styles.get(t).modelElements; return !n.includes(e.name) } } const { objectFullWidth: TN, objectInline: IN, objectLeft: MN, objectRight: BN, objectCenter: LN, objectBlockLeft: NN, objectBlockRight: zN } = v_; const PN = { get inline() { return { name: "inline", title: "In line", icon: IN, modelElements: ["imageInline"], isDefault: true } }, get alignLeft() { return { name: "alignLeft", title: "Left aligned image", icon: MN, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-left" } }, get alignBlockLeft() { return { name: "alignBlockLeft", title: "Left aligned image", icon: NN, modelElements: ["imageBlock"], className: "image-style-block-align-left" } }, get alignCenter() { return { name: "alignCenter", title: "Centered image", icon: LN, modelElements: ["imageBlock"], className: "image-style-align-center" } }, get alignRight() { return { name: "alignRight", title: "Right aligned image", icon: BN, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-right" } }, get alignBlockRight() { return { name: "alignBlockRight", title: "Right aligned image", icon: zN, modelElements: ["imageBlock"], className: "image-style-block-align-right" } }, get block() { return { name: "block", title: "Centered image", icon: LN, modelElements: ["imageBlock"], isDefault: true } }, get side() { return { name: "side", title: "Side image", icon: BN, modelElements: ["imageBlock"], className: "image-style-side" } } }; const ON = { full: TN, left: NN, right: zN, center: LN, inlineLeft: MN, inlineRight: BN, inline: IN }; const RN = [{ name: "imageStyle:wrapText", title: "Wrap text", defaultItem: "imageStyle:alignLeft", items: ["imageStyle:alignLeft", "imageStyle:alignRight"] }, { name: "imageStyle:breakText", title: "Break text", defaultItem: "imageStyle:block", items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"] }]; function VN(t) { const e = t.configuredStyles.options || []; const n = e.map((t => HN(t))).filter((e => UN(e, t))); return n } function jN(t, e) { if (t && e) { return { options: ["inline", "alignLeft", "alignRight", "alignCenter", "alignBlockLeft", "alignBlockRight", "block", "side"] } } else if (t) { return { options: ["block", "side"] } } else if (e) { return { options: ["inline", "alignLeft", "alignRight"] } } return {} } function FN(t) { if (t.has("ImageBlockEditing") && t.has("ImageInlineEditing")) { return [...RN] } else { return [] } } function HN(t) { if (typeof t === "string") { if (!PN[t]) { t = { name: t } } else { t = { ...PN[t] } } } else { t = WN(PN[t.name], t) } if (typeof t.icon === "string") { t.icon = ON[t.icon] || t.icon } return t } function UN(t, { isBlockPluginLoaded: e, isInlinePluginLoaded: n }) { const { modelElements: i, name: o } = t; if (!i || !i.length || !o) { qN({ style: t }); return false } else { const o = [e ? "imageBlock" : null, n ? "imageInline" : null]; if (!i.some((t => o.includes(t)))) { M("image-style-missing-dependency", { style: t, missingPlugins: i.map((t => t === "imageBlock" ? "ImageBlockEditing" : "ImageInlineEditing")) }); return false } } return true } function WN(t, e) { const n = { ...e }; for (const i in t) { if (!Object.prototype.hasOwnProperty.call(e, i)) { n[i] = t[i] } } return n } function qN(t) { M("image-style-configuration-definition-invalid", t) } const GN = { normalizeStyles: VN, getDefaultStylesConfiguration: jN, getDefaultDropdownDefinitions: FN, warnInvalidStyle: qN, DEFAULT_OPTIONS: PN, DEFAULT_ICONS: ON, DEFAULT_DROPDOWN_DEFINITIONS: RN }; function $N(t) { return (e, n, i) => { if (!i.consumable.consume(n.item, e.name)) { return } const o = YN(n.attributeNewValue, t); const r = YN(n.attributeOldValue, t); const s = i.mapper.toViewElement(n.item); const a = i.writer; if (r) { a.removeClass(r.className, s) } if (o) { a.addClass(o.className, s) } } } function KN(t) { const e = { imageInline: t.filter((t => !t.isDefault && t.modelElements.includes("imageInline"))), imageBlock: t.filter((t => !t.isDefault && t.modelElements.includes("imageBlock"))) }; return (t, n, i) => { if (!n.modelRange) { return } const o = n.viewItem; const r = ol(n.modelRange.getItems()); if (!r) { return } if (!i.schema.checkAttribute(r, "imageStyle")) { return } for (const t of e[r.name]) { if (i.consumable.consume(o, { classes: t.className })) { i.writer.setAttribute("imageStyle", t.name, r) } } } } function YN(t, e) { for (const n of e) { if (n.name === t) { return n } } } class QN extends wl { static get pluginName() { return "ImageStyleEditing" } static get requires() { return [oT] } init() { const { normalizeStyles: t, getDefaultStylesConfiguration: e } = GN; const n = this.editor; const i = n.plugins.has("ImageBlockEditing"); const o = n.plugins.has("ImageInlineEditing"); n.config.define("image.styles", e(i, o)); this.normalizedStyles = t({ configuredStyles: n.config.get("image.styles"), isBlockPluginLoaded: i, isInlinePluginLoaded: o }); this._setupConversion(i, o); this._setupPostFixer(); n.commands.add("imageStyle", new SN(n, this.normalizedStyles)) } _setupConversion(t, e) { const n = this.editor; const i = n.model.schema; const o = $N(this.normalizedStyles); const r = KN(this.normalizedStyles); n.editing.downcastDispatcher.on("attribute:imageStyle", o); n.data.downcastDispatcher.on("attribute:imageStyle", o); if (t) { i.extend("imageBlock", { allowAttributes: "imageStyle" }); n.data.upcastDispatcher.on("element:figure", r, { priority: "low" }) } if (e) { i.extend("imageInline", { allowAttributes: "imageStyle" }); n.data.upcastDispatcher.on("element:img", r, { priority: "low" }) } } _setupPostFixer() { const t = this.editor; const e = t.model.document; const n = t.plugins.get(oT); const i = new Map(this.normalizedStyles.map((t => [t.name, t]))); e.registerPostFixer((t => { let o = false; for (const r of e.differ.getChanges()) { if (r.type == "insert" || r.type == "attribute" && r.attributeKey == "imageStyle") { let e = r.type == "insert" ? r.position.nodeAfter : r.range.start.nodeAfter; if (e && e.is("element", "paragraph") && e.childCount > 0) { e = e.getChild(0) } if (!n.isImage(e)) { continue } const s = e.getAttribute("imageStyle"); if (!s) { continue } const a = i.get(s); if (!a || !a.modelElements.includes(e.name)) { t.removeAttribute("imageStyle", e); o = true } } } return o })) } } var ZN = n(4622); var JN = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; JN.insert = "head"; JN.singleton = true; var XN = Sl()(ZN.Z, JN); const tz = ZN.Z.locals || {}; class ez extends wl { static get requires() { return [QN] } static get pluginName() { return "ImageStyleUI" } get localizedDefaultStylesTitles() { const t = this.editor.t; return { "Wrap text": t("Wrap text"), "Break text": t("Break text"), "In line": t("In line"), "Full size image": t("Full size image"), "Side image": t("Side image"), "Left aligned image": t("Left aligned image"), "Centered image": t("Centered image"), "Right aligned image": t("Right aligned image") } } init() { const t = this.editor.plugins; const e = this.editor.config.get("image.toolbar") || []; const n = t.get("ImageStyleEditing"); const i = nz(n.normalizedStyles, this.localizedDefaultStylesTitles); for (const t of i) { this._createButton(t) } const o = nz([...e.filter(nt), ...GN.getDefaultDropdownDefinitions(t)], this.localizedDefaultStylesTitles); for (const t of o) { this._createDropdown(t, i) } } _createDropdown(t, e) { const n = this.editor.ui.componentFactory; n.add(t.name, (i => { let o; const { defaultItem: r, items: s, title: a } = t; const c = s.filter((t => e.find((({ name: e }) => iz(e) === t)))).map((t => { const e = n.create(t); if (t === r) { o = e } return e })); if (s.length !== c.length) { GN.warnInvalidStyle({ dropdown: t }) } const l = Dv(i, YC); const d = l.buttonView; const u = d.arrowView; Sv(l, c, { enableActiveItemFocusOnDropdownOpen: true }); d.set({ label: oz(a, o.label), class: null, tooltip: true }); u.unbind("label"); u.set({ label: a }); d.bind("icon").toMany(c, "isOn", ((...t) => { const e = t.findIndex(gu); return e < 0 ? o.icon : c[e].icon })); d.bind("label").toMany(c, "isOn", ((...t) => { const e = t.findIndex(gu); return oz(a, e < 0 ? o.label : c[e].label) })); d.bind("isOn").toMany(c, "isOn", ((...t) => t.some(gu))); d.bind("class").toMany(c, "isOn", ((...t) => t.some(gu) ? "ck-splitbutton_flatten" : undefined)); d.on("execute", (() => { if (!c.some((({ isOn: t }) => t))) { o.fire("execute") } else { l.isOpen = !l.isOpen } })); l.bind("isEnabled").toMany(c, "isEnabled", ((...t) => t.some(gu))); this.listenTo(l, "execute", (() => { this.editor.editing.view.focus() })); return l })) } _createButton(t) { const e = t.name; this.editor.ui.componentFactory.add(iz(e), (n => { const i = this.editor.commands.get("imageStyle"); const o = new wC(n); o.set({ label: t.title, icon: t.icon, tooltip: true, isToggleable: true }); o.bind("isEnabled").to(i, "isEnabled"); o.bind("isOn").to(i, "value", (t => t === e)); o.on("execute", this._executeCommand.bind(this, e)); return o })) } _executeCommand(t) { this.editor.execute("imageStyle", { value: t }); this.editor.editing.view.focus() } } function nz(t, e) { for (const n of t) { if (e[n.title]) { n.title = e[n.title] } } return t } function iz(t) { return `imageStyle:${t}` } function oz(t, e) { return (t ? t + ": " : "") + e } class rz extends wl { static get requires() { return [QN, ez] } static get pluginName() { return "ImageStyle" } } class sz extends wl { static get requires() { return [aS, oT] } static get pluginName() { return "ImageToolbar" } afterInit() { const t = this.editor; const e = t.t; const n = t.plugins.get(aS); const i = t.plugins.get("ImageUtils"); n.register("image", { ariaLabel: e("Image toolbar"), items: az(t.config.get("image.toolbar") || []), getRelatedElement: t => i.getClosestSelectedImageWidget(t) }) } } function az(t) { return t.map((t => nt(t) ? t.name : t)) } class cz extends (lt()) { constructor() { super(); const t = new window.FileReader; this._reader = t; this._data = undefined; this.set("loaded", 0); t.onprogress = t => { this.loaded = t.loaded } } get error() { return this._reader.error } get data() { return this._data } read(t) { const e = this._reader; this.total = t.size; return new Promise(((n, i) => { e.onload = () => { const t = e.result; this._data = t; n(t) }; e.onerror = () => { i("error") }; e.onabort = () => { i("aborted") }; this._reader.readAsDataURL(t) })) } abort() { this._reader.abort() } } class lz extends wl { constructor() { super(...arguments); this.loaders = new il; this._loadersMap = new Map; this._pendingAction = null } static get pluginName() { return "FileRepository" } static get requires() { return [HA] } init() { this.loaders.on("change", (() => this._updatePendingAction())); this.set("uploaded", 0); this.set("uploadTotal", null); this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", ((t, e) => e ? t / e * 100 : 0)) } getLoader(t) { return this._loadersMap.get(t) || null } createLoader(t) { if (!this.createUploadAdapter) { M("filerepository-no-upload-adapter"); return null } const e = new dz(Promise.resolve(t), this.createUploadAdapter); this.loaders.add(e); this._loadersMap.set(t, e); if (t instanceof Promise) { e.file.then((t => { this._loadersMap.set(t, e) })).catch((() => { })) } e.on("change:uploaded", (() => { let t = 0; for (const e of this.loaders) { t += e.uploaded } this.uploaded = t })); e.on("change:uploadTotal", (() => { let t = 0; for (const e of this.loaders) { if (e.uploadTotal) { t += e.uploadTotal } } this.uploadTotal = t })); return e } destroyLoader(t) { const e = t instanceof dz ? t : this.getLoader(t); e._destroy(); this.loaders.remove(e); this._loadersMap.forEach(((t, n) => { if (t === e) { this._loadersMap.delete(n) } })) } _updatePendingAction() { const t = this.editor.plugins.get(HA); if (this.loaders.length) { if (!this._pendingAction) { const e = this.editor.t; const n = t => `${e("Upload in progress")} ${parseInt(t)}%.`; this._pendingAction = t.add(n(this.uploadedPercent)); this._pendingAction.bind("message").to(this, "uploadedPercent", n) } } else { t.remove(this._pendingAction); this._pendingAction = null } } } class dz extends (lt()) { constructor(t, e) { super(); this.id = x(); this._filePromiseWrapper = this._createFilePromiseWrapper(t); this._adapter = e(this); this._reader = new cz; this.set("status", "idle"); this.set("uploaded", 0); this.set("uploadTotal", null); this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", ((t, e) => e ? t / e * 100 : 0)); this.set("uploadResponse", null) } get file() { if (!this._filePromiseWrapper) { return Promise.resolve(null) } else { return this._filePromiseWrapper.promise.then((t => this._filePromiseWrapper ? t : null)) } } get data() { return this._reader.data } read() { if (this.status != "idle") { throw new I("filerepository-read-wrong-status", this) } this.status = "reading"; return this.file.then((t => this._reader.read(t))).then((t => { if (this.status !== "reading") { throw this.status } this.status = "idle"; return t })).catch((t => { if (t === "aborted") { this.status = "aborted"; throw "aborted" } this.status = "error"; throw this._reader.error ? this._reader.error : t })) } upload() { if (this.status != "idle") { throw new I("filerepository-upload-wrong-status", this) } this.status = "uploading"; return this.file.then((() => this._adapter.upload())).then((t => { this.uploadResponse = t; this.status = "idle"; return t })).catch((t => { if (this.status === "aborted") { throw "aborted" } this.status = "error"; throw t })) } abort() { const t = this.status; this.status = "aborted"; if (!this._filePromiseWrapper.isFulfilled) { this._filePromiseWrapper.promise.catch((() => { })); this._filePromiseWrapper.rejecter("aborted") } else if (t == "reading") { this._reader.abort() } else if (t == "uploading" && this._adapter.abort) { this._adapter.abort() } this._destroy() } _destroy() { this._filePromiseWrapper = undefined; this._reader = undefined; this._adapter = undefined; this.uploadResponse = undefined } _createFilePromiseWrapper(t) { const e = {}; e.promise = new Promise(((n, i) => { e.rejecter = i; e.isFulfilled = false; t.then((t => { e.isFulfilled = true; n(t) })).catch((t => { e.isFulfilled = true; i(t) })) })); return e } } class uz extends N_ { constructor(t) { super(t); this.buttonView = new wC(t); this._fileInputView = new hz(t); this._fileInputView.bind("acceptedType").to(this); this._fileInputView.bind("allowMultipleFiles").to(this); this._fileInputView.delegate("done").to(this); this.setTemplate({ tag: "span", attributes: { class: "ck-file-dialog-button" }, children: [this.buttonView, this._fileInputView] }); this.buttonView.on("execute", (() => { this._fileInputView.open() })) } focus() { this.buttonView.focus() } } class hz extends N_ { constructor(t) { super(t); this.set("acceptedType", undefined); this.set("allowMultipleFiles", false); const e = this.bindTemplate; this.setTemplate({ tag: "input", attributes: { class: ["ck-hidden"], type: "file", tabindex: "-1", accept: e.to("acceptedType"), multiple: e.to("allowMultipleFiles") }, on: { change: e.to((() => { if (this.element && this.element.files && this.element.files.length) { this.fire("done", this.element.files) } this.element.value = "" })) } }) } open() { this.element.click() } } class gz extends (null && Plugin) { static get requires() { return [FileRepository] } static get pluginName() { return "Base64UploadAdapter" } init() { this.editor.plugins.get(FileRepository).createUploadAdapter = t => new mz(t) } } class mz { constructor(t) { this.loader = t } upload() { return new Promise(((t, e) => { const n = this.reader = new window.FileReader; n.addEventListener("load", (() => { t({ default: n.result }) })); n.addEventListener("error", (t => { e(t) })); n.addEventListener("abort", (() => { e() })); this.loader.file.then((t => { n.readAsDataURL(t) })) })) } abort() { this.reader.abort() } } class fz extends wl { static get requires() { return [lz] } static get pluginName() { return "SimpleUploadAdapter" } init() { const t = this.editor.config.get("simpleUpload"); if (!t) { return } if (!t.uploadUrl) { M("simple-upload-adapter-missing-uploadurl"); return } this.editor.plugins.get(lz).createUploadAdapter = e => new pz(e, t) } } class pz { constructor(t, e) { this.loader = t; this.options = e } upload() { return this.loader.file.then((t => new Promise(((e, n) => { this._initRequest(); this._initListeners(e, n, t); this._sendRequest(t) })))) } abort() { if (this.xhr) { this.xhr.abort() } } _initRequest() { const t = this.xhr = new XMLHttpRequest; t.open("POST", this.options.uploadUrl, true); t.responseType = "json" } _initListeners(t, e, n) { const i = this.xhr; const o = this.loader; const r = `Couldn't upload file: ${n.name}.`; i.addEventListener("error", (() => e(r))); i.addEventListener("abort", (() => e())); i.addEventListener("load", (() => { const n = i.response; if (!n || n.error) { return e(n && n.error && n.error.message ? n.error.message : r) } const o = n.url ? { default: n.url } : n.urls; t({ ...n, urls: o }) })); if (i.upload) { i.upload.addEventListener("progress", (t => { if (t.lengthComputable) { o.uploadTotal = t.total; o.uploaded = t.loaded } })) } } _sendRequest(t) { const e = this.options.headers || {}; const n = this.options.withCredentials || false; for (const t of Object.keys(e)) { this.xhr.setRequestHeader(t, e[t]) } this.xhr.withCredentials = n; const i = new FormData; i.append("upload", t); this.xhr.send(i) } } function bz(t) { const e = t.map((t => t.replace("+", "\\+"))); return new RegExp(`^image\\/(${e.join("|")})$`) } function kz(t) { return new Promise(((e, n) => { const i = t.getAttribute("src"); fetch(i).then((t => t.blob())).then((t => { const n = Az(t, i); const o = n.replace("image/", ""); const r = `image.${o}`; const s = new File([t], r, { type: n }); e(s) })).catch((t => t && t.name === "TypeError" ? _z(i).then(e).catch(n) : n(t))) })) } function wz(t, e) { if (!t.isInlineImageView(e) || !e.getAttribute("src")) { return false } return !!e.getAttribute("src").match(/^data:image\/\w+;base64,/g) || !!e.getAttribute("src").match(/^blob:/g) } function Az(t, e) { if (t.type) { return t.type } else if (e.match(/data:(image\/\w+);base64/)) { return e.match(/data:(image\/\w+);base64/)[1].toLowerCase() } else { return "image/jpeg" } } function _z(t) { return Cz(t).then((e => { const n = Az(e, t); const i = n.replace("image/", ""); const o = `image.${i}`; return new File([e], o, { type: n }) })) } function Cz(t) { return new Promise(((e, n) => { const i = Za.document.createElement("img"); i.addEventListener("load", (() => { const t = Za.document.createElement("canvas"); t.width = i.width; t.height = i.height; const o = t.getContext("2d"); o.drawImage(i, 0, 0); t.toBlob((t => t ? e(t) : n())) })); i.addEventListener("error", (() => n())); i.src = t })) } class vz extends wl { static get pluginName() { return "ImageUploadUI" } init() { const t = this.editor; const e = t.t; const n = n => { const i = new uz(n); const o = t.commands.get("uploadImage"); const r = t.config.get("image.upload.types"); const s = bz(r); i.set({ acceptedType: r.map((t => `image/${t}`)).join(","), allowMultipleFiles: true }); i.buttonView.set({ label: e("Insert image"), icon: v_.image, tooltip: true }); i.buttonView.bind("isEnabled").to(o); i.on("done", ((e, n) => { const i = Array.from(n).filter((t => s.test(t.type))); if (i.length) { t.execute("uploadImage", { file: i }); t.editing.view.focus() } })); return i }; t.ui.componentFactory.add("uploadImage", n); t.ui.componentFactory.add("imageUpload", n) } } var yz = n(5870); var xz = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; xz.insert = "head"; xz.singleton = true; var Ez = Sl()(yz.Z, xz); const Dz = yz.Z.locals || {}; var Sz = n(9899); var Tz = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Tz.insert = "head"; Tz.singleton = true; var Iz = Sl()(Sz.Z, Tz); const Mz = Sz.Z.locals || {}; var Bz = n(9825); var Lz = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Lz.insert = "head"; Lz.singleton = true; var Nz = Sl()(Bz.Z, Lz); const zz = Bz.Z.locals || {}; class Pz extends wl { static get pluginName() { return "ImageUploadProgress" } constructor(t) { super(t); this.uploadStatusChange = (t, e, n) => { const i = this.editor; const o = e.item; const r = o.getAttribute("uploadId"); if (!n.consumable.consume(e.item, t.name)) { return } const s = i.plugins.get("ImageUtils"); const a = i.plugins.get(lz); const c = r ? e.attributeNewValue : null; const l = this.placeholder; const d = i.editing.mapper.toViewElement(o); const u = n.writer; if (c == "reading") { Oz(d, u); Vz(s, l, d, u); return } if (c == "uploading") { const t = a.loaders.get(r); Oz(d, u); if (!t) { Vz(s, l, d, u) } else { jz(d, u); Fz(d, u, t, i.editing.view); Kz(s, d, u, t) } return } if (c == "complete" && a.loaders.get(r)) { Uz(d, u, i.editing.view) } Hz(d, u); jz(d, u); Rz(d, u) }; this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" } init() { const t = this.editor; if (t.plugins.has("ImageBlockEditing")) { t.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", this.uploadStatusChange) } if (t.plugins.has("ImageInlineEditing")) { t.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", this.uploadStatusChange) } } } function Oz(t, e) { if (!t.hasClass("ck-appear")) { e.addClass("ck-appear", t) } } function Rz(t, e) { e.removeClass("ck-appear", t) } function Vz(t, e, n, i) { if (!n.hasClass("ck-image-upload-placeholder")) { i.addClass("ck-image-upload-placeholder", n) } const o = t.findViewImgElement(n); if (o.getAttribute("src") !== e) { i.setAttribute("src", e, o) } if (!Gz(n, "placeholder")) { i.insert(i.createPositionAfter(o), qz(i)) } } function jz(t, e) { if (t.hasClass("ck-image-upload-placeholder")) { e.removeClass("ck-image-upload-placeholder", t) } $z(t, e, "placeholder") } function Fz(t, e, n, i) { const o = Wz(e); e.insert(e.createPositionAt(t, "end"), o); n.on("change:uploadedPercent", ((t, e, n) => { i.change((t => { t.setStyle("width", n + "%", o) })) })) } function Hz(t, e) { $z(t, e, "progressBar") } function Uz(t, e, n) { const i = e.createUIElement("div", { class: "ck-image-upload-complete-icon" }); e.insert(e.createPositionAt(t, "end"), i); setTimeout((() => { n.change((t => t.remove(t.createRangeOn(i)))) }), 3e3) } function Wz(t) { const e = t.createUIElement("div", { class: "ck-progress-bar" }); t.setCustomProperty("progressBar", true, e); return e } function qz(t) { const e = t.createUIElement("div", { class: "ck-upload-placeholder-loader" }); t.setCustomProperty("placeholder", true, e); return e } function Gz(t, e) { for (const n of t.getChildren()) { if (n.getCustomProperty(e)) { return n } } } function $z(t, e, n) { const i = Gz(t, n); if (i) { e.remove(e.createRangeOn(i)) } } function Kz(t, e, n, i) { if (i.data) { const o = t.findViewImgElement(e); n.setAttribute("src", i.data, o) } } class Yz extends _l { refresh() { const t = this.editor; const e = t.plugins.get("ImageUtils"); const n = t.model.document.selection.getSelectedElement(); this.isEnabled = e.isImageAllowed() || e.isImage(n) } execute(t) { const e = $c(t.file); const n = this.editor.model.document.selection; const i = this.editor.plugins.get("ImageUtils"); const o = Object.fromEntries(n.getAttributes()); e.forEach(((t, e) => { const r = n.getSelectedElement(); if (e && r && i.isImage(r)) { const e = this.editor.model.createPositionAfter(r); this._uploadImage(t, o, e) } else { this._uploadImage(t, o) } })) } _uploadImage(t, e, n) { const i = this.editor; const o = i.plugins.get(lz); const r = o.createLoader(t); const s = i.plugins.get("ImageUtils"); if (!r) { return } s.insertImage({ ...e, uploadId: r.id }, n) } } class Qz extends wl { static get requires() { return [lz, jy, aE, oT] } static get pluginName() { return "ImageUploadEditing" } constructor(t) { super(t); t.config.define("image", { upload: { types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"] } }); this._uploadImageElements = new Map } init() { const t = this.editor; const e = t.model.document; const n = t.conversion; const i = t.plugins.get(lz); const o = t.plugins.get("ImageUtils"); const r = t.plugins.get("ClipboardPipeline"); const s = bz(t.config.get("image.upload.types")); const a = new Yz(t); t.commands.add("uploadImage", a); t.commands.add("imageUpload", a); n.for("upcast").attributeToAttribute({ view: { name: "img", key: "uploadId" }, model: "uploadId" }); this.listenTo(t.editing.view.document, "clipboardInput", ((e, n) => { if (Zz(n.dataTransfer)) { return } const i = Array.from(n.dataTransfer.files).filter((t => { if (!t) { return false } return s.test(t.type) })); if (!i.length) { return } e.stop(); t.model.change((e => { if (n.targetRanges) { e.setSelection(n.targetRanges.map((e => t.editing.mapper.toModelRange(e)))) } t.model.enqueueChange((() => { t.execute("uploadImage", { file: i }) })) })) })); this.listenTo(r, "inputTransformation", ((e, n) => { const r = Array.from(t.editing.view.createRangeIn(n.content)).map((t => t.item)).filter((t => wz(o, t) && !t.getAttribute("uploadProcessed"))).map((t => ({ promise: kz(t), imageElement: t }))); if (!r.length) { return } const s = new Uw(t.editing.view.document); for (const t of r) { s.setAttribute("uploadProcessed", true, t.imageElement); const e = i.createLoader(t.promise); if (e) { s.setAttribute("src", "", t.imageElement); s.setAttribute("uploadId", e.id, t.imageElement) } } })); t.editing.view.document.on("dragover", ((t, e) => { e.preventDefault() })); e.on("change", (() => { const n = e.differ.getChanges({ includeChangesInGraveyard: true }).reverse(); const o = new Set; for (const e of n) { if (e.type == "insert" && e.name != "$text") { const n = e.position.nodeAfter; const r = e.position.root.rootName == "$graveyard"; for (const e of Jz(t, n)) { const t = e.getAttribute("uploadId"); if (!t) { continue } const n = i.loaders.get(t); if (!n) { continue } if (r) { if (!o.has(t)) { n.abort() } } else { o.add(t); this._uploadImageElements.set(t, e); if (n.status == "idle") { this._readAndUpload(n) } } } } } })); this.on("uploadComplete", ((t, { imageElement: e, data: n }) => { const i = n.urls ? n.urls : n; this.editor.model.change((t => { t.setAttribute("src", i.default, e); this._parseAndSetSrcsetAttributeOnImage(i, e, t) })) }), { priority: "low" }) } afterInit() { const t = this.editor.model.schema; if (this.editor.plugins.has("ImageBlockEditing")) { t.extend("imageBlock", { allowAttributes: ["uploadId", "uploadStatus"] }) } if (this.editor.plugins.has("ImageInlineEditing")) { t.extend("imageInline", { allowAttributes: ["uploadId", "uploadStatus"] }) } } _readAndUpload(t) { const e = this.editor; const n = e.model; const i = e.locale.t; const o = e.plugins.get(lz); const s = e.plugins.get(jy); const a = e.plugins.get("ImageUtils"); const c = this._uploadImageElements; n.enqueueChange({ isUndoable: false }, (e => { e.setAttribute("uploadStatus", "reading", c.get(t.id)) })); return t.read().then((() => { const i = t.upload(); const o = c.get(t.id); if (r.isSafari) { const t = e.editing.mapper.toViewElement(o); const n = a.findViewImgElement(t); e.editing.view.once("render", (() => { if (!n.parent) { return } const t = e.editing.view.domConverter.mapViewToDom(n.parent); if (!t) { return } const i = t.style.display; t.style.display = "none"; t._ckHack = t.offsetHeight; t.style.display = i })) } n.enqueueChange({ isUndoable: false }, (t => { t.setAttribute("uploadStatus", "uploading", o) })); return i })).then((e => { n.enqueueChange({ isUndoable: false }, (n => { const i = c.get(t.id); n.setAttribute("uploadStatus", "complete", i); this.fire("uploadComplete", { data: e, imageElement: i }) })); l() })).catch((e => { if (t.status !== "error" && t.status !== "aborted") { throw e } if (t.status == "error" && e) { s.showWarning(e, { title: i("Upload failed"), namespace: "upload" }) } n.enqueueChange({ isUndoable: false }, (e => { e.remove(c.get(t.id)) })); l() })); function l() { n.enqueueChange({ isUndoable: false }, (e => { const n = c.get(t.id); e.removeAttribute("uploadId", n); e.removeAttribute("uploadStatus", n); c.delete(t.id) })); o.destroyLoader(t) } } _parseAndSetSrcsetAttributeOnImage(t, e, n) { let i = 0; const o = Object.keys(t).filter((t => { const e = parseInt(t, 10); if (!isNaN(e)) { i = Math.max(i, e); return true } })).map((e => `${t[e]} ${e}w`)).join(", "); if (o != "") { n.setAttribute("srcset", { data: o, width: i }, e) } } } function Zz(t) { return Array.from(t.types).includes("text/html") && t.getData("text/html") !== "" } function Jz(t, e) { const n = t.plugins.get("ImageUtils"); return Array.from(t.model.createRangeOn(e)).filter((t => n.isImage(t.item))).map((t => t.item)) } class Xz extends wl { static get pluginName() { return "ImageUpload" } static get requires() { return [Qz, vz, Pz] } } class tP extends wl { static get pluginName() { return "IndentEditing" } init() { const t = this.editor; t.commands.add("indent", new vl(t)); t.commands.add("outdent", new vl(t)) } } const eP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>'; const nP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>'; class iP extends wl { static get pluginName() { return "IndentUI" } init() { const t = this.editor; const e = t.locale; const n = t.t; const i = e.uiLanguageDirection == "ltr" ? eP : nP; const o = e.uiLanguageDirection == "ltr" ? nP : eP; this._defineButton("indent", n("Increase indent"), i); this._defineButton("outdent", n("Decrease indent"), o) } _defineButton(t, e, n) { const i = this.editor; i.ui.componentFactory.add(t, (o => { const r = i.commands.get(t); const s = new wC(o); s.set({ label: e, icon: n, tooltip: true }); s.bind("isEnabled").to(r, "isEnabled"); this.listenTo(s, "execute", (() => { i.execute(t); i.editing.view.focus() })); return s })) } } class oP extends wl { static get pluginName() { return "Indent" } static get requires() { return [tP, iP] } } class rP extends _l { constructor(t, e) { super(t); this._indentBehavior = e } refresh() { const t = this.editor; const e = t.model; const n = ol(e.document.selection.getSelectedBlocks()); if (!n || !e.schema.checkAttribute(n, "blockIndent")) { this.isEnabled = false; return } this.isEnabled = this._indentBehavior.checkEnabled(n.getAttribute("blockIndent")) } execute() { const t = this.editor.model; const e = sP(t); t.change((t => { for (const n of e) { const e = n.getAttribute("blockIndent"); const i = this._indentBehavior.getNextIndent(e); if (i) { t.setAttribute("blockIndent", i, n) } else { t.removeAttribute("blockIndent", n) } } })) } } function sP(t) { const e = t.document.selection; const n = t.schema; const i = Array.from(e.getSelectedBlocks()); return i.filter((t => n.checkAttribute(t, "blockIndent"))) } class aP { constructor(t) { this.isForward = t.direction === "forward"; this.offset = t.offset; this.unit = t.unit } checkEnabled(t) { const e = parseFloat(t || "0"); return this.isForward || e > 0 } getNextIndent(t) { const e = parseFloat(t || "0"); const n = !t || t.endsWith(this.unit); if (!n) { return this.isForward ? this.offset + this.unit : undefined } const i = this.isForward ? this.offset : -this.offset; const o = e + i; return o > 0 ? o + this.unit : undefined } } class cP { constructor(t) { this.isForward = t.direction === "forward"; this.classes = t.classes } checkEnabled(t) { const e = this.classes.indexOf(t); if (this.isForward) { return e < this.classes.length - 1 } else { return e >= 0 } } getNextIndent(t) { const e = this.classes.indexOf(t); const n = this.isForward ? 1 : -1; return this.classes[e + n] } } const lP = ["paragraph", "heading1", "heading2", "heading3", "heading4", "heading5", "heading6"]; class dP extends wl { constructor(t) { super(t); t.config.define("indentBlock", { offset: 40, unit: "px" }) } static get pluginName() { return "IndentBlock" } init() { const t = this.editor; const e = t.config.get("indentBlock"); if (e.classes && e.classes.length) { this._setupConversionUsingClasses(e.classes); t.commands.add("indentBlock", new rP(t, new cP({ direction: "forward", classes: e.classes }))); t.commands.add("outdentBlock", new rP(t, new cP({ direction: "backward", classes: e.classes }))) } else { t.data.addStyleProcessorRules(BA); this._setupConversionUsingOffset(); t.commands.add("indentBlock", new rP(t, new aP({ direction: "forward", offset: e.offset, unit: e.unit }))); t.commands.add("outdentBlock", new rP(t, new aP({ direction: "backward", offset: e.offset, unit: e.unit }))) } } afterInit() { const t = this.editor; const e = t.model.schema; const n = t.commands.get("indent"); const i = t.commands.get("outdent"); const o = t.config.get("heading.options"); const r = o && o.map((t => t.model)); const s = r || lP; s.forEach((t => { if (e.isRegistered(t)) { e.extend(t, { allowAttributes: "blockIndent" }) } })); e.setAttributeProperties("blockIndent", { isFormatting: true }); n.registerChildCommand(t.commands.get("indentBlock")); i.registerChildCommand(t.commands.get("outdentBlock")) } _setupConversionUsingOffset() { const t = this.editor.conversion; const e = this.editor.locale; const n = e.contentLanguageDirection === "rtl" ? "margin-right" : "margin-left"; t.for("upcast").attributeToAttribute({ view: { styles: { [n]: /[\s\S]+/ } }, model: { key: "blockIndent", value: t => t.getStyle(n) } }); t.for("downcast").attributeToAttribute({ model: "blockIndent", view: t => ({ key: "style", value: { [n]: t } }) }) } _setupConversionUsingClasses(t) { const e = { model: { key: "blockIndent", values: [] }, view: {} }; for (const n of t) { e.model.values.push(n); e.view[n] = { key: "class", value: [n] } } this.editor.conversion.attributeToAttribute(e) } } const uP = "italic"; class hP extends wl { static get pluginName() { return "ItalicEditing" } init() { const t = this.editor; t.model.schema.extend("$text", { allowAttributes: uP }); t.model.schema.setAttributeProperties(uP, { isFormatting: true, copyOnEnter: true }); t.conversion.attributeToElement({ model: uP, view: "i", upcastAlso: ["em", { styles: { "font-style": "italic" } }] }); t.commands.add(uP, new FI(t, uP)); t.keystrokes.set("CTRL+I", uP) } } const gP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>'; const mP = "italic"; class fP extends wl { static get pluginName() { return "ItalicUI" } init() { const t = this.editor; const e = t.t; t.ui.componentFactory.add(mP, (n => { const i = t.commands.get(mP); const o = new wC(n); o.set({ label: e("Italic"), icon: gP, keystroke: "CTRL+I", tooltip: true, isToggleable: true }); o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"); this.listenTo(o, "execute", (() => { t.execute(mP); t.editing.view.focus() })); return o })) } } class pP extends wl { static get requires() { return [hP, fP] } static get pluginName() { return "Italic" } } class bP { constructor() { this._definitions = new Set } get length() { return this._definitions.size } add(t) { if (Array.isArray(t)) { t.forEach((t => this._definitions.add(t))) } else { this._definitions.add(t) } } getDispatcher() { return t => { t.on("attribute:linkHref", ((t, e, n) => { if (!n.consumable.test(e.item, "attribute:linkHref")) { return } if (!(e.item.is("selection") || n.schema.isInline(e.item))) { return } const i = n.writer; const o = i.document.selection; for (const t of this._definitions) { const r = i.createAttributeElement("a", t.attributes, { priority: 5 }); if (t.classes) { i.addClass(t.classes, r) } for (const e in t.styles) { i.setStyle(e, t.styles[e], r) } i.setCustomProperty("link", true, r); if (t.callback(e.attributeNewValue)) { if (e.item.is("selection")) { i.wrap(o.getFirstRange(), r) } else { i.wrap(n.mapper.toViewRange(e.range), r) } } else { i.unwrap(n.mapper.toViewRange(e.range), r) } } }), { priority: "high" }) } } getDispatcherForLinkedImage() { return t => { t.on("attribute:linkHref:imageBlock", ((t, e, { writer: n, mapper: i }) => { const o = i.toViewElement(e.item); const r = Array.from(o.getChildren()).find((t => t.is("element", "a"))); for (const t of this._definitions) { const i = cl(t.attributes); if (t.callback(e.attributeNewValue)) { for (const [t, e] of i) { if (t === "class") { n.addClass(e, r) } else { n.setAttribute(t, e, r) } } if (t.classes) { n.addClass(t.classes, r) } for (const e in t.styles) { n.setStyle(e, t.styles[e], r) } } else { for (const [t, e] of i) { if (t === "class") { n.removeClass(e, r) } else { n.removeAttribute(t, r) } } if (t.classes) { n.removeClass(t.classes, r) } for (const e in t.styles) { n.removeStyle(e, r) } } } })) } } } class kP extends _l { constructor() { super(...arguments); this.manualDecorators = new il; this.automaticDecorators = new bP } restoreManualDecoratorStates() { for (const t of this.manualDecorators) { t.value = this._getDecoratorStateFromModel(t.id) } } refresh() { const t = this.editor.model; const e = t.document.selection; const n = e.getSelectedElement() || ol(e.getSelectedBlocks()); if (pI(n, t.schema)) { this.value = n.getAttribute("linkHref"); this.isEnabled = t.schema.checkAttribute(n, "linkHref") } else { this.value = e.getAttribute("linkHref"); this.isEnabled = t.schema.checkAttributeInSelection(e, "linkHref") } for (const t of this.manualDecorators) { t.value = this._getDecoratorStateFromModel(t.id) } } execute(t, e = {}) { const n = this.editor.model; const i = n.document.selection; const o = []; const r = []; for (const t in e) { if (e[t]) { o.push(t) } else { r.push(t) } } n.change((e => { if (i.isCollapsed) { const s = i.getFirstPosition(); if (i.hasAttribute("linkHref")) { const a = wP(i); let c = YE(s, "linkHref", i.getAttribute("linkHref"), n); if (i.getAttribute("linkHref") === a) { c = this._updateLinkContent(n, e, c, t) } e.setAttribute("linkHref", t, c); o.forEach((t => { e.setAttribute(t, true, c) })); r.forEach((t => { e.removeAttribute(t, c) })); e.setSelection(e.createPositionAfter(c.end.nodeBefore)) } else if (t !== "") { const r = cl(i.getAttributes()); r.set("linkHref", t); o.forEach((t => { r.set(t, true) })); const { end: a } = n.insertContent(e.createText(t, r), s); e.setSelection(a) } ["linkHref", ...o, ...r].forEach((t => { e.removeSelectionAttribute(t) })) } else { const s = n.schema.getValidRanges(i.getRanges(), "linkHref"); const a = []; for (const t of i.getSelectedBlocks()) { if (n.schema.checkAttribute(t, "linkHref")) { a.push(e.createRangeOn(t)) } } const c = a.slice(); for (const t of s) { if (this._isRangeToUpdate(t, a)) { c.push(t) } } for (const s of c) { let a = s; if (c.length === 1) { const o = wP(i); if (i.getAttribute("linkHref") === o) { a = this._updateLinkContent(n, e, s, t); e.setSelection(e.createSelection(a)) } } e.setAttribute("linkHref", t, a); o.forEach((t => { e.setAttribute(t, true, a) })); r.forEach((t => { e.removeAttribute(t, a) })) } } })) } _getDecoratorStateFromModel(t) { const e = this.editor.model; const n = e.document.selection; const i = n.getSelectedElement(); if (pI(i, e.schema)) { return i.getAttribute(t) } return n.getAttribute(t) } _isRangeToUpdate(t, e) { for (const n of e) { if (n.containsRange(t)) { return false } } return true } _updateLinkContent(t, e, n, i) { const o = e.createText(i, { linkHref: i }); return t.insertContent(o, n) } } function wP(t) { if (t.isCollapsed) { const e = t.getFirstPosition(); return e.textNode && e.textNode.data } else { const e = Array.from(t.getFirstRange().getItems()); if (e.length > 1) { return null } const n = e[0]; if (n.is("$text") || n.is("$textProxy")) { return n.data } return null } } class AP extends _l { refresh() { const t = this.editor.model; const e = t.document.selection; const n = e.getSelectedElement(); if (pI(n, t.schema)) { this.isEnabled = t.schema.checkAttribute(n, "linkHref") } else { this.isEnabled = t.schema.checkAttributeInSelection(e, "linkHref") } } execute() { const t = this.editor; const e = this.editor.model; const n = e.document.selection; const i = t.commands.get("link"); e.change((t => { const o = n.isCollapsed ? [YE(n.getFirstPosition(), "linkHref", n.getAttribute("linkHref"), e)] : e.schema.getValidRanges(n.getRanges(), "linkHref"); for (const e of o) { t.removeAttribute("linkHref", e); if (i) { for (const n of i.manualDecorators) { t.removeAttribute(n.id, e) } } } })) } } class _P extends (lt()) { constructor({ id: t, label: e, attributes: n, classes: i, styles: o, defaultValue: r }) { super(); this.id = t; this.set("value", undefined); this.defaultValue = r; this.label = e; this.attributes = n; this.classes = i; this.styles = o } _createPattern() { return { attributes: this.attributes, classes: this.classes, styles: this.styles } } } var CP = n(399); var vP = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; vP.insert = "head"; vP.singleton = true; var yP = Sl()(CP.Z, vP); const xP = CP.Z.locals || {}; const EP = "ck-link_selected"; const DP = "automatic"; const SP = "manual"; const TP = /^(https?:)?\/\//; class IP extends wl { static get pluginName() { return "LinkEditing" } static get requires() { return [TE, hE, aE] } constructor(t) { super(t); t.config.define("link", { addTargetToExternalLinks: false }) } init() { const t = this.editor; t.model.schema.extend("$text", { allowAttributes: "linkHref" }); t.conversion.for("dataDowncast").attributeToElement({ model: "linkHref", view: uI }); t.conversion.for("editingDowncast").attributeToElement({ model: "linkHref", view: (t, e) => uI(hI(t), e) }); t.conversion.for("upcast").elementToAttribute({ view: { name: "a", attributes: { href: true } }, model: { key: "linkHref", value: t => t.getAttribute("href") } }); t.commands.add("link", new kP(t)); t.commands.add("unlink", new AP(t)); const e = mI(t.t, fI(t.config.get("link.decorators"))); this._enableAutomaticDecorators(e.filter((t => t.mode === DP))); this._enableManualDecorators(e.filter((t => t.mode === SP))); const n = t.plugins.get(TE); n.registerAttribute("linkHref"); ZE(t, "linkHref", "a", EP); this._enableLinkOpen(); this._enableInsertContentSelectionAttributesFixer(); this._enableClickingAfterLink(); this._enableTypingOverLink(); this._handleDeleteContentAfterLink(); this._enableClipboardIntegration() } _enableAutomaticDecorators(t) { const e = this.editor; const n = e.commands.get("link"); const i = n.automaticDecorators; if (e.config.get("link.addTargetToExternalLinks")) { i.add({ id: "linkIsExternal", mode: DP, callback: t => !!t && TP.test(t), attributes: { target: "_blank", rel: "noopener noreferrer" } }) } i.add(t); if (i.length) { e.conversion.for("downcast").add(i.getDispatcher()) } } _enableManualDecorators(t) { if (!t.length) { return } const e = this.editor; const n = e.commands.get("link"); const i = n.manualDecorators; t.forEach((t => { e.model.schema.extend("$text", { allowAttributes: t.id }); const n = new _P(t); i.add(n); e.conversion.for("downcast").attributeToElement({ model: n.id, view: (t, { writer: e, schema: i }, { item: o }) => { if (!(o.is("selection") || i.isInline(o))) { return } if (t) { const t = e.createAttributeElement("a", n.attributes, { priority: 5 }); if (n.classes) { e.addClass(n.classes, t) } for (const i in n.styles) { e.setStyle(i, n.styles[i], t) } e.setCustomProperty("link", true, t); return t } } }); e.conversion.for("upcast").elementToAttribute({ view: { name: "a", ...n._createPattern() }, model: { key: n.id } }) })) } _enableLinkOpen() { const t = this.editor; const e = t.editing.view; const n = e.document; this.listenTo(n, "click", ((t, e) => { const n = r.isMac ? e.domEvent.metaKey : e.domEvent.ctrlKey; if (!n) { return } let i = e.domTarget; if (i.tagName.toLowerCase() != "a") { i = i.closest("a") } if (!i) { return } const o = i.getAttribute("href"); if (!o) { return } t.stop(); e.preventDefault(); AI(o) }), { context: "$capture" }); this.listenTo(n, "keydown", ((e, n) => { const i = t.commands.get("link"); const o = i.value; const r = !!o && n.keyCode === Pc.enter && n.altKey; if (!r) { return } e.stop(); AI(o) })) } _enableInsertContentSelectionAttributesFixer() { const t = this.editor; const e = t.model; const n = e.document.selection; this.listenTo(e, "insertContent", (() => { const t = n.anchor.nodeBefore; const i = n.anchor.nodeAfter; if (!n.hasAttribute("linkHref")) { return } if (!t) { return } if (!t.hasAttribute("linkHref")) { return } if (i && i.hasAttribute("linkHref")) { return } e.change((t => { MP(t, NP(e.schema)) })) }), { priority: "low" }) } _enableClickingAfterLink() { const t = this.editor; const e = t.model; t.editing.view.addObserver(Hw); let n = false; this.listenTo(t.editing.view.document, "mousedown", (() => { n = true })); this.listenTo(t.editing.view.document, "selectionChange", (() => { if (!n) { return } n = false; const t = e.document.selection; if (!t.isCollapsed) { return } if (!t.hasAttribute("linkHref")) { return } const i = t.getFirstPosition(); const o = YE(i, "linkHref", t.getAttribute("linkHref"), e); if (i.isTouching(o.start) || i.isTouching(o.end)) { e.change((t => { MP(t, NP(e.schema)) })) } })) } _enableTypingOverLink() { const t = this.editor; const e = t.editing.view; let n = null; let i = false; this.listenTo(e.document, "delete", (() => { i = true }), { priority: "high" }); this.listenTo(t.model, "deleteContent", (() => { const e = t.model.document.selection; if (e.isCollapsed) { return } if (i) { i = false; return } if (!LP(t)) { return } if (BP(t.model)) { n = e.getAttributes() } }), { priority: "high" }); this.listenTo(t.model, "insertContent", ((e, [o]) => { i = false; if (!LP(t)) { return } if (!n) { return } t.model.change((t => { for (const [e, i] of n) { t.setAttribute(e, i, o) } })); n = null }), { priority: "high" }) } _handleDeleteContentAfterLink() { const t = this.editor; const e = t.model; const n = e.document.selection; const i = t.editing.view; let o = false; let r = false; this.listenTo(i.document, "delete", ((t, e) => { r = e.direction === "backward" }), { priority: "high" }); this.listenTo(e, "deleteContent", (() => { o = false; const t = n.getFirstPosition(); const i = n.getAttribute("linkHref"); if (!i) { return } const r = YE(t, "linkHref", i, e); o = r.containsPosition(t) || r.end.isEqual(t) }), { priority: "high" }); this.listenTo(e, "deleteContent", (() => { if (!r) { return } r = false; if (o) { return } t.model.enqueueChange((t => { MP(t, NP(e.schema)) })) }), { priority: "low" }) } _enableClipboardIntegration() { const t = this.editor; const e = t.model; const n = this.editor.config.get("link.defaultProtocol"); if (!n) { return } this.listenTo(t.plugins.get("ClipboardPipeline"), "contentInsertion", ((t, i) => { e.change((t => { const e = t.createRangeIn(i.content); for (const i of e.getItems()) { if (i.hasAttribute("linkHref")) { const e = kI(i.getAttribute("linkHref"), n); t.setAttribute("linkHref", e, i) } } })) })) } } function MP(t, e) { t.removeSelectionAttribute("linkHref"); for (const n of e) { t.removeSelectionAttribute(n) } } function BP(t) { const e = t.document.selection; const n = e.getFirstPosition(); const i = e.getLastPosition(); const o = n.nodeAfter; if (!o) { return false } if (!o.is("$text")) { return false } if (!o.hasAttribute("linkHref")) { return false } const r = i.textNode || i.nodeBefore; if (o === r) { return true } const s = YE(n, "linkHref", o.getAttribute("linkHref"), t); return s.containsRange(t.createRange(n, i), true) } function LP(t) { const e = t.model.change((t => t.batch)); return e.isTyping } function NP(t) { const e = t.getDefinition("$text").allowAttributes; return e.filter((t => t.startsWith("link"))) } var zP = n(4827); var PP = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; PP.insert = "head"; PP.singleton = true; var OP = Sl()(zP.Z, PP); const RP = zP.Z.locals || {}; class VP extends N_ { constructor(t, e) { super(t); this.focusTracker = new rl; this.keystrokes = new sl; this._focusables = new S_; const n = t.t; this.urlInputView = this._createUrlInput(); this.saveButtonView = this._createButton(n("Save"), v_.check, "ck-button-save"); this.saveButtonView.type = "submit"; this.cancelButtonView = this._createButton(n("Cancel"), v_.cancel, "ck-button-cancel", "cancel"); this._manualDecoratorSwitches = this._createManualDecoratorSwitches(e); this.children = this._createFormChildren(e.manualDecorators); this._focusCycler = new QC({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }); const i = ["ck", "ck-link-form", "ck-responsive-form"]; if (e.manualDecorators.length) { i.push("ck-link-form_layout-vertical", "ck-vertical-form") } this.setTemplate({ tag: "form", attributes: { class: i, tabindex: "-1" }, children: this.children }) } getDecoratorSwitchesState() { return Array.from(this._manualDecoratorSwitches).reduce(((t, e) => { t[e.name] = e.isOn; return t }), {}) } render() { super.render(); E_({ view: this }); const t = [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView]; t.forEach((t => { this._focusables.add(t); this.focusTracker.add(t.element) })); this.keystrokes.listenTo(this.element) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } focus() { this._focusCycler.focusFirst() } _createUrlInput() { const t = this.locale.t; const e = new Py(this.locale, Oy); e.label = t("Link URL"); return e } _createButton(t, e, n, i) { const o = new wC(this.locale); o.set({ label: t, icon: e, tooltip: true }); o.extendTemplate({ attributes: { class: n } }); if (i) { o.delegate("execute").to(this, i) } return o } _createManualDecoratorSwitches(t) { const e = this.createCollection(); for (const n of t.manualDecorators) { const i = new yC(this.locale); i.set({ name: n.id, label: n.label, withText: true }); i.bind("isOn").toMany([n, t], "value", ((t, e) => e === undefined && t === undefined ? !!n.defaultValue : !!t)); i.on("execute", (() => { n.set("value", !i.isOn) })); e.add(i) } return e } _createFormChildren(t) { const e = this.createCollection(); e.add(this.urlInputView); if (t.length) { const t = new N_; t.setTemplate({ tag: "ul", children: this._manualDecoratorSwitches.map((t => ({ tag: "li", children: [t], attributes: { class: ["ck", "ck-list__item"] } }))), attributes: { class: ["ck", "ck-reset", "ck-list"] } }); e.add(t) } e.add(this.saveButtonView); e.add(this.cancelButtonView); return e } } var jP = n(9465); var FP = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; FP.insert = "head"; FP.singleton = true; var HP = Sl()(jP.Z, FP); const UP = jP.Z.locals || {}; const WP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>'; class qP extends N_ { constructor(t) { super(t); this.focusTracker = new rl; this.keystrokes = new sl; this._focusables = new S_; const e = t.t; this.previewButtonView = this._createPreviewButton(); this.unlinkButtonView = this._createButton(e("Unlink"), WP, "unlink"); this.editButtonView = this._createButton(e("Edit link"), v_.pencil, "edit"); this.set("href", undefined); this._focusCycler = new QC({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }); this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-link-actions", "ck-responsive-form"], tabindex: "-1" }, children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView] }) } render() { super.render(); const t = [this.previewButtonView, this.editButtonView, this.unlinkButtonView]; t.forEach((t => { this._focusables.add(t); this.focusTracker.add(t.element) })); this.keystrokes.listenTo(this.element) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } focus() { this._focusCycler.focusFirst() } _createButton(t, e, n) { const i = new wC(this.locale); i.set({ label: t, icon: e, tooltip: true }); i.delegate("execute").to(this, n); return i } _createPreviewButton() { const t = new wC(this.locale); const e = this.bindTemplate; const n = this.t; t.set({ withText: true, tooltip: n("Open link in new tab") }); t.extendTemplate({ attributes: { class: ["ck", "ck-link-actions__preview"], href: e.to("href", (t => t && hI(t))), target: "_blank", rel: "noopener noreferrer" } }); t.bind("label").to(this, "href", (t => t || n("This link has no URL"))); t.bind("isEnabled").to(this, "href", (t => !!t)); t.template.tag = "a"; t.template.eventListeners = {}; return t } } const GP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>'; const $P = "link-ui"; class KP extends wl { constructor() { super(...arguments); this.actionsView = null; this.formView = null } static get requires() { return [Xy] } static get pluginName() { return "LinkUI" } init() { const t = this.editor; t.editing.view.addObserver(Fw); this._balloon = t.plugins.get(Xy); this._createToolbarLinkButton(); this._enableBalloonActivators(); t.conversion.for("editingDowncast").markerToHighlight({ model: $P, view: { classes: ["ck-fake-link-selection"] } }); t.conversion.for("editingDowncast").markerToElement({ model: $P, view: { name: "span", classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"] } }) } destroy() { super.destroy(); if (this.formView) { this.formView.destroy() } if (this.actionsView) { this.actionsView.destroy() } } _createViews() { this.actionsView = this._createActionsView(); this.formView = this._createFormView(); this._enableUserBalloonInteractions() } _createActionsView() { const t = this.editor; const e = new qP(t.locale); const n = t.commands.get("link"); const i = t.commands.get("unlink"); e.bind("href").to(n, "value"); e.editButtonView.bind("isEnabled").to(n); e.unlinkButtonView.bind("isEnabled").to(i); this.listenTo(e, "edit", (() => { this._addFormView() })); this.listenTo(e, "unlink", (() => { t.execute("unlink"); this._hideUI() })); e.keystrokes.set("Esc", ((t, e) => { this._hideUI(); e() })); e.keystrokes.set(lI, ((t, e) => { this._addFormView(); e() })); return e } _createFormView() { const t = this.editor; const e = t.commands.get("link"); const n = t.config.get("link.defaultProtocol"); const i = new (x_(VP))(t.locale, e); i.urlInputView.fieldView.bind("value").to(e, "value"); i.urlInputView.bind("isEnabled").to(e, "isEnabled"); i.saveButtonView.bind("isEnabled").to(e); this.listenTo(i, "submit", (() => { const { value: e } = i.urlInputView.fieldView.element; const o = kI(e, n); t.execute("link", o, i.getDecoratorSwitchesState()); this._closeFormView() })); this.listenTo(i, "cancel", (() => { this._closeFormView() })); i.keystrokes.set("Esc", ((t, e) => { this._closeFormView(); e() })); return i } _createToolbarLinkButton() { const t = this.editor; const e = t.commands.get("link"); const n = t.t; t.ui.componentFactory.add("link", (t => { const i = new wC(t); i.isEnabled = true; i.label = n("Link"); i.icon = GP; i.keystroke = lI; i.tooltip = true; i.isToggleable = true; i.bind("isEnabled").to(e, "isEnabled"); i.bind("isOn").to(e, "value", (t => !!t)); this.listenTo(i, "execute", (() => this._showUI(true))); return i })) } _enableBalloonActivators() { const t = this.editor; const e = t.editing.view.document; this.listenTo(e, "click", (() => { const t = this._getSelectedLinkElement(); if (t) { this._showUI() } })); t.keystrokes.set(lI, ((e, n) => { n(); if (t.commands.get("link").isEnabled) { this._showUI(true) } })) } _enableUserBalloonInteractions() { this.editor.keystrokes.set("Tab", ((t, e) => { if (this._areActionsVisible && !this.actionsView.focusTracker.isFocused) { this.actionsView.focus(); e() } }), { priority: "high" }); this.editor.keystrokes.set("Esc", ((t, e) => { if (this._isUIVisible) { this._hideUI(); e() } })); y_({ emitter: this.formView, activator: () => this._isUIInPanel, contextElements: () => [this._balloon.view.element], callback: () => this._hideUI() }) } _addActionsView() { if (!this.actionsView) { this._createViews() } if (this._areActionsInPanel) { return } this._balloon.add({ view: this.actionsView, position: this._getBalloonPositionData() }) } _addFormView() { if (!this.formView) { this._createViews() } if (this._isFormInPanel) { return } const t = this.editor; const e = t.commands.get("link"); this.formView.disableCssTransitions(); this._balloon.add({ view: this.formView, position: this._getBalloonPositionData() }); if (this._balloon.visibleView === this.formView) { this.formView.urlInputView.fieldView.select() } this.formView.enableCssTransitions(); this.formView.urlInputView.fieldView.element.value = e.value || "" } _closeFormView() { const t = this.editor.commands.get("link"); t.restoreManualDecoratorStates(); if (t.value !== undefined) { this._removeFormView() } else { this._hideUI() } } _removeFormView() { if (this._isFormInPanel) { this.formView.saveButtonView.focus(); this._balloon.remove(this.formView); this.editor.editing.view.focus(); this._hideFakeVisualSelection() } } _showUI(t = false) { if (!this.formView) { this._createViews() } if (!this._getSelectedLinkElement()) { this._showFakeVisualSelection(); this._addActionsView(); if (t) { this._balloon.showStack("main") } this._addFormView() } else { if (this._areActionsVisible) { this._addFormView() } else { this._addActionsView() } if (t) { this._balloon.showStack("main") } } this._startUpdatingUI() } _hideUI() { if (!this._isUIInPanel) { return } const t = this.editor; this.stopListening(t.ui, "update"); this.stopListening(this._balloon, "change:visibleView"); t.editing.view.focus(); this._removeFormView(); this._balloon.remove(this.actionsView); this._hideFakeVisualSelection() } _startUpdatingUI() { const t = this.editor; const e = t.editing.view.document; let n = this._getSelectedLinkElement(); let i = r(); const o = () => { const t = this._getSelectedLinkElement(); const e = r(); if (n && !t || !n && e !== i) { this._hideUI() } else if (this._isUIVisible) { this._balloon.updatePosition(this._getBalloonPositionData()) } n = t; i = e }; function r() { return e.selection.focus.getAncestors().reverse().find((t => t.is("element"))) } this.listenTo(t.ui, "update", o); this.listenTo(this._balloon, "change:visibleView", o) } get _isFormInPanel() { return !!this.formView && this._balloon.hasView(this.formView) } get _areActionsInPanel() { return !!this.actionsView && this._balloon.hasView(this.actionsView) } get _areActionsVisible() { return !!this.actionsView && this._balloon.visibleView === this.actionsView } get _isUIInPanel() { return this._isFormInPanel || this._areActionsInPanel } get _isUIVisible() { const t = this._balloon.visibleView; return !!this.formView && t == this.formView || this._areActionsVisible } _getBalloonPositionData() { const t = this.editor.editing.view; const e = this.editor.model; const n = t.document; let i; if (e.markers.has($P)) { const e = Array.from(this.editor.editing.mapper.markerNameToElements($P)); const n = t.createRange(t.createPositionBefore(e[0]), t.createPositionAfter(e[e.length - 1])); i = t.domConverter.viewRangeToDom(n) } else { i = () => { const e = this._getSelectedLinkElement(); return e ? t.domConverter.mapViewToDom(e) : t.domConverter.viewRangeToDom(n.selection.getFirstRange()) } } return { target: i } } _getSelectedLinkElement() { const t = this.editor.editing.view; const e = t.document.selection; const n = e.getSelectedElement(); if (e.isCollapsed || n && bD(n)) { return YP(e.getFirstPosition()) } else { const n = e.getFirstRange().getTrimmed(); const i = YP(n.start); const o = YP(n.end); if (!i || i != o) { return null } if (t.createRangeIn(i).getTrimmed().isEqual(n)) { return i } else { return null } } } _showFakeVisualSelection() { const t = this.editor.model; t.change((e => { const n = t.document.selection.getFirstRange(); if (t.markers.has($P)) { e.updateMarker($P, { range: n }) } else { if (n.start.isAtEnd) { const i = n.start.getLastMatchingPosition((({ item: e }) => !t.schema.isContent(e)), { boundaries: n }); e.addMarker($P, { usingOperation: false, affectsData: false, range: e.createRange(i, n.end) }) } else { e.addMarker($P, { usingOperation: false, affectsData: false, range: n }) } } })) } _hideFakeVisualSelection() { const t = this.editor.model; if (t.markers.has($P)) { t.change((t => { t.removeMarker($P) })) } } } function YP(t) { return t.getAncestors().find((t => dI(t))) || null } class QP extends wl { static get requires() { return [IP, KP, yI] } static get pluginName() { return "Link" } } class ZP extends wl { static get requires() { return ["ImageEditing", "ImageUtils", IP] } static get pluginName() { return "LinkImageEditing" } init() { const t = this.editor; const e = t.model.schema; if (t.plugins.has("ImageBlockEditing")) { e.extend("imageBlock", { allowAttributes: ["linkHref"] }) } t.conversion.for("upcast").add(JP(t)); t.conversion.for("downcast").add(XP(t)); this._enableAutomaticDecorators(); this._enableManualDecorators() } _enableAutomaticDecorators() { const t = this.editor; const e = t.commands.get("link"); const n = e.automaticDecorators; if (n.length) { t.conversion.for("downcast").add(n.getDispatcherForLinkedImage()) } } _enableManualDecorators() { const t = this.editor; const e = t.commands.get("link"); for (const n of e.manualDecorators) { if (t.plugins.has("ImageBlockEditing")) { t.model.schema.extend("imageBlock", { allowAttributes: n.id }) } if (t.plugins.has("ImageInlineEditing")) { t.model.schema.extend("imageInline", { allowAttributes: n.id }) } t.conversion.for("downcast").add(tO(n)); t.conversion.for("upcast").add(eO(t, n)) } } } function JP(t) { const e = t.plugins.has("ImageInlineEditing"); const n = t.plugins.get("ImageUtils"); return t => { t.on("element:a", ((t, i, o) => { const r = i.viewItem; const s = n.findViewImgElement(r); if (!s) { return } const a = s.findAncestor((t => n.isBlockImageView(t))); if (e && !a) { return } const c = { attributes: ["href"] }; if (!o.consumable.consume(r, c)) { return } const l = r.getAttribute("href"); if (!l) { return } let d = i.modelCursor.parent; if (!d.is("element", "imageBlock")) { const t = o.convertItem(s, i.modelCursor); i.modelRange = t.modelRange; i.modelCursor = t.modelCursor; d = i.modelCursor.nodeBefore } if (d && d.is("element", "imageBlock")) { o.writer.setAttribute("linkHref", l, d) } }), { priority: "high" }) } } function XP(t) { const e = t.plugins.get("ImageUtils"); return t => { t.on("attribute:linkHref:imageBlock", ((t, n, i) => { if (!i.consumable.consume(n.item, t.name)) { return } const o = i.mapper.toViewElement(n.item); const r = i.writer; const s = Array.from(o.getChildren()).find((t => t.is("element", "a"))); const a = e.findViewImgElement(o); const c = a.parent.is("element", "picture") ? a.parent : a; if (s) { if (n.attributeNewValue) { r.setAttribute("href", n.attributeNewValue, s) } else { r.move(r.createRangeOn(c), r.createPositionAt(o, 0)); r.remove(s) } } else { const t = r.createContainerElement("a", { href: n.attributeNewValue }); r.insert(r.createPositionAt(o, 0), t); r.move(r.createRangeOn(c), r.createPositionAt(t, 0)) } }), { priority: "high" }) } } function tO(t) { return e => { e.on(`attribute:${t.id}:imageBlock`, ((e, n, i) => { const o = i.mapper.toViewElement(n.item); const r = Array.from(o.getChildren()).find((t => t.is("element", "a"))); if (!r) { return } for (const [e, n] of cl(t.attributes)) { i.writer.setAttribute(e, n, r) } if (t.classes) { i.writer.addClass(t.classes, r) } for (const e in t.styles) { i.writer.setStyle(e, t.styles[e], r) } })) } } function eO(t, e) { const n = t.plugins.has("ImageInlineEditing"); const i = t.plugins.get("ImageUtils"); return t => { t.on("element:a", ((t, o, r) => { const s = o.viewItem; const a = i.findViewImgElement(s); if (!a) { return } const c = a.findAncestor((t => i.isBlockImageView(t))); if (n && !c) { return } const l = new Yl(e._createPattern()); const d = l.match(s); if (!d) { return } if (!r.consumable.consume(s, d.match)) { return } const u = o.modelCursor.nodeBefore || o.modelCursor.parent; r.writer.setAttribute(e.id, true, u) }), { priority: "high" }) } } class nO extends wl { static get requires() { return [IP, KP, "ImageBlockEditing"] } static get pluginName() { return "LinkImageUI" } init() { const t = this.editor; const e = t.editing.view.document; this.listenTo(e, "click", ((e, n) => { if (this._isSelectedLinkedImage(t.model.document.selection)) { n.preventDefault(); e.stop() } }), { priority: "high" }); this._createToolbarLinkImageButton() } _createToolbarLinkImageButton() { const t = this.editor; const e = t.t; t.ui.componentFactory.add("linkImage", (n => { const i = new wC(n); const o = t.plugins.get("LinkUI"); const r = t.commands.get("link"); i.set({ isEnabled: true, label: e("Link image"), icon: GP, keystroke: lI, tooltip: true, isToggleable: true }); i.bind("isEnabled").to(r, "isEnabled"); i.bind("isOn").to(r, "value", (t => !!t)); this.listenTo(i, "execute", (() => { if (this._isSelectedLinkedImage(t.model.document.selection)) { o._addActionsView() } else { o._showUI(true) } })); return i })) } _isSelectedLinkedImage(t) { const e = t.getSelectedElement(); const n = this.editor.plugins.get("ImageUtils"); return n.isImage(e) && e.hasAttribute("linkHref") } } var iO = n(3858); var oO = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; oO.insert = "head"; oO.singleton = true; var rO = Sl()(iO.Z, oO); const sO = iO.Z.locals || {}; class aO extends wl { static get requires() { return [ZP, nO] } static get pluginName() { return "LinkImage" } } class cO extends _l { constructor(t, e) { super(t); this.type = e } refresh() { this.value = this._getValue(); this.isEnabled = this._checkEnabled() } execute(t = {}) { const e = this.editor.model; const n = e.document; const i = Array.from(n.selection.getSelectedBlocks()).filter((t => dO(t, e.schema))); const o = t.forceValue !== undefined ? !t.forceValue : this.value; e.change((t => { if (o) { let e = i[i.length - 1].nextSibling; let n = Number.POSITIVE_INFINITY; let o = []; while (e && e.name == "listItem" && e.getAttribute("listIndent") !== 0) { const t = e.getAttribute("listIndent"); if (t < n) { n = t } const i = t - n; o.push({ element: e, listIndent: i }); e = e.nextSibling } o = o.reverse(); for (const e of o) { t.setAttribute("listIndent", e.listIndent, e.element) } } if (!o) { let t = Number.POSITIVE_INFINITY; for (const e of i) { if (e.is("element", "listItem") && e.getAttribute("listIndent") < t) { t = e.getAttribute("listIndent") } } t = t === 0 ? 1 : t; lO(i, true, t); lO(i, false, t) } for (const e of i.reverse()) { if (o && e.name == "listItem") { t.rename(e, "paragraph") } else if (!o && e.name != "listItem") { t.setAttributes({ listType: this.type, listIndent: 0 }, e); t.rename(e, "listItem") } else if (!o && e.name == "listItem" && e.getAttribute("listType") != this.type) { t.setAttribute("listType", this.type, e) } } this.fire("_executeCleanup", i) })) } _getValue() { const t = ol(this.editor.model.document.selection.getSelectedBlocks()); return !!t && t.is("element", "listItem") && t.getAttribute("listType") == this.type } _checkEnabled() { if (this.value) { return true } const t = this.editor.model.document.selection; const e = this.editor.model.schema; const n = ol(t.getSelectedBlocks()); if (!n) { return false } return dO(n, e) } } function lO(t, e, n) { const i = e ? t[0] : t[t.length - 1]; if (i.is("element", "listItem")) { let o = i[e ? "previousSibling" : "nextSibling"]; let r = i.getAttribute("listIndent"); while (o && o.is("element", "listItem") && o.getAttribute("listIndent") >= n) { if (r > o.getAttribute("listIndent")) { r = o.getAttribute("listIndent") } if (o.getAttribute("listIndent") == r) { t[e ? "unshift" : "push"](o) } o = o[e ? "previousSibling" : "nextSibling"] } } } function dO(t, e) { return e.checkChild(t.parent, "listItem") && !e.isObject(t) } class uO extends _l { constructor(t, e) { super(t); this._indentBy = e == "forward" ? 1 : -1 } refresh() { this.isEnabled = this._checkEnabled() } execute() { const t = this.editor.model; const e = t.document; let n = Array.from(e.selection.getSelectedBlocks()); t.change((t => { const e = n[n.length - 1]; let i = e.nextSibling; while (i && i.name == "listItem" && i.getAttribute("listIndent") > e.getAttribute("listIndent")) { n.push(i); i = i.nextSibling } if (this._indentBy < 0) { n = n.reverse() } for (const e of n) { const n = e.getAttribute("listIndent") + this._indentBy; if (n < 0) { t.rename(e, "paragraph") } else { t.setAttribute("listIndent", n, e) } } this.fire("_executeCleanup", n) })) } _checkEnabled() { const t = ol(this.editor.model.document.selection.getSelectedBlocks()); if (!t || !t.is("element", "listItem")) { return false } if (this._indentBy > 0) { const e = t.getAttribute("listIndent"); const n = t.getAttribute("listType"); let i = t.previousSibling; while (i && i.is("element", "listItem") && i.getAttribute("listIndent") >= e) { if (i.getAttribute("listIndent") == e) { return i.getAttribute("listType") == n } i = i.previousSibling } return false } return true } } function hO(t) { const e = t.createContainerElement("li"); e.getFillerOffset = xO; return e } function gO(t, e) { const n = e.mapper; const i = e.writer; const o = t.getAttribute("listType") == "numbered" ? "ol" : "ul"; const r = hO(i); const s = i.createContainerElement(o, null); i.insert(i.createPositionAt(s, 0), r); n.bindElements(t, r); return r } function mO(t, e, n, i) { const o = e.parent; const r = n.mapper; const s = n.writer; let a = r.toViewPosition(i.createPositionBefore(t)); const c = bO(t.previousSibling, { sameIndent: true, smallerIndent: true, listIndent: t.getAttribute("listIndent") }); const l = t.previousSibling; if (c && c.getAttribute("listIndent") == t.getAttribute("listIndent")) { const t = r.toViewElement(c); a = s.breakContainer(s.createPositionAfter(t)) } else { if (l && l.name == "listItem") { a = r.toViewPosition(i.createPositionAt(l, "end")); const t = r.findMappedViewAncestor(a); const e = wO(t); if (e) { a = s.createPositionBefore(e) } else { a = s.createPositionAt(t, "end") } } else { a = r.toViewPosition(i.createPositionBefore(t)) } } a = pO(a); s.insert(a, o); if (l && l.name == "listItem") { const t = r.toViewElement(l); const n = s.createRange(s.createPositionAt(t, 0), a); const i = n.getWalker({ ignoreElementEnd: true }); for (const t of i) { if (t.item.is("element", "li")) { const n = s.breakContainer(s.createPositionBefore(t.item)); const o = t.item.parent; const r = s.createPositionAt(e, "end"); fO(s, r.nodeBefore, r.nodeAfter); s.move(s.createRangeOn(o), r); i._position = n } } } else { const n = o.nextSibling; if (n && (n.is("element", "ul") || n.is("element", "ol"))) { let i = null; for (const e of n.getChildren()) { const n = r.toModelElement(e); if (n && n.getAttribute("listIndent") > t.getAttribute("listIndent")) { i = e } else { break } } if (i) { s.breakContainer(s.createPositionAfter(i)); s.move(s.createRangeOn(i.parent), s.createPositionAt(e, "end")) } } } fO(s, o, o.nextSibling); fO(s, o.previousSibling, o) } function fO(t, e, n) { if (!e || !n || e.name != "ul" && e.name != "ol") { return null } if (e.name != n.name || e.getAttribute("class") !== n.getAttribute("class")) { return null } return t.mergeContainers(t.createPositionAfter(e)) } function pO(t) { return t.getLastMatchingPosition((t => t.item.is("uiElement"))) } function bO(t, e) { const n = !!e.sameIndent; const i = !!e.smallerIndent; const o = e.listIndent; let r = t; while (r && r.name == "listItem") { const t = r.getAttribute("listIndent"); if (n && o == t || i && o > t) { return r } if (e.direction === "forward") { r = r.nextSibling } else { r = r.previousSibling } } return null } function kO(t, e, n, i) { t.ui.componentFactory.add(e, (o => { const r = t.commands.get(e); const s = new wC(o); s.set({ label: n, icon: i, tooltip: true, isToggleable: true }); s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"); s.on("execute", (() => { t.execute(e); t.editing.view.focus() })); return s })) } function wO(t) { for (const e of t.getChildren()) { if (e.name == "ul" || e.name == "ol") { return e } } return null } function AO(t, e) { const n = []; const i = t.parent; const o = { ignoreElementEnd: false, startPosition: t, shallow: true, direction: e }; const r = i.getAttribute("listIndent"); const s = [...new ff(o)].filter((t => t.item.is("element"))).map((t => t.item)); for (const t of s) { if (!t.is("element", "listItem")) { break } if (t.getAttribute("listIndent") < r) { break } if (t.getAttribute("listIndent") > r) { continue } if (t.getAttribute("listType") !== i.getAttribute("listType")) { break } if (t.getAttribute("listStyle") !== i.getAttribute("listStyle")) { break } if (t.getAttribute("listReversed") !== i.getAttribute("listReversed")) { break } if (t.getAttribute("listStart") !== i.getAttribute("listStart")) { break } if (e === "backward") { n.unshift(t) } else { n.push(t) } } return n } function _O(t) { const e = t.document; let n = [...e.selection.getSelectedBlocks()].filter((t => t.is("element", "listItem"))).map((e => { const n = t.change((t => t.createPositionAt(e, 0))); return [...AO(n, "backward"), ...AO(n, "forward")] })).flat(); n = [...new Set(n)]; return n } const CO = ["disc", "circle", "square"]; const vO = ["decimal", "decimal-leading-zero", "lower-roman", "upper-roman", "lower-latin", "upper-latin"]; function yO(t) { if (CO.includes(t)) { return "bulleted" } if (vO.includes(t)) { return "numbered" } return null } function xO() { const t = !this.isEmpty && (this.getChild(0).name == "ul" || this.getChild(0).name == "ol"); if (this.isEmpty || t) { return 0 } return Ju.call(this) } class EO extends wl { static get pluginName() { return "ListUtils" } getListTypeFromListStyleType(t) { return yO(t) } getSelectedListItems(t) { return _O(t) } getSiblingNodes(t, e) { return AO(t, e) } } function DO(t) { return (e, n, i) => { const o = i.consumable; if (!o.test(n.item, "insert") || !o.test(n.item, "attribute:listType") || !o.test(n.item, "attribute:listIndent")) { return } o.consume(n.item, "insert"); o.consume(n.item, "attribute:listType"); o.consume(n.item, "attribute:listIndent"); const r = n.item; const s = gO(r, i); mO(r, s, i, t) } } function SO(t) { return (e, n, i) => { const o = i.mapper.toViewPosition(n.position); const r = o.getLastMatchingPosition((t => !t.item.is("element", "li"))); const s = r.nodeAfter; const a = i.writer; a.breakContainer(a.createPositionBefore(s)); a.breakContainer(a.createPositionAfter(s)); const c = s.parent; const l = c.previousSibling; const d = a.createRangeOn(c); const u = a.remove(d); if (l && l.nextSibling) { fO(a, l, l.nextSibling) } const h = i.mapper.toModelElement(s); UO(h.getAttribute("listIndent") + 1, n.position, d.start, s, i, t); for (const t of a.createRangeIn(u).getItems()) { i.mapper.unbindViewElement(t) } e.stop() } } const TO = (t, e, n) => { if (!n.consumable.test(e.item, t.name)) { return } const i = n.mapper.toViewElement(e.item); const o = n.writer; o.breakContainer(o.createPositionBefore(i)); o.breakContainer(o.createPositionAfter(i)); const r = i.parent; const s = e.attributeNewValue == "numbered" ? "ol" : "ul"; o.rename(s, r) }; const IO = (t, e, n) => { n.consumable.consume(e.item, t.name); const i = n.mapper.toViewElement(e.item); const o = i.parent; const r = n.writer; fO(r, o, o.nextSibling); fO(r, o.previousSibling, o) }; function MO(t) { return (e, n, i) => { if (!i.consumable.consume(n.item, "attribute:listIndent")) { return } const o = i.mapper.toViewElement(n.item); const r = i.writer; r.breakContainer(r.createPositionBefore(o)); r.breakContainer(r.createPositionAfter(o)); const s = o.parent; const a = s.previousSibling; const c = r.createRangeOn(s); r.remove(c); if (a && a.nextSibling) { fO(r, a, a.nextSibling) } UO(n.attributeOldValue + 1, n.range.start, c.start, o, i, t); mO(n.item, o, i, t); for (const t of n.item.getChildren()) { i.consumable.consume(t, "insert") } } } const BO = (t, e, n) => { if (!n.consumable.test(e.item, t.name)) { return } if (e.item.name != "listItem") { let t = n.mapper.toViewPosition(e.range.start); const i = n.writer; const o = []; while (t.parent.name == "ul" || t.parent.name == "ol") { t = i.breakContainer(t); if (t.parent.name != "li") { break } const e = t; const n = i.createPositionAt(t.parent, "end"); if (!e.isEqual(n)) { const t = i.remove(i.createRange(e, n)); o.push(t) } t = i.createPositionAfter(t.parent) } if (o.length > 0) { for (let e = 0; e < o.length; e++) { const n = t.nodeBefore; const r = i.insert(t, o[e]); t = r.end; if (e > 0) { const e = fO(i, n, n.nextSibling); if (e && e.parent == n) { t.offset-- } } } fO(i, t.nodeBefore, t.nodeAfter) } } }; const LO = (t, e, n) => { const i = n.mapper.toViewPosition(e.position); const o = i.nodeBefore; const r = i.nodeAfter; fO(n.writer, o, r) }; const NO = (t, e, n) => { if (n.consumable.consume(e.viewItem, { name: true })) { const t = n.writer; const i = t.createElement("listItem"); const o = qO(e.viewItem); t.setAttribute("listIndent", o, i); const r = e.viewItem.parent && e.viewItem.parent.name == "ol" ? "numbered" : "bulleted"; t.setAttribute("listType", r, i); if (!n.safeInsert(i, e.modelCursor)) { return } const s = FO(i, e.viewItem.getChildren(), n); e.modelRange = t.createRange(e.modelCursor, s); n.updateConversionResult(i, e) } }; const zO = (t, e, n) => { if (n.consumable.test(e.viewItem, { name: true })) { const t = Array.from(e.viewItem.getChildren()); for (const e of t) { const t = !(e.is("element", "li") || WO(e)); if (t) { e._remove() } } } }; const PO = (t, e, n) => { if (n.consumable.test(e.viewItem, { name: true })) { if (e.viewItem.childCount === 0) { return } const t = [...e.viewItem.getChildren()]; let n = false; for (const e of t) { if (n && !WO(e)) { e._remove() } if (WO(e)) { n = true } } } }; function OO(t) { return (e, n) => { if (n.isPhantom) { return } const i = n.modelPosition.nodeBefore; if (i && i.is("element", "listItem")) { const e = n.mapper.toViewElement(i); const o = e.getAncestors().find(WO); const r = t.createPositionAt(e, 0).getWalker(); for (const t of r) { if (t.type == "elementStart" && t.item.is("element", "li")) { n.viewPosition = t.previousPosition; break } else if (t.type == "elementEnd" && t.item == o) { n.viewPosition = t.nextPosition; break } } } } } function RO(t) { return (e, n) => { const i = n.viewPosition; const o = i.parent; const r = n.mapper; if (o.name == "ul" || o.name == "ol") { if (!i.isAtEnd) { const e = r.toModelElement(i.nodeAfter); n.modelPosition = t.createPositionBefore(e) } else { const e = r.toModelElement(i.nodeBefore); const o = r.getModelLength(i.nodeBefore); n.modelPosition = t.createPositionBefore(e).getShiftedBy(o) } e.stop() } else if (o.name == "li" && i.nodeBefore && (i.nodeBefore.name == "ul" || i.nodeBefore.name == "ol")) { const s = r.toModelElement(o); let a = 1; let c = i.nodeBefore; while (c && WO(c)) { a += r.getModelLength(c); c = c.previousSibling } n.modelPosition = t.createPositionBefore(s).getShiftedBy(a); e.stop() } } } function VO(t, e) { const n = t.document.differ.getChanges(); const i = new Map; let o = false; for (const i of n) { if (i.type == "insert" && i.name == "listItem") { r(i.position) } else if (i.type == "insert" && i.name != "listItem") { if (i.name != "$text") { const n = i.position.nodeAfter; if (n.hasAttribute("listIndent")) { e.removeAttribute("listIndent", n); o = true } if (n.hasAttribute("listType")) { e.removeAttribute("listType", n); o = true } if (n.hasAttribute("listStyle")) { e.removeAttribute("listStyle", n); o = true } if (n.hasAttribute("listReversed")) { e.removeAttribute("listReversed", n); o = true } if (n.hasAttribute("listStart")) { e.removeAttribute("listStart", n); o = true } for (const e of Array.from(t.createRangeIn(n)).filter((t => t.item.is("element", "listItem")))) { r(e.previousPosition) } } const n = i.position.getShiftedBy(i.length); r(n) } else if (i.type == "remove" && i.name == "listItem") { r(i.position) } else if (i.type == "attribute" && i.attributeKey == "listIndent") { r(i.range.start) } else if (i.type == "attribute" && i.attributeKey == "listType") { r(i.range.start) } } for (const t of i.values()) { s(t); a(t) } return o; function r(t) { const e = t.nodeBefore; if (!e || !e.is("element", "listItem")) { const e = t.nodeAfter; if (e && e.is("element", "listItem")) { i.set(e, e) } } else { let t = e; if (i.has(t)) { return } for (let e = t.previousSibling; e && e.is("element", "listItem"); e = t.previousSibling) { t = e; if (i.has(t)) { return } } i.set(e, t) } } function s(t) { let n = 0; let i = null; while (t && t.is("element", "listItem")) { const r = t.getAttribute("listIndent"); if (r > n) { let s; if (i === null) { i = r - n; s = n } else { if (i > r) { i = r } s = r - i } e.setAttribute("listIndent", s, t); o = true } else { i = null; n = t.getAttribute("listIndent") + 1 } t = t.nextSibling } } function a(t) { let n = []; let i = null; while (t && t.is("element", "listItem")) { const r = t.getAttribute("listIndent"); if (i && i.getAttribute("listIndent") > r) { n = n.slice(0, r + 1) } if (r != 0) { if (n[r]) { const i = n[r]; if (t.getAttribute("listType") != i) { e.setAttribute("listType", i, t); o = true } } else { n[r] = t.getAttribute("listType") } } i = t; t = t.nextSibling } } } const jO = function (t, [e, n]) { const i = this; let o = e.is("documentFragment") ? e.getChild(0) : e; let r; if (!n) { r = i.document.selection } else { r = i.createSelection(n) } if (o && o.is("element", "listItem")) { const t = r.getFirstPosition(); let e = null; if (t.parent.is("element", "listItem")) { e = t.parent } else if (t.nodeBefore && t.nodeBefore.is("element", "listItem")) { e = t.nodeBefore } if (e) { const t = e.getAttribute("listIndent"); if (t > 0) { while (o && o.is("element", "listItem")) { o._setAttribute("listIndent", o.getAttribute("listIndent") + t); o = o.nextSibling } } } } }; function FO(t, e, n) { const { writer: i, schema: o } = n; let r = i.createPositionAfter(t); for (const s of e) { if (s.name == "ul" || s.name == "ol") { r = n.convertItem(s, r).modelCursor } else { const e = n.convertItem(s, i.createPositionAt(t, "end")); const a = e.modelRange.start.nodeAfter; const c = a && a.is("element") && !o.checkChild(t, a.name); if (c) { if (e.modelCursor.parent.is("element", "listItem")) { t = e.modelCursor.parent } else { t = HO(e.modelCursor) } r = i.createPositionAfter(t) } } } return r } function HO(t) { const e = new ff({ startPosition: t }); let n; do { n = e.next() } while (!n.value.item.is("element", "listItem")); return n.value.item } function UO(t, e, n, i, o, r) { const s = bO(e.nodeBefore, { sameIndent: true, smallerIndent: true, listIndent: t }); const a = o.mapper; const c = o.writer; const l = s ? s.getAttribute("listIndent") : null; let d; if (!s) { d = n } else if (l == t) { const t = a.toViewElement(s).parent; d = c.createPositionAfter(t) } else { const t = r.createPositionAt(s, "end"); d = a.toViewPosition(t) } d = pO(d); for (const t of [...i.getChildren()]) { if (WO(t)) { d = c.move(c.createRangeOn(t), d).end; fO(c, t, t.nextSibling); fO(c, t.previousSibling, t) } } } function WO(t) { return t.is("element", "ol") || t.is("element", "ul") } function qO(t) { let e = 0; let n = t.parent; while (n) { if (n.is("element", "li")) { e++ } else { const t = n.previousSibling; if (t && t.is("element", "li")) { e++ } } n = n.parent } return e } var GO = n(9989); var $O = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; $O.insert = "head"; $O.singleton = true; var KO = Sl()(GO.Z, $O); const YO = GO.Z.locals || {}; class QO extends wl { static get pluginName() { return "ListEditing" } static get requires() { return [iD, xE, EO] } init() { const t = this.editor; t.model.schema.register("listItem", { inheritAllFrom: "$block", allowAttributes: ["listType", "listIndent"] }); const e = t.data; const n = t.editing; t.model.document.registerPostFixer((e => VO(t.model, e))); n.mapper.registerViewToModelLength("li", ZO); e.mapper.registerViewToModelLength("li", ZO); n.mapper.on("modelToViewPosition", OO(n.view)); n.mapper.on("viewToModelPosition", RO(t.model)); e.mapper.on("modelToViewPosition", OO(n.view)); t.conversion.for("editingDowncast").add((e => { e.on("insert", BO, { priority: "high" }); e.on("insert:listItem", DO(t.model)); e.on("attribute:listType:listItem", TO, { priority: "high" }); e.on("attribute:listType:listItem", IO, { priority: "low" }); e.on("attribute:listIndent:listItem", MO(t.model)); e.on("remove:listItem", SO(t.model)); e.on("remove", LO, { priority: "low" }) })); t.conversion.for("dataDowncast").add((e => { e.on("insert", BO, { priority: "high" }); e.on("insert:listItem", DO(t.model)) })); t.conversion.for("upcast").add((t => { t.on("element:ul", zO, { priority: "high" }); t.on("element:ol", zO, { priority: "high" }); t.on("element:li", PO, { priority: "high" }); t.on("element:li", NO) })); t.model.on("insertContent", jO, { priority: "high" }); t.commands.add("numberedList", new cO(t, "numbered")); t.commands.add("bulletedList", new cO(t, "bulleted")); t.commands.add("indentList", new uO(t, "forward")); t.commands.add("outdentList", new uO(t, "backward")); const i = n.view.document; this.listenTo(i, "enter", ((t, e) => { const n = this.editor.model.document; const i = n.selection.getLastPosition().parent; if (n.selection.isCollapsed && i.name == "listItem" && i.isEmpty) { this.editor.execute("outdentList"); e.preventDefault(); t.stop() } }), { context: "li" }); this.listenTo(i, "delete", ((t, e) => { if (e.direction !== "backward") { return } const n = this.editor.model.document.selection; if (!n.isCollapsed) { return } const i = n.getFirstPosition(); if (!i.isAtStart) { return } const o = i.parent; if (o.name !== "listItem") { return } const r = o.previousSibling && o.previousSibling.name === "listItem"; if (r) { return } this.editor.execute("outdentList"); e.preventDefault(); t.stop() }), { context: "li" }); this.listenTo(t.editing.view.document, "tab", ((e, n) => { const i = n.shiftKey ? "outdentList" : "indentList"; const o = this.editor.commands.get(i); if (o.isEnabled) { t.execute(i); n.stopPropagation(); n.preventDefault(); e.stop() } }), { context: "li" }) } afterInit() { const t = this.editor.commands; const e = t.get("indent"); const n = t.get("outdent"); if (e) { e.registerChildCommand(t.get("indentList")) } if (n) { n.registerChildCommand(t.get("outdentList")) } } } function ZO(t) { let e = 1; for (const n of t.getChildren()) { if (n.name == "ul" || n.name == "ol") { for (const t of n.getChildren()) { e += ZO(t) } } } return e } const JO = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>'; const XO = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>'; class tR extends wl { static get pluginName() { return "ListUI" } init() { const t = this.editor.t; kO(this.editor, "numberedList", t("Numbered List"), JO); kO(this.editor, "bulletedList", t("Bulleted List"), XO) } } class eR extends wl { static get requires() { return [QO, tR] } static get pluginName() { return "List" } } class nR extends _l { constructor(t, e) { super(t); this.defaultType = e } refresh() { this.value = this._getValue(); this.isEnabled = this._checkEnabled() } execute(t = {}) { this._tryToConvertItemsToList(t); const e = this.editor.model; const n = _O(e); if (!n.length) { return } e.change((e => { for (const i of n) { e.setAttribute("listStyle", t.type || this.defaultType, i) } })) } _getValue() { const t = this.editor.model.document.selection.getFirstPosition().parent; if (t && t.is("element", "listItem")) { return t.getAttribute("listStyle") } return null } _checkEnabled() { const t = this.editor; const e = t.commands.get("numberedList"); const n = t.commands.get("bulletedList"); return e.isEnabled || n.isEnabled } _tryToConvertItemsToList(t) { if (!t.type) { return } const e = yO(t.type); if (!e) { return } const n = this.editor; const i = `${e}List`; const o = n.commands.get(i); if (!o.value) { n.execute(i) } } } class iR extends _l { refresh() { const t = this._getValue(); this.value = t; this.isEnabled = t != null } execute(t = {}) { const e = this.editor.model; const n = _O(e).filter((t => t.getAttribute("listType") == "numbered")); e.change((e => { for (const i of n) { e.setAttribute("listReversed", !!t.reversed, i) } })) } _getValue() { const t = this.editor.model.document.selection.getFirstPosition().parent; if (t && t.is("element", "listItem") && t.getAttribute("listType") == "numbered") { return t.getAttribute("listReversed") } return null } } class oR extends _l { refresh() { const t = this._getValue(); this.value = t; this.isEnabled = t != null } execute({ startIndex: t = 1 } = {}) { const e = this.editor.model; const n = _O(e).filter((t => t.getAttribute("listType") == "numbered")); e.change((e => { for (const i of n) { e.setAttribute("listStart", t >= 0 ? t : 1, i) } })) } _getValue() { const t = this.editor.model.document.selection.getFirstPosition().parent; if (t && t.is("element", "listItem") && t.getAttribute("listType") == "numbered") { return t.getAttribute("listStart") } return null } } const rR = "default"; class sR extends wl { static get requires() { return [QO] } static get pluginName() { return "ListPropertiesEditing" } constructor(t) { super(t); t.config.define("list", { properties: { styles: true, startIndex: false, reversed: false } }) } init() { const t = this.editor; const e = t.model; const n = t.config.get("list.properties"); const i = aR(n); e.schema.extend("listItem", { allowAttributes: i.map((t => t.attributeName)) }); for (const e of i) { e.addCommand(t) } this.listenTo(t.commands.get("indentList"), "_executeCleanup", dR(t, i)); this.listenTo(t.commands.get("outdentList"), "_executeCleanup", uR(t, i)); this.listenTo(t.commands.get("bulletedList"), "_executeCleanup", pR(t)); this.listenTo(t.commands.get("numberedList"), "_executeCleanup", pR(t)); e.document.registerPostFixer(hR(t, i)); t.conversion.for("upcast").add(cR(i)); t.conversion.for("downcast").add(lR(i)); this._mergeListAttributesWhileMergingLists(i) } afterInit() { const t = this.editor; if (t.commands.get("todoList")) { t.model.document.registerPostFixer(fR(t)) } } _mergeListAttributesWhileMergingLists(t) { const e = this.editor; const n = e.model; let i; this.listenTo(n, "deleteContent", ((t, [e]) => { const n = e.getFirstPosition(); const o = e.getLastPosition(); if (n.parent === o.parent) { return } if (!n.parent.is("element", "listItem")) { return } const r = o.parent.nextSibling; if (!r || !r.is("element", "listItem")) { return } const s = bO(n.parent, { sameIndent: true, listIndent: r.getAttribute("listIndent") }); if (!s) { return } if (s.getAttribute("listType") === r.getAttribute("listType")) { i = s } }), { priority: "high" }); this.listenTo(n, "deleteContent", (() => { if (!i) { return } n.change((e => { const n = bO(i.nextSibling, { sameIndent: true, listIndent: i.getAttribute("listIndent"), direction: "forward" }); if (!n) { i = null; return } const o = [n, ...AO(e.createPositionAt(n, 0), "forward")]; for (const n of o) { for (const o of t) { if (o.appliesToListItem(n)) { const t = o.attributeName; const r = i.getAttribute(t); e.setAttribute(t, r, n) } } } })); i = null }), { priority: "low" }) } } function aR(t) { const e = []; if (t.styles) { e.push({ attributeName: "listStyle", defaultValue: rR, addCommand(t) { t.commands.add("listStyle", new nR(t, rR)) }, appliesToListItem() { return true }, setAttributeOnDowncast(t, e, n) { if (e && e !== rR) { t.setStyle("list-style-type", e, n) } else { t.removeStyle("list-style-type", n) } }, getAttributeOnUpcast(t) { return t.getStyle("list-style-type") || rR } }) } if (t.reversed) { e.push({ attributeName: "listReversed", defaultValue: false, addCommand(t) { t.commands.add("listReversed", new iR(t)) }, appliesToListItem(t) { return t.getAttribute("listType") == "numbered" }, setAttributeOnDowncast(t, e, n) { if (e) { t.setAttribute("reversed", "reversed", n) } else { t.removeAttribute("reversed", n) } }, getAttributeOnUpcast(t) { return t.hasAttribute("reversed") } }) } if (t.startIndex) { e.push({ attributeName: "listStart", defaultValue: 1, addCommand(t) { t.commands.add("listStart", new oR(t)) }, appliesToListItem(t) { return t.getAttribute("listType") == "numbered" }, setAttributeOnDowncast(t, e, n) { if (e == 0 || e > 1) { t.setAttribute("start", e, n) } else { t.removeAttribute("start", n) } }, getAttributeOnUpcast(t) { const e = t.getAttribute("start"); return e >= 0 ? e : 1 } }) } return e } function cR(t) { return e => { e.on("element:li", ((e, n, i) => { if (!n.modelRange) { return } const o = n.viewItem.parent; const r = n.modelRange.start.nodeAfter || n.modelRange.end.nodeBefore; for (const e of t) { if (e.appliesToListItem(r)) { const t = e.getAttributeOnUpcast(o); i.writer.setAttribute(e.attributeName, t, r) } } }), { priority: "low" }) } } function lR(t) { return n => { for (const i of t) { n.on(`attribute:${i.attributeName}:listItem`, ((t, n, o) => { const r = o.writer; const s = n.item; const a = bO(s.previousSibling, { sameIndent: true, listIndent: s.getAttribute("listIndent"), direction: "backward" }); const c = o.mapper.toViewElement(s); if (!e(s, a)) { r.breakContainer(r.createPositionBefore(c)) } i.setAttributeOnDowncast(r, n.attributeNewValue, c.parent) }), { priority: "low" }) } }; function e(t, e) { return e && t.getAttribute("listType") === e.getAttribute("listType") && t.getAttribute("listIndent") === e.getAttribute("listIndent") && t.getAttribute("listStyle") === e.getAttribute("listStyle") && t.getAttribute("listReversed") === e.getAttribute("listReversed") && t.getAttribute("listStart") === e.getAttribute("listStart") } } function dR(t, e) { return (n, i) => { const o = i[0]; const r = o.getAttribute("listIndent"); const s = i.filter((t => t.getAttribute("listIndent") === r)); let a = null; if (o.previousSibling.getAttribute("listIndent") + 1 !== r) { a = bO(o.previousSibling, { sameIndent: true, direction: "backward", listIndent: r }) } t.model.change((t => { for (const n of s) { for (const i of e) { if (i.appliesToListItem(n)) { const e = a == null ? i.defaultValue : a.getAttribute(i.attributeName); t.setAttribute(i.attributeName, e, n) } } } })) } } function uR(t, e) { return (n, i) => { i = i.reverse().filter((t => t.is("element", "listItem"))); if (!i.length) { return } const o = i[0].getAttribute("listIndent"); const r = i[0].getAttribute("listType"); let s = i[0].previousSibling; if (s.is("element", "listItem")) { while (s.getAttribute("listIndent") !== o) { s = s.previousSibling } } else { s = null } if (!s) { s = i[i.length - 1].nextSibling } if (!s || !s.is("element", "listItem")) { return } if (s.getAttribute("listType") !== r) { return } t.model.change((t => { const n = i.filter((t => t.getAttribute("listIndent") === o)); for (const i of n) { for (const n of e) { if (n.appliesToListItem(i)) { const e = n.attributeName; const o = s.getAttribute(e); t.setAttribute(e, o, i) } } } })) } } function hR(t, e) { return n => { let i = false; const o = bR(t.model.document.differ.getChanges()).filter((t => t.getAttribute("listType") !== "todo")); if (!o.length) { return i } let r = o[o.length - 1].nextSibling; if (!r || !r.is("element", "listItem")) { r = o[0].previousSibling; if (r) { const t = o[0].getAttribute("listIndent"); while (r.is("element", "listItem") && r.getAttribute("listIndent") !== t) { r = r.previousSibling; if (!r) { break } } } } for (const t of e) { const e = t.attributeName; for (const s of o) { if (!t.appliesToListItem(s)) { n.removeAttribute(e, s); continue } if (!s.hasAttribute(e)) { if (gR(r, s, t)) { n.setAttribute(e, r.getAttribute(e), s) } else { n.setAttribute(e, t.defaultValue, s) } i = true } else { const o = s.previousSibling; if (mR(o, s, t.attributeName)) { n.setAttribute(e, o.getAttribute(e), s); i = true } } } } return i } } function gR(t, e, n) { if (!t) { return false } const i = t.getAttribute(n.attributeName); if (!i) { return false } if (i == n.defaultValue) { return false } if (t.getAttribute("listType") !== e.getAttribute("listType")) { return false } return true } function mR(t, e, n) { if (!t || !t.is("element", "listItem")) { return false } if (e.getAttribute("listType") !== t.getAttribute("listType")) { return false } const i = t.getAttribute("listIndent"); if (i < 1 || i !== e.getAttribute("listIndent")) { return false } const o = t.getAttribute(n); if (!o || o === e.getAttribute(n)) { return false } return true } function fR(t) { return e => { const n = bR(t.model.document.differ.getChanges()).filter((t => t.getAttribute("listType") === "todo" && (t.hasAttribute("listStyle") || t.hasAttribute("listReversed") || t.hasAttribute("listStart")))); if (!n.length) { return false } for (const t of n) { e.removeAttribute("listStyle", t); e.removeAttribute("listReversed", t); e.removeAttribute("listStart", t) } return true } } function pR(t) { return (e, n) => { n = n.filter((t => t.is("element", "listItem"))); t.model.change((t => { for (const e of n) { t.removeAttribute("listStyle", e) } })) } } function bR(t) { const e = []; for (const n of t) { const t = kR(n); if (t && t.is("element", "listItem")) { e.push(t) } } return e } function kR(t) { if (t.type === "attribute") { return t.range.start.nodeAfter } if (t.type === "insert") { return t.position.nodeAfter } return null } var wR = n(3195); var AR = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; AR.insert = "head"; AR.singleton = true; var _R = Sl()(wR.Z, AR); const CR = wR.Z.locals || {}; class vR extends N_ { constructor(t, e) { super(t); const n = this.bindTemplate; this.set("isCollapsed", false); this.set("label", ""); this.buttonView = this._createButtonView(); this.children = this.createCollection(); this.set("_collapsibleAriaLabelUid", undefined); if (e) { this.children.addMany(e) } this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-collapsible", n.if("isCollapsed", "ck-collapsible_collapsed")] }, children: [this.buttonView, { tag: "div", attributes: { class: ["ck", "ck-collapsible__children"], role: "region", hidden: n.if("isCollapsed", "hidden"), "aria-labelledby": n.to("_collapsibleAriaLabelUid") }, children: this.children }] }) } render() { super.render(); this._collapsibleAriaLabelUid = this.buttonView.labelView.element.id } _createButtonView() { const t = new wC(this.locale); const e = t.bindTemplate; t.set({ withText: true, icon: UC }); t.extendTemplate({ attributes: { "aria-expanded": e.to("isOn", (t => String(t))) } }); t.bind("label").to(this); t.bind("isOn").to(this, "isCollapsed", (t => !t)); t.on("execute", (() => { this.isCollapsed = !this.isCollapsed })); return t } } var yR = n(7133); var xR = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; xR.insert = "head"; xR.singleton = true; var ER = Sl()(yR.Z, xR); const DR = yR.Z.locals || {}; class SR extends N_ { constructor(t, { enabledProperties: e, styleButtonViews: n, styleGridAriaLabel: i }) { super(t); this.stylesView = null; this.additionalPropertiesCollapsibleView = null; this.startIndexFieldView = null; this.reversedSwitchButtonView = null; this.focusTracker = new rl; this.keystrokes = new sl; this.focusables = new S_; const o = ["ck", "ck-list-properties"]; this.children = this.createCollection(); this.focusCycler = new QC({ focusables: this.focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }); if (e.styles) { this.stylesView = this._createStylesView(n, i); this.children.add(this.stylesView) } else { o.push("ck-list-properties_without-styles") } if (e.startIndex || e.reversed) { this._addNumberedListPropertyViews(e); o.push("ck-list-properties_with-numbered-properties") } this.setTemplate({ tag: "div", attributes: { class: o }, children: this.children }) } render() { super.render(); if (this.stylesView) { this.focusables.add(this.stylesView); this.focusTracker.add(this.stylesView.element); if (this.startIndexFieldView || this.reversedSwitchButtonView) { this.focusables.add(this.children.last.buttonView); this.focusTracker.add(this.children.last.buttonView.element) } for (const t of this.stylesView.children) { this.stylesView.focusTracker.add(t.element) } D_({ keystrokeHandler: this.stylesView.keystrokes, focusTracker: this.stylesView.focusTracker, gridItems: this.stylesView.children, numberOfColumns: () => Za.window.getComputedStyle(this.stylesView.element).getPropertyValue("grid-template-columns").split(" ").length, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection }) } if (this.startIndexFieldView) { this.focusables.add(this.startIndexFieldView); this.focusTracker.add(this.startIndexFieldView.element); this.listenTo(this.startIndexFieldView.element, "selectstart", ((t, e) => { e.stopPropagation() }), { priority: "high" }); const t = t => t.stopPropagation(); this.keystrokes.set("arrowright", t); this.keystrokes.set("arrowleft", t); this.keystrokes.set("arrowup", t); this.keystrokes.set("arrowdown", t) } if (this.reversedSwitchButtonView) { this.focusables.add(this.reversedSwitchButtonView); this.focusTracker.add(this.reversedSwitchButtonView.element) } this.keystrokes.listenTo(this.element) } focus() { this.focusCycler.focusFirst() } focusLast() { this.focusCycler.focusLast() } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } _createStylesView(t, e) { const n = new N_(this.locale); n.children = n.createCollection(); n.children.addMany(t); n.setTemplate({ tag: "div", attributes: { "aria-label": e, class: ["ck", "ck-list-styles-list"] }, children: n.children }); n.children.delegate("execute").to(this); n.focus = function () { this.children.first.focus() }; n.focusTracker = new rl; n.keystrokes = new sl; n.render(); n.keystrokes.listenTo(n.element); return n } _addNumberedListPropertyViews(t) { const e = this.locale.t; const n = []; if (t.startIndex) { this.startIndexFieldView = this._createStartIndexField(); n.push(this.startIndexFieldView) } if (t.reversed) { this.reversedSwitchButtonView = this._createReversedSwitchButton(); n.push(this.reversedSwitchButtonView) } if (t.styles) { this.additionalPropertiesCollapsibleView = new vR(this.locale, n); this.additionalPropertiesCollapsibleView.set({ label: e("List properties"), isCollapsed: true }); this.additionalPropertiesCollapsibleView.buttonView.bind("isEnabled").toMany(n, "isEnabled", ((...t) => t.some((t => t)))); this.additionalPropertiesCollapsibleView.buttonView.on("change:isEnabled", ((t, e, n) => { if (!n) { this.additionalPropertiesCollapsibleView.isCollapsed = true } })); this.children.add(this.additionalPropertiesCollapsibleView) } else { this.children.addMany(n) } } _createStartIndexField() { const t = this.locale.t; const e = new Py(this.locale, Ry); e.set({ label: t("Start at"), class: "ck-numbered-list-properties__start-index" }); e.fieldView.set({ min: 0, step: 1, value: 1, inputMode: "numeric" }); e.fieldView.on("input", (() => { const n = e.fieldView.element; const i = n.valueAsNumber; if (Number.isNaN(i)) { return } if (!n.checkValidity()) { e.errorText = t("Start index must be greater than 0.") } else { this.fire("listStart", { startIndex: i }) } })); return e } _createReversedSwitchButton() { const t = this.locale.t; const e = new yC(this.locale); e.set({ withText: true, label: t("Reversed order"), class: "ck-numbered-list-properties__reversed-order" }); e.delegate("execute").to(this, "listReversed"); return e } } const TR = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6z"/></svg>'; const IR = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4z"/></svg>'; const MR = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M14 27v6H8v-6h6zm0-9v6H8v-6h6zm0-9v6H8V9h6z"/></svg>'; const BR = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M10.29 15V8.531H9.286c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.343 0v-1.235h-1.235V15h1.235zM11.3 24v-1.147H8.848c.064-.111.148-.226.252-.343.104-.117.351-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.494-.824.104-.263.156-.539.156-.829 0-.51-.182-.936-.545-1.279-.363-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.153-.155.358-.233.616-.233.26 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.468.536-1.024 1.055-.692.641-1.155 1.156-1.389 1.544-.234.389-.375.8-.422 1.233H11.3zm2.333 0v-1.235h-1.235V24h1.235zM9.204 34.11c.615 0 1.129-.2 1.542-.598.413-.398.62-.88.62-1.446 0-.39-.11-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.619-.337.928-.788.928-1.353 0-.399-.151-.756-.453-1.073-.366-.386-.852-.58-1.459-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.668.55c-.16.232-.28.544-.358.933l1.138.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.215 0 .386.065.515.194s.193.302.193.518c0 .255-.087.46-.263.613-.176.154-.43.227-.765.218l-.136 1.006c.22-.061.409-.092.567-.092.24 0 .444.09.61.272.168.182.251.428.251.739 0 .328-.087.589-.261.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.307-.698l-1.196.145c.062.542.285.98.668 1.316.384.335.868.503 1.45.503zm4.43-.11v-1.235h-1.236V34h1.235z"/></svg>'; const LR = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M5.714 15.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm6.078.914V8.531H10.79c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.344 0v-1.235h-1.235V15h1.235zm-9.422 9.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm7.088.914v-1.147H10.35c.065-.111.149-.226.253-.343.104-.117.35-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.493-.824.104-.263.156-.539.156-.829 0-.51-.181-.936-.544-1.279-.364-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.152-.155.357-.233.615-.233.261 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.467.536-1.024 1.055-.691.641-1.154 1.156-1.388 1.544-.235.389-.375.8-.422 1.233h4.328zm2.334 0v-1.235h-1.235V24h1.235zM5.714 34.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm4.992 1.024c.616 0 1.13-.2 1.543-.598.413-.398.62-.88.62-1.446 0-.39-.111-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.618-.337.927-.788.927-1.353 0-.399-.15-.756-.452-1.073-.366-.386-.853-.58-1.46-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.667.55c-.16.232-.28.544-.359.933l1.139.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.214 0 .386.065.515.194s.193.302.193.518c0 .255-.088.46-.264.613-.175.154-.43.227-.764.218l-.136 1.006c.22-.061.408-.092.566-.092.24 0 .444.09.611.272.167.182.25.428.25.739 0 .328-.086.589-.26.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.308-.698l-1.195.145c.062.542.284.98.668 1.316.384.335.867.503 1.45.503zm4.43-.11v-1.235h-1.235V34h1.235z"/></svg>'; const NR = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.88 8.7V7.558h-1.234V8.7h1.234zm0 5.3V9.333h-1.234V14h1.234zm2.5 0v-1.235h-1.234V14h1.235zm-4.75 4.7v-1.142H8.395V18.7H9.63zm0 5.3v-4.667H8.395V24H9.63zm2.5-5.3v-1.142h-1.234V18.7h1.235zm0 5.3v-4.667h-1.234V24h1.235zm2.501 0v-1.235h-1.235V24h1.235zM7.38 28.7v-1.142H6.145V28.7H7.38zm0 5.3v-4.667H6.145V34H7.38zm2.5-5.3v-1.142H8.646V28.7H9.88zm0 5.3v-4.667H8.646V34H9.88zm2.5-5.3v-1.142h-1.234V28.7h1.235zm0 5.3v-4.667h-1.234V34h1.235zm2.501 0v-1.235h-1.235V34h1.235z"/></svg>'; const zR = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.916 15V8.558h-1.301V15h1.3zm2.465 0v-1.235h-1.235V15h1.235zM9.665 25v-6.442h-1.3V25h1.3zm2.5 0v-6.442h-1.3V25h1.3zm2.466 0v-1.235h-1.235V25h1.235zm-7.216 9v-6.442h-1.3V34h1.3zm2.5 0v-6.442h-1.3V34h1.3zm2.501 0v-6.442h-1.3V34h1.3zm2.465 0v-1.235h-1.235V34h1.235z"/></svg>'; const PR = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M9.62 14.105c.272 0 .528-.05.768-.153s.466-.257.677-.462c.009.024.023.072.044.145.047.161.086.283.119.365h1.221a2.649 2.649 0 0 1-.222-.626c-.04-.195-.059-.498-.059-.908l.013-1.441c0-.536-.055-.905-.165-1.105-.11-.201-.3-.367-.569-.497-.27-.13-.68-.195-1.23-.195-.607 0-1.064.108-1.371.325-.308.217-.525.55-.65 1.002l1.12.202c.076-.217.176-.369.299-.455.123-.086.294-.13.514-.13.325 0 .546.05.663.152.118.101.176.27.176.508v.123c-.222.093-.622.194-1.2.303-.427.082-.755.178-.982.288-.227.11-.403.268-.53.474a1.327 1.327 0 0 0-.188.706c0 .398.138.728.415.988.277.261.656.391 1.136.391zm.368-.87a.675.675 0 0 1-.492-.189.606.606 0 0 1-.193-.448c0-.176.08-.32.241-.435.106-.07.33-.142.673-.215a7.19 7.19 0 0 0 .751-.19v.247c0 .296-.016.496-.048.602a.773.773 0 0 1-.295.409 1.07 1.07 0 0 1-.637.22zm4.645.765v-1.235h-1.235V14h1.235zM10.2 25.105c.542 0 1.003-.215 1.382-.646.38-.43.57-1.044.57-1.84 0-.771-.187-1.362-.559-1.774a1.82 1.82 0 0 0-1.41-.617c-.522 0-.973.216-1.354.65v-2.32H7.594V25h1.147v-.686a1.9 1.9 0 0 0 .67.592c.26.133.523.2.79.2zm-.299-.975c-.354 0-.638-.164-.852-.492-.153-.232-.229-.59-.229-1.073 0-.468.098-.818.295-1.048a.93.93 0 0 1 .738-.345c.302 0 .55.118.743.354.193.236.29.62.29 1.154 0 .5-.096.868-.288 1.1-.192.233-.424.35-.697.35zm4.478.87v-1.235h-1.234V25h1.234zm-4.017 9.105c.6 0 1.08-.142 1.437-.426.357-.284.599-.704.725-1.261l-1.213-.207c-.061.326-.167.555-.316.688a.832.832 0 0 1-.576.2.916.916 0 0 1-.75-.343c-.185-.228-.278-.62-.278-1.173 0-.498.091-.853.274-1.066.183-.212.429-.318.736-.318.232 0 .42.061.565.184.145.123.238.306.28.55l1.216-.22c-.146-.501-.387-.874-.722-1.119-.336-.244-.788-.366-1.356-.366-.695 0-1.245.214-1.653.643-.407.43-.61 1.03-.61 1.8 0 .762.202 1.358.608 1.788.406.431.95.646 1.633.646zM14.633 34v-1.235h-1.235V34h1.235z"/></svg>'; const OR = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="m7.88 15 .532-1.463h2.575L11.549 15h1.415l-2.58-6.442H9.01L6.5 15h1.38zm2.69-2.549H8.811l.87-2.39.887 2.39zM14.88 15v-1.235h-1.234V15h1.234zM9.352 25c.83-.006 1.352-.02 1.569-.044.346-.038.636-.14.872-.305.236-.166.422-.387.558-.664.137-.277.205-.562.205-.855 0-.372-.106-.695-.317-.97-.21-.276-.512-.471-.905-.585a1.51 1.51 0 0 0 .661-.567 1.5 1.5 0 0 0 .244-.83c0-.28-.066-.53-.197-.754a1.654 1.654 0 0 0-.495-.539 1.676 1.676 0 0 0-.672-.266c-.25-.042-.63-.063-1.14-.063H7.158V25h2.193zm.142-3.88H8.46v-1.49h.747c.612 0 .983.007 1.112.022.217.026.38.102.49.226.11.125.165.287.165.486a.68.68 0 0 1-.192.503.86.86 0 0 1-.525.23 11.47 11.47 0 0 1-.944.023h.18zm.17 2.795H8.46v-1.723h1.05c.592 0 .977.03 1.154.092.177.062.313.16.406.295a.84.84 0 0 1 .14.492c0 .228-.06.41-.181.547a.806.806 0 0 1-.473.257c-.126.026-.423.04-.892.04zM14.88 25v-1.235h-1.234V25h1.234zm-5.018 9.11c.691 0 1.262-.17 1.711-.512.45-.341.772-.864.965-1.567l-1.261-.4c-.109.472-.287.818-.536 1.037-.25.22-.547.33-.892.33-.47 0-.85-.173-1.143-.519-.293-.345-.44-.925-.44-1.74 0-.767.15-1.322.447-1.665.297-.343.684-.514 1.162-.514.346 0 .64.096.881.29.242.193.4.457.477.79l1.288-.307c-.147-.516-.367-.911-.66-1.187-.492-.465-1.132-.698-1.92-.698-.902 0-1.63.296-2.184.89-.554.593-.83 1.426-.83 2.498 0 1.014.275 1.813.825 2.397.551.585 1.254.877 2.11.877zM14.88 34v-1.235h-1.234V34h1.234z"/></svg>'; var RR = n(4553); var VR = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; VR.insert = "head"; VR.singleton = true; var jR = Sl()(RR.Z, VR); const FR = RR.Z.locals || {}; class HR extends wl { static get pluginName() { return "ListPropertiesUI" } init() { const t = this.editor; const e = t.locale.t; const n = t.config.get("list.properties"); if (n.styles) { t.ui.componentFactory.add("bulletedList", UR({ editor: t, parentCommandName: "bulletedList", buttonLabel: e("Bulleted List"), buttonIcon: XO, styleGridAriaLabel: e("Bulleted list styles toolbar"), styleDefinitions: [{ label: e("Toggle the disc list style"), tooltip: e("Disc"), type: "disc", icon: TR }, { label: e("Toggle the circle list style"), tooltip: e("Circle"), type: "circle", icon: IR }, { label: e("Toggle the square list style"), tooltip: e("Square"), type: "square", icon: MR }] })) } if (n.styles || n.startIndex || n.reversed) { t.ui.componentFactory.add("numberedList", UR({ editor: t, parentCommandName: "numberedList", buttonLabel: e("Numbered List"), buttonIcon: JO, styleGridAriaLabel: e("Numbered list styles toolbar"), styleDefinitions: [{ label: e("Toggle the decimal list style"), tooltip: e("Decimal"), type: "decimal", icon: BR }, { label: e("Toggle the decimal with leading zero list style"), tooltip: e("Decimal with leading zero"), type: "decimal-leading-zero", icon: LR }, { label: e("Toggle the lower–roman list style"), tooltip: e("Lower–roman"), type: "lower-roman", icon: NR }, { label: e("Toggle the upper–roman list style"), tooltip: e("Upper-roman"), type: "upper-roman", icon: zR }, { label: e("Toggle the lower–latin list style"), tooltip: e("Lower-latin"), type: "lower-latin", icon: PR }, { label: e("Toggle the upper–latin list style"), tooltip: e("Upper-latin"), type: "upper-latin", icon: OR }] })) } } } function UR({ editor: t, parentCommandName: e, buttonLabel: n, buttonIcon: i, styleGridAriaLabel: o, styleDefinitions: r }) { const s = t.commands.get(e); return a => { const c = Dv(a, YC); const l = c.buttonView; c.bind("isEnabled").to(s); c.class = "ck-list-styles-dropdown"; l.on("execute", (() => { t.execute(e); t.editing.view.focus() })); l.set({ label: n, icon: i, tooltip: true, isToggleable: true }); l.bind("isOn").to(s, "value", (t => !!t)); c.once("change:isOpen", (() => { const n = qR({ editor: t, dropdownView: c, parentCommandName: e, styleGridAriaLabel: o, styleDefinitions: r }); c.panelView.children.add(n) })); c.on("execute", (() => { t.editing.view.focus() })); return c } } function WR({ editor: t, listStyleCommand: e, parentCommandName: n }) { const i = t.locale; const o = t.commands.get(n); return ({ label: n, type: r, icon: s, tooltip: a }) => { const c = new wC(i); c.set({ label: n, icon: s, tooltip: a }); e.on("change:value", (() => { c.isOn = e.value === r })); c.on("execute", (() => { if (o.value) { if (e.value !== r) { t.execute("listStyle", { type: r }) } else { t.execute("listStyle", { type: e.defaultType }) } } else { t.model.change((() => { t.execute("listStyle", { type: r }) })) } })); return c } } function qR({ editor: t, dropdownView: e, parentCommandName: n, styleDefinitions: i, styleGridAriaLabel: o }) { const r = t.locale; const s = t.config.get("list.properties"); let a = null; if (n != "numberedList") { s.startIndex = false; s.reversed = false } if (s.styles) { const e = t.commands.get("listStyle"); const o = WR({ editor: t, parentCommandName: n, listStyleCommand: e }); const r = typeof e.isStyleTypeSupported == "function" ? t => e.isStyleTypeSupported(t.type) : () => true; a = i.filter(r).map(o) } const c = new SR(r, { styleGridAriaLabel: o, enabledProperties: s, styleButtonViews: a }); if (s.styles) { Bv(e, (() => c.stylesView.children.find((t => t.isOn)))) } if (s.startIndex) { const e = t.commands.get("listStart"); c.startIndexFieldView.bind("isEnabled").to(e); c.startIndexFieldView.fieldView.bind("value").to(e); c.on("listStart", ((e, n) => t.execute("listStart", n))) } if (s.reversed) { const e = t.commands.get("listReversed"); c.reversedSwitchButtonView.bind("isEnabled").to(e); c.reversedSwitchButtonView.bind("isOn").to(e, "value", (t => !!t)); c.on("listReversed", (() => { const n = e.value; t.execute("listReversed", { reversed: !n }) })) } c.delegate("execute").to(e); return c } class GR extends wl { static get requires() { return [sR, HR] } static get pluginName() { return "ListProperties" } } function $R(t, e) { const n = (n, i, o) => { if (!o.consumable.consume(i.item, n.name)) { return } const r = i.attributeNewValue; const s = o.writer; const a = o.mapper.toViewElement(i.item); const c = [...a.getChildren()].find((t => t.getCustomProperty("media-content"))); s.remove(c); const l = t.getMediaViewElement(s, r, e); s.insert(s.createPositionAt(a, 0), l) }; return t => { t.on("attribute:url:media", n) } } function KR(t, e, n) { e.setCustomProperty("media", true, t); return kD(t, e, { label: n }) } function YR(t) { const e = t.getSelectedElement(); if (e && QR(e)) { return e } return null } function QR(t) { return !!t.getCustomProperty("media") && bD(t) } function ZR(t, e, n, i) { return t.createContainerElement("figure", { class: "media" }, [e.getMediaViewElement(t, n, i), t.createSlot()]) } function JR(t) { const e = t.getSelectedElement(); if (e && e.is("element", "media")) { return e } return null } function XR(t, e, n, i) { t.change((o => { const r = o.createElement("media", { url: e }); t.insertObject(r, n, null, { setSelection: "on", findOptimalPosition: i ? "auto" : undefined }) })) } class tV extends _l { refresh() { const t = this.editor.model; const e = t.document.selection; const n = JR(e); this.value = n ? n.getAttribute("url") : undefined; this.isEnabled = nV(e) || eV(e, t) } execute(t) { const e = this.editor.model; const n = e.document.selection; const i = JR(n); if (i) { e.change((e => { e.setAttribute("url", t, i) })) } else { XR(e, t, n, true) } } } function eV(t, e) { const n = xD(t, e); let i = n.start.parent; if (i.isEmpty && !e.schema.isLimit(i)) { i = i.parent } return e.schema.checkChild(i, "media") } function nV(t) { const e = t.getSelectedElement(); return !!e && e.name === "media" } const iV = '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>'; const oV = "0 0 64 42"; class rV { constructor(t, e) { const n = e.providers; const i = e.extraProviders || []; const o = new Set(e.removeProviders); const r = n.concat(i).filter((t => { const e = t.name; if (!e) { M("media-embed-no-provider-name", { provider: t }); return false } return !o.has(e) })); this.locale = t; this.providerDefinitions = r } hasMedia(t) { return !!this._getMedia(t) } getMediaViewElement(t, e, n) { return this._getMedia(e).getViewElement(t, n) } _getMedia(t) { if (!t) { return new sV(this.locale) } t = t.trim(); for (const e of this.providerDefinitions) { const n = e.html; const i = $c(e.url); for (const e of i) { const i = this._getUrlMatches(t, e); if (i) { return new sV(this.locale, t, i, n) } } } return null } _getUrlMatches(t, e) { let n = t.match(e); if (n) { return n } let i = t.replace(/^https?:\/\//, ""); n = i.match(e); if (n) { return n } i = i.replace(/^www\./, ""); n = i.match(e); if (n) { return n } return null } } class sV { constructor(t, e, n, i) { this.url = this._getValidUrl(e); this._locale = t; this._match = n; this._previewRenderer = i } getViewElement(t, e) { const n = {}; let i; if (e.renderForEditingView || e.renderMediaPreview && this.url && this._previewRenderer) { if (this.url) { n["data-oembed-url"] = this.url } if (e.renderForEditingView) { n.class = "ck-media__wrapper" } const o = this._getPreviewHtml(e); i = t.createRawElement("div", n, ((t, e) => { e.setContentOf(t, o) })) } else { if (this.url) { n.url = this.url } i = t.createEmptyElement(e.elementName, n) } t.setCustomProperty("media-content", true, i); return i } _getPreviewHtml(t) { if (this._previewRenderer) { return this._previewRenderer(this._match) } else { if (this.url && t.renderForEditingView) { return this._getPlaceholderHtml() } return "" } } _getPlaceholderHtml() { const t = new mC; const e = this._locale.t; t.content = iV; t.viewBox = oV; const n = new P_({ tag: "div", attributes: { class: "ck ck-reset_all ck-media__placeholder" }, children: [{ tag: "div", attributes: { class: "ck-media__placeholder__icon" }, children: [t] }, { tag: "a", attributes: { class: "ck-media__placeholder__url", target: "_blank", rel: "noopener noreferrer", href: this.url, "data-cke-tooltip-text": e("Open media in new tab") }, children: [{ tag: "span", attributes: { class: "ck-media__placeholder__url__text" }, children: [this.url] }] }] }).render(); return n.outerHTML } _getValidUrl(t) { if (!t) { return null } if (t.match(/^https?/)) { return t } return "https://" + t } } var aV = n(952); var cV = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; cV.insert = "head"; cV.singleton = true; var lV = Sl()(aV.Z, cV); const dV = aV.Z.locals || {}; class uV extends wl { static get pluginName() { return "MediaEmbedEditing" } constructor(t) { super(t); t.config.define("mediaEmbed", { elementName: "oembed", providers: [{ name: "dailymotion", url: /^dailymotion\.com\/video\/(\w+)/, html: t => { const e = t[1]; return '<div style="position: relative; padding-bottom: 100%; height: 0; ">' + `<iframe src="https://www.dailymotion.com/embed/video/${e}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" width="480" height="270" allowfullscreen allow="autoplay">' + "</iframe>" + "</div>" } }, { name: "spotify", url: [/^open\.spotify\.com\/(artist\/\w+)/, /^open\.spotify\.com\/(album\/\w+)/, /^open\.spotify\.com\/(track\/\w+)/], html: t => { const e = t[1]; return '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;">' + `<iframe src="https://open.spotify.com/embed/${e}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" allowtransparency="true" allow="encrypted-media">' + "</iframe>" + "</div>" } }, { name: "youtube", url: [/^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)(?:&t=(\d+))?/, /^(?:m\.)?youtube\.com\/v\/([\w-]+)(?:\?t=(\d+))?/, /^youtube\.com\/embed\/([\w-]+)(?:\?start=(\d+))?/, /^youtu\.be\/([\w-]+)(?:\?t=(\d+))?/], html: t => { const e = t[1]; const n = t[2]; return '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;">' + `<iframe src="https://www.youtube.com/embed/${e}${n ? `?start=${n}` : ""}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>' + "</iframe>" + "</div>" } }, { name: "vimeo", url: [/^vimeo\.com\/(\d+)/, /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/channels\/[^/]+\/(\d+)/, /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/, /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/, /^player\.vimeo\.com\/video\/(\d+)/], html: t => { const e = t[1]; return '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;">' + `<iframe src="https://player.vimeo.com/video/${e}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen>' + "</iframe>" + "</div>" } }, { name: "instagram", url: /^instagram\.com\/p\/(\w+)/ }, { name: "twitter", url: /^twitter\.com/ }, { name: "googleMaps", url: [/^google\.com\/maps/, /^goo\.gl\/maps/, /^maps\.google\.com/, /^maps\.app\.goo\.gl/] }, { name: "flickr", url: /^flickr\.com/ }, { name: "facebook", url: /^facebook\.com/ }] }); this.registry = new rV(t.locale, t.config.get("mediaEmbed")) } init() { const t = this.editor; const e = t.model.schema; const n = t.t; const i = t.conversion; const o = t.config.get("mediaEmbed.previewsInData"); const r = t.config.get("mediaEmbed.elementName"); const s = this.registry; t.commands.add("mediaEmbed", new tV(t)); e.register("media", { inheritAllFrom: "$blockObject", allowAttributes: ["url"] }); i.for("dataDowncast").elementToStructure({ model: "media", view: (t, { writer: e }) => { const n = t.getAttribute("url"); return ZR(e, s, n, { elementName: r, renderMediaPreview: !!n && o }) } }); i.for("dataDowncast").add($R(s, { elementName: r, renderMediaPreview: o })); i.for("editingDowncast").elementToStructure({ model: "media", view: (t, { writer: e }) => { const i = t.getAttribute("url"); const o = ZR(e, s, i, { elementName: r, renderForEditingView: true }); return KR(o, e, n("media widget")) } }); i.for("editingDowncast").add($R(s, { elementName: r, renderForEditingView: true })); i.for("upcast").elementToElement({ view: t => ["oembed", r].includes(t.name) && t.getAttribute("url") ? { name: true } : null, model: (t, { writer: e }) => { const n = t.getAttribute("url"); if (s.hasMedia(n)) { return e.createElement("media", { url: n }) } return null } }).elementToElement({ view: { name: "div", attributes: { "data-oembed-url": true } }, model: (t, { writer: e }) => { const n = t.getAttribute("data-oembed-url"); if (s.hasMedia(n)) { return e.createElement("media", { url: n }) } return null } }).add((t => { const e = (t, e, n) => { if (!n.consumable.consume(e.viewItem, { name: true, classes: "media" })) { return } const { modelRange: i, modelCursor: o } = n.convertChildren(e.viewItem, e.modelCursor); e.modelRange = i; e.modelCursor = o; const r = ol(i.getItems()); if (!r) { n.consumable.revert(e.viewItem, { name: true, classes: "media" }) } }; t.on("element:figure", e) })) } } const hV = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/; class gV extends wl { static get requires() { return [US, xE, XS] } static get pluginName() { return "AutoMediaEmbed" } constructor(t) { super(t); this._timeoutId = null; this._positionToInsert = null } init() { const t = this.editor; const e = t.model.document; const n = t.plugins.get("ClipboardPipeline"); this.listenTo(n, "inputTransformation", (() => { const t = e.selection.getFirstRange(); const n = Vk.fromPosition(t.start); n.stickiness = "toPrevious"; const i = Vk.fromPosition(t.end); i.stickiness = "toNext"; e.once("change:data", (() => { this._embedMediaBetweenPositions(n, i); n.detach(); i.detach() }), { priority: "high" }) })); const i = t.commands.get("undo"); i.on("execute", (() => { if (this._timeoutId) { Za.window.clearTimeout(this._timeoutId); this._positionToInsert.detach(); this._timeoutId = null; this._positionToInsert = null } }), { priority: "high" }) } _embedMediaBetweenPositions(t, e) { const n = this.editor; const i = n.plugins.get(uV).registry; const o = new jf(t, e); const r = o.getWalker({ ignoreElementEnd: true }); let s = ""; for (const t of r) { if (t.item.is("$textProxy")) { s += t.item.data } } s = s.trim(); if (!s.match(hV)) { o.detach(); return } if (!i.hasMedia(s)) { o.detach(); return } const a = n.commands.get("mediaEmbed"); if (!a.isEnabled) { o.detach(); return } this._positionToInsert = Vk.fromPosition(t); this._timeoutId = Za.window.setTimeout((() => { n.model.change((t => { this._timeoutId = null; t.remove(o); o.detach(); let e = null; if (this._positionToInsert.root.rootName !== "$graveyard") { e = this._positionToInsert } XR(n.model, s, e, false); this._positionToInsert.detach(); this._positionToInsert = null })); n.plugins.get(xE).requestUndoOnBackspace() }), 100) } } var mV = n(3525); var fV = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; fV.insert = "head"; fV.singleton = true; var pV = Sl()(mV.Z, fV); const bV = mV.Z.locals || {}; class kV extends N_ { constructor(t, e) { super(e); const n = e.t; this.focusTracker = new rl; this.keystrokes = new sl; this.set("mediaURLInputValue", ""); this.urlInputView = this._createUrlInput(); this.saveButtonView = this._createButton(n("Save"), v_.check, "ck-button-save"); this.saveButtonView.type = "submit"; this.saveButtonView.bind("isEnabled").to(this, "mediaURLInputValue", (t => !!t)); this.cancelButtonView = this._createButton(n("Cancel"), v_.cancel, "ck-button-cancel", "cancel"); this._focusables = new S_; this._focusCycler = new QC({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }); this._validators = t; this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-media-form", "ck-responsive-form"], tabindex: "-1" }, children: [this.urlInputView, this.saveButtonView, this.cancelButtonView] }) } render() { super.render(); E_({ view: this }); const t = [this.urlInputView, this.saveButtonView, this.cancelButtonView]; t.forEach((t => { this._focusables.add(t); this.focusTracker.add(t.element) })); this.keystrokes.listenTo(this.element); const e = t => t.stopPropagation(); this.keystrokes.set("arrowright", e); this.keystrokes.set("arrowleft", e); this.keystrokes.set("arrowup", e); this.keystrokes.set("arrowdown", e); this.listenTo(this.urlInputView.element, "selectstart", ((t, e) => { e.stopPropagation() }), { priority: "high" }) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } focus() { this._focusCycler.focusFirst() } get url() { return this.urlInputView.fieldView.element.value.trim() } set url(t) { this.urlInputView.fieldView.element.value = t.trim() } isValid() { this.resetFormStatus(); for (const t of this._validators) { const e = t(this); if (e) { this.urlInputView.errorText = e; return false } } return true } resetFormStatus() { this.urlInputView.errorText = null; this.urlInputView.infoText = this._urlInputViewInfoDefault } _createUrlInput() { const t = this.locale.t; const e = new Py(this.locale, Oy); const n = e.fieldView; this._urlInputViewInfoDefault = t("Paste the media URL in the input."); this._urlInputViewInfoTip = t("Tip: Paste the URL into the content to embed faster."); e.label = t("Media URL"); e.infoText = this._urlInputViewInfoDefault; n.on("input", (() => { e.infoText = n.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault; this.mediaURLInputValue = n.element.value.trim() })); return e } _createButton(t, e, n, i) { const o = new wC(this.locale); o.set({ label: t, icon: e, tooltip: true }); o.extendTemplate({ attributes: { class: n } }); if (i) { o.delegate("execute").to(this, i) } return o } } const wV = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18.68 3.03c.6 0 .59-.03.59.55v12.84c0 .59.01.56-.59.56H1.29c-.6 0-.59.03-.59-.56V3.58c0-.58-.01-.55.6-.55h17.38zM15.77 15V5H4.2v10h11.57zM2 4v1h1V4H2zm0 2v1h1V6H2zm0 2v1h1V8H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zM17 4v1h1V4h-1zm0 2v1h1V6h-1zm0 2v1h1V8h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zM7.5 7.177a.4.4 0 0 1 .593-.351l5.133 2.824a.4.4 0 0 1 0 .7l-5.133 2.824a.4.4 0 0 1-.593-.35V7.176v.001z"/></svg>'; class AV extends wl { static get requires() { return [uV] } static get pluginName() { return "MediaEmbedUI" } init() { const t = this.editor; const e = t.commands.get("mediaEmbed"); t.ui.componentFactory.add("mediaEmbed", (t => { const n = Dv(t); this._setUpDropdown(n, e); return n })) } _setUpDropdown(t, e) { const n = this.editor; const i = n.t; const o = t.buttonView; const r = n.plugins.get(uV).registry; t.once("change:isOpen", (() => { const i = new (x_(kV))(_V(n.t, r), n.locale); t.panelView.children.add(i); o.on("open", (() => { i.disableCssTransitions(); i.url = e.value || ""; i.urlInputView.fieldView.select(); i.enableCssTransitions() }), { priority: "low" }); t.on("submit", (() => { if (i.isValid()) { n.execute("mediaEmbed", i.url); n.editing.view.focus() } })); t.on("change:isOpen", (() => i.resetFormStatus())); t.on("cancel", (() => { n.editing.view.focus() })); i.delegate("submit", "cancel").to(t); i.urlInputView.fieldView.bind("value").to(e, "value"); i.urlInputView.bind("isEnabled").to(e, "isEnabled") })); t.bind("isEnabled").to(e); o.set({ label: i("Insert media"), icon: wV, tooltip: true }) } } function _V(t, e) { return [e => { if (!e.url.length) { return t("The URL must not be empty.") } }, n => { if (!e.hasMedia(n.url)) { return t("This media URL is not supported.") } }] } var CV = n(5777); var vV = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; vV.insert = "head"; vV.singleton = true; var yV = Sl()(CV.Z, vV); const xV = CV.Z.locals || {}; class EV extends wl { static get requires() { return [uV, AV, gV, oS] } static get pluginName() { return "MediaEmbed" } } class DV extends wl { static get requires() { return [aS] } static get pluginName() { return "MediaEmbedToolbar" } afterInit() { const t = this.editor; const e = t.t; const n = t.plugins.get(aS); n.register("mediaEmbed", { ariaLabel: e("Media toolbar"), items: t.config.get("mediaEmbed.toolbar") || [], getRelatedElement: YR }) } } class SV extends _l { refresh() { const t = this.editor.model; const e = t.document; this.isEnabled = t.schema.checkAttributeInSelection(e.selection, "mention") } execute(t) { const e = this.editor.model; const n = e.document; const i = n.selection; const o = typeof t.mention == "string" ? { id: t.mention } : t.mention; const r = o.id; const s = t.range || i.getFirstRange(); const a = t.text || r; const c = IV({ _text: a, id: r }, o); if (t.marker.length != 1) { throw new I("mentioncommand-incorrect-marker", this) } if (r.charAt(0) != t.marker) { throw new I("mentioncommand-incorrect-id", this) } e.change((t => { const n = cl(i.getAttributes()); const o = new Map(n.entries()); o.set("mention", c); e.insertContent(t.createText(a, o), s); e.insertContent(t.createText(" ", n), s.start.getShiftedBy(a.length)) })) } } class TV extends wl { static get pluginName() { return "MentionEditing" } init() { const t = this.editor; const e = t.model; const n = e.document; e.schema.extend("$text", { allowAttributes: "mention" }); t.conversion.for("upcast").elementToAttribute({ view: { name: "span", key: "data-mention", classes: "mention" }, model: { key: "mention", value: t => MV(t) } }); t.conversion.for("downcast").attributeToElement({ model: "mention", view: LV }); t.conversion.for("downcast").add(BV); n.registerPostFixer((t => PV(t, n, e.schema))); n.registerPostFixer((t => OV(t, n))); n.registerPostFixer((t => NV(t, n))); t.commands.add("mention", new SV(t)) } } function IV(t, e) { return Object.assign({ uid: x() }, t, e || {}) } function MV(t, e) { const n = t.getAttribute("data-mention"); const i = t.getChild(0); if (!i) { return } const o = { id: n, _text: i.data }; return IV(o, e) } function BV(t) { t.on("attribute:mention", ((t, e, n) => { const i = e.attributeNewValue; if (!e.item.is("$textProxy") || !i) { return } const o = e.range.start; const r = o.textNode || o.nodeAfter; if (r.data != i._text) { n.consumable.consume(e.item, t.name) } }), { priority: "highest" }) } function LV(t, { writer: e }) { if (!t) { return } const n = { class: "mention", "data-mention": t.id }; const i = { id: t.uid, priority: 20 }; return e.createAttributeElement("span", n, i) } function NV(t, e) { const n = e.selection; const i = n.focus; if (n.isCollapsed && n.hasAttribute("mention") && zV(i)) { t.removeSelectionAttribute("mention"); return true } return false } function zV(t) { const e = t.isAtStart; const n = t.nodeBefore && t.nodeBefore.is("$text"); return n || e } function PV(t, e, n) { const i = e.differ.getChanges(); let o = false; for (const e of i) { if (e.type == "attribute") { continue } const i = e.position; if (e.name == "$text") { const e = i.textNode && i.textNode.nextSibling; o = VV(i.textNode, t) || o; o = VV(e, t) || o; o = VV(i.nodeBefore, t) || o; o = VV(i.nodeAfter, t) || o } if (e.name != "$text" && e.type == "insert") { const e = i.nodeAfter; for (const n of t.createRangeIn(e).getItems()) { o = VV(n, t) || o } } if (e.type == "insert" && n.isInline(e.name)) { const e = i.nodeAfter && i.nodeAfter.nextSibling; o = VV(i.nodeBefore, t) || o; o = VV(e, t) || o } } return o } function OV(t, e) { const n = e.differ.getChanges(); let i = false; for (const e of n) { if (e.type === "attribute" && e.attributeKey != "mention") { const n = e.range.start.nodeBefore; const o = e.range.end.nodeAfter; for (const r of [n, o]) { if (RV(r) && r.getAttribute(e.attributeKey) != e.attributeNewValue) { t.setAttribute(e.attributeKey, e.attributeNewValue, r); i = true } } } } return i } function RV(t) { if (!t || !(t.is("$text") || t.is("$textProxy")) || !t.hasAttribute("mention")) { return false } const e = t.data; const n = t.getAttribute("mention"); const i = n._text; return e != i } function VV(t, e) { if (RV(t)) { e.removeAttribute("mention", t); return true } return false } var jV = n(6391); var FV = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; FV.insert = "head"; FV.singleton = true; var HV = Sl()(jV.Z, FV); const UV = jV.Z.locals || {}; class WV extends pv { constructor(t) { super(t); this.extendTemplate({ attributes: { class: ["ck-mentions"], tabindex: "-1" } }) } selectFirst() { this.select(0) } selectNext() { const t = this.selected; const e = this.items.getIndex(t); this.select(e + 1) } selectPrevious() { const t = this.selected; const e = this.items.getIndex(t); this.select(e - 1) } select(t) { let e = 0; if (t > 0 && t < this.items.length) { e = t } else if (t < 0) { e = this.items.length - 1 } const n = this.items.get(e); if (this.selected === n) { return } if (this.selected) { this.selected.removeHighlight() } n.highlight(); this.selected = n; if (!this._isItemVisibleInScrolledArea(n)) { this.element.scrollTop = n.element.offsetTop } } executeSelected() { this.selected.fire("execute") } _isItemVisibleInScrolledArea(t) { return new oc(this.element).contains(new oc(t.element)) } } class qV extends N_ { constructor(t, e) { super(t); this.template = undefined; this.domElement = e; this.domElement.classList.add("ck-button"); this.set("isOn", false); this.on("change:isOn", ((t, e, n) => { if (n) { this.domElement.classList.add("ck-on"); this.domElement.classList.remove("ck-off") } else { this.domElement.classList.add("ck-off"); this.domElement.classList.remove("ck-on") } })); this.listenTo(this.domElement, "click", (() => { this.fire("execute") })) } render() { super.render(); this.element = this.domElement } } class GV extends bv { highlight() { const t = this.children.first; t.isOn = true } removeHighlight() { const t = this.children.first; t.isOn = false } } const $V = 3; const KV = [Pc.arrowup, Pc.arrowdown, Pc.esc]; const YV = [Pc.enter, Pc.tab]; class QV extends wl { static get pluginName() { return "MentionUI" } static get requires() { return [Xy] } constructor(t) { super(t); this._items = new il; this._mentionsView = this._createMentionView(); this._mentionsConfigurations = new Map; this._requestFeedDebounced = Yg(this._requestFeed, 100); t.config.define("mention", { feeds: [] }) } init() { const t = this.editor; const e = t.config.get("mention.commitKeys") || YV; const n = KV.concat(e); this._balloon = t.plugins.get(Xy); t.editing.view.document.on("keydown", ((t, n) => { if (o(n.keyCode) && this._isUIVisible) { n.preventDefault(); t.stop(); if (n.keyCode == Pc.arrowdown) { this._mentionsView.selectNext() } if (n.keyCode == Pc.arrowup) { this._mentionsView.selectPrevious() } if (e.includes(n.keyCode)) { this._mentionsView.executeSelected() } if (n.keyCode == Pc.esc) { this._hideUIAndRemoveMarker() } } }), { priority: "highest" }); y_({ emitter: this._mentionsView, activator: () => this._isUIVisible, contextElements: () => [this._balloon.view.element], callback: () => this._hideUIAndRemoveMarker() }); const i = t.config.get("mention.feeds"); for (const t of i) { const { feed: e, marker: n, dropdownLimit: i } = t; if (!rj(n)) { throw new I("mentionconfig-incorrect-marker", null, { marker: n }) } const o = typeof e == "function" ? e.bind(this.editor) : nj(e); const r = t.itemRenderer; const s = { marker: n, feedCallback: o, itemRenderer: r, dropdownLimit: i }; this._mentionsConfigurations.set(n, s) } this._setupTextWatcher(i); this.listenTo(t, "change:isReadOnly", (() => { this._hideUIAndRemoveMarker() })); this.on("requestFeed:response", ((t, e) => this._handleFeedResponse(e))); this.on("requestFeed:error", (() => this._hideUIAndRemoveMarker())); function o(t) { return n.includes(t) } } destroy() { super.destroy(); this._mentionsView.destroy() } get _isUIVisible() { return this._balloon.visibleView === this._mentionsView } _createMentionView() { const t = this.editor.locale; const e = new WV(t); e.items.bindTo(this._items).using((n => { const { item: i, marker: o } = n; const { dropdownLimit: r } = this._mentionsConfigurations.get(o); const s = r || this.editor.config.get("mention.dropdownLimit") || 10; if (e.items.length >= s) { return null } const a = new GV(t); const c = this._renderItem(i, o); c.delegate("execute").to(a); a.children.add(c); a.item = i; a.marker = o; a.on("execute", (() => { e.fire("execute", { item: i, marker: o }) })); return a })); e.on("execute", ((t, e) => { const n = this.editor; const i = n.model; const o = e.item; const r = e.marker; const s = n.model.markers.get("mention"); const a = i.createPositionAt(i.document.selection.focus); const c = i.createPositionAt(s.getStart()); const l = i.createRange(c, a); this._hideUIAndRemoveMarker(); n.execute("mention", { mention: o, text: o.text, marker: r, range: l }); n.editing.view.focus() })); return e } _getItemRenderer(t) { const { itemRenderer: e } = this._mentionsConfigurations.get(t); return e } _requestFeed(t, e) { this._lastRequested = e; const { feedCallback: n } = this._mentionsConfigurations.get(t); const i = n(e); const o = i instanceof Promise; if (!o) { this.fire("requestFeed:response", { feed: i, marker: t, feedText: e }); return } i.then((n => { if (this._lastRequested == e) { this.fire("requestFeed:response", { feed: n, marker: t, feedText: e }) } else { this.fire("requestFeed:discarded", { feed: n, marker: t, feedText: e }) } })).catch((e => { this.fire("requestFeed:error", { error: e }); M("mention-feed-callback-error", { marker: t }) })) } _setupTextWatcher(t) { const e = this.editor; const n = t.map((t => ({ ...t, pattern: XV(t.marker, t.minimumCharacters || 0) }))); const i = new SE(e.model, tj(n)); i.on("matched", ((t, i) => { const o = JV(n, i.text); const r = e.model.document.selection; const s = r.focus; const a = e.model.createPositionAt(s.parent, o.position); if (ij(s) || oj(a)) { this._hideUIAndRemoveMarker(); return } const c = ej(o, i.text); const l = o.marker.length + c.length; const d = s.getShiftedBy(-l); const u = s.getShiftedBy(-c.length); const h = e.model.createRange(d, u); if (sj(e)) { const t = e.model.markers.get("mention"); e.model.change((e => { e.updateMarker(t, { range: h }) })) } else { e.model.change((t => { t.addMarker("mention", { range: h, usingOperation: false, affectsData: false }) })) } this._requestFeedDebounced(o.marker, c) })); i.on("unmatched", (() => { this._hideUIAndRemoveMarker() })); const o = e.commands.get("mention"); i.bind("isEnabled").to(o); return i } _handleFeedResponse(t) { const { feed: e, marker: n } = t; if (!sj(this.editor)) { return } this._items.clear(); for (const t of e) { const e = typeof t != "object" ? { id: t, text: t } : t; this._items.add({ item: e, marker: n }) } const i = this.editor.model.markers.get("mention"); if (this._items.length) { this._showOrUpdateUI(i) } else { this._hideUIAndRemoveMarker() } } _showOrUpdateUI(t) { if (this._isUIVisible) { this._balloon.updatePosition(this._getBalloonPanelPositionData(t, this._mentionsView.position)) } else { this._balloon.add({ view: this._mentionsView, position: this._getBalloonPanelPositionData(t, this._mentionsView.position), singleViewMode: true }) } this._mentionsView.position = this._balloon.view.position; this._mentionsView.selectFirst() } _hideUIAndRemoveMarker() { if (this._balloon.hasView(this._mentionsView)) { this._balloon.remove(this._mentionsView) } if (sj(this.editor)) { this.editor.model.change((t => t.removeMarker("mention"))) } this._mentionsView.position = undefined } _renderItem(t, e) { const n = this.editor; let i; let o = t.id; const r = this._getItemRenderer(e); if (r) { const e = r(t); if (typeof e != "string") { i = new qV(n.locale, e) } else { o = e } } if (!i) { const t = new wC(n.locale); t.label = o; t.withText = true; i = t } return i } _getBalloonPanelPositionData(t, e) { const n = this.editor; const i = n.editing; const o = i.view.domConverter; const r = i.mapper; const s = n.locale.uiLanguageDirection; return { target: () => { let e = t.getRange(); if (e.start.root.rootName == "$graveyard") { e = n.model.document.selection.getFirstRange() } const i = r.toViewRange(e); const s = oc.getDomRangeRects(o.viewRangeToDom(i)); return s.pop() }, limiter: () => { const t = this.editor.editing.view; const e = t.document; const n = e.selection.editableElement; if (n) { return t.domConverter.mapViewToDom(n.root) } return null }, positions: ZV(e, s) } } } function ZV(t, e) { const n = { caret_se: t => ({ top: t.bottom + $V, left: t.right, name: "caret_se", config: { withArrow: false } }), caret_ne: (t, e) => ({ top: t.top - e.height - $V, left: t.right, name: "caret_ne", config: { withArrow: false } }), caret_sw: (t, e) => ({ top: t.bottom + $V, left: t.right - e.width, name: "caret_sw", config: { withArrow: false } }), caret_nw: (t, e) => ({ top: t.top - e.height - $V, left: t.right - e.width, name: "caret_nw", config: { withArrow: false } }) }; if (Object.prototype.hasOwnProperty.call(n, t)) { return [n[t]] } return e !== "rtl" ? [n.caret_se, n.caret_sw, n.caret_ne, n.caret_nw] : [n.caret_sw, n.caret_se, n.caret_nw, n.caret_ne] } function JV(t, e) { let n; for (const i of t) { const t = e.lastIndexOf(i.marker); if (t > 0 && !e.substring(t - 1).match(i.pattern)) { continue } if (!n || t >= n.position) { n = { marker: i.marker, position: t, minimumCharacters: i.minimumCharacters, pattern: i.pattern } } } return n } function XV(t, e) { const n = e == 0 ? "*" : `{${e},}`; const i = r.features.isRegExpUnicodePropertySupported ? "\\p{Ps}\\p{Pi}\"'" : "\\(\\[{\"'"; const o = "."; const s = `(?:^|[ ${i}])([${t}])(${o}${n})$`; return new RegExp(s, "u") } function tj(t) { const e = e => { const n = JV(t, e); if (!n) { return false } let i = 0; if (n.position !== 0) { i = n.position - 1 } const o = e.substring(i); return n.pattern.test(o) }; return e } function ej(t, e) { let n = 0; if (t.position !== 0) { n = t.position - 1 } const i = XV(t.marker, 0); const o = e.substring(n); const r = o.match(i); return r[2] } function nj(t) { return e => { const n = t.filter((t => { const n = typeof t == "string" ? t : String(t.id); return n.toLowerCase().includes(e.toLowerCase()) })); return n } } function ij(t) { const e = t.textNode && t.textNode.hasAttribute("mention"); const n = t.nodeBefore; return e || n && n.is("$text") && n.hasAttribute("mention") } function oj(t) { const e = t.nodeAfter; return e && e.is("$text") && e.hasAttribute("mention") } function rj(t) { return t && t.length == 1 } function sj(t) { return t.model.markers.has("mention") } var aj = n(7583); var cj = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; cj.insert = "head"; cj.singleton = true; var lj = Sl()(aj.Z, cj); const dj = aj.Z.locals || {}; class uj extends wl { toMentionAttribute(t, e) { return MV(t, e) } static get pluginName() { return "Mention" } static get requires() { return [TV, QV] } } function hj(t, e) { for (const n of t.getChildren()) { if (n.is("element", "b") && n.getStyle("font-weight") === "normal") { const i = t.getChildIndex(n); e.remove(n); e.insertChild(i, n.getChildren(), t) } } } function gj(t, e) { const n = new ph(e.document.stylesProcessor); const i = new kg(n, { renderingMode: "data" }); const o = i.blockElements; const r = i.inlineObjectElements; const s = []; for (const n of e.createRangeIn(t)) { const t = n.item; if (t.is("element", "br")) { const n = mj(t, "forward", e, { blockElements: o, inlineObjectElements: r }); const i = mj(t, "backward", e, { blockElements: o, inlineObjectElements: r }); const a = fj(n, o); const c = fj(i, o); if (c || a) { s.push(t) } } } for (const t of s) { if (t.hasClass("Apple-interchange-newline")) { e.remove(t) } else { e.replace(t, e.createElement("p")) } } } function mj(t, e, n, { blockElements: i, inlineObjectElements: o }) { let r = n.createPositionAt(t, e == "forward" ? "after" : "before"); r = r.getLastMatchingPosition((({ item: t }) => t.is("element") && !i.includes(t.name) && !o.includes(t.name)), { direction: e }); return e == "forward" ? r.nodeAfter : r.nodeBefore } function fj(t, e) { return !!t && t.is("element") && e.includes(t.name) } function pj(t, e) { if (!t.childCount) { return } const n = new Uw(t.document); const i = kj(t, n); if (!i.length) { return } let o = null; let r = 1; i.forEach(((t, s) => { const a = Dj(i[s - 1], t); const c = a ? null : i[s - 1]; const l = Tj(c, t); if (a) { o = null; r = 1 } if (!o || l !== 0) { const i = wj(t, e); if (!o) { o = vj(i, t.element, n) } else if (t.indent > r) { const t = o.getChild(o.childCount - 1); const e = t.getChild(t.childCount - 1); o = vj(i, e, n); r += 1 } else if (t.indent < r) { const e = r - t.indent; o = Ij(o, e); r = t.indent } if (t.indent <= r) { if (!o.is("element", i.type)) { o = n.rename(i.type, o) } } } const d = yj(t.element, n); n.appendChild(d, o) })) } function bj(t, e) { for (const n of e.createRangeIn(t)) { const t = n.item; if (t.is("element", "li")) { const n = t.getChild(0); if (n && n.is("element", "p")) { e.unwrapElement(n) } } } } function kj(t, e) { const n = e.createRangeIn(t); const i = new Yl({ name: /^p|h\d+$/, styles: { "mso-list": /.*/ } }); const o = []; for (const t of n) { if (t.type === "elementStart" && i.match(t.item)) { const e = xj(t.item); o.push({ element: t.item, id: e.id, order: e.order, indent: e.indent }) } } return o } function wj(t, e) { const n = new RegExp(`@list l${t.id}:level${t.indent}\\s*({[^}]*)`, "gi"); const i = /mso-level-number-format:([^;]{0,100});/gi; const o = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi; const r = n.exec(e); let s = "decimal"; let a = "ol"; let c = null; if (r && r[1]) { const e = i.exec(r[1]); if (e && e[1]) { s = e[1].trim(); a = s !== "bullet" && s !== "image" ? "ol" : "ul" } if (s === "bullet") { const e = Aj(t.element); if (e) { s = e } } else { const t = o.exec(r[1]); if (t && t[1]) { c = parseInt(t[1]) } } } return { type: a, startIndex: c, style: Cj(s) } } function Aj(t) { const e = _j(t); if (!e) { return null } const n = e._data; if (n === "o") { return "circle" } else if (n === "·") { return "disc" } else if (n === "§") { return "square" } return null } function _j(t) { if (t.getChild(0).is("$text")) { return null } for (const e of t.getChildren()) { if (!e.is("element", "span")) { continue } const t = e.getChild(0); if (!t) { continue } if (t.is("$text")) { return t } return t.getChild(0) } return null } function Cj(t) { if (t.startsWith("arabic-leading-zero")) { return "decimal-leading-zero" } switch (t) { case "alpha-upper": return "upper-alpha"; case "alpha-lower": return "lower-alpha"; case "roman-upper": return "upper-roman"; case "roman-lower": return "lower-roman"; case "circle": case "disc": case "square": return t; default: return null } } function vj(t, e, n) { const i = e.parent; const o = n.createElement(t.type); const r = i.getChildIndex(e) + 1; n.insertChild(r, o, i); if (t.style) { n.setStyle("list-style-type", t.style, o) } if (t.startIndex && t.startIndex > 1) { n.setAttribute("start", t.startIndex, o) } return o } function yj(t, e) { Ej(t, e); return e.rename("li", t) } function xj(t) { const e = {}; const n = t.getStyle("mso-list"); if (n) { const t = n.match(/(^|\s{1,100})l(\d+)/i); const i = n.match(/\s{0,100}lfo(\d+)/i); const o = n.match(/\s{0,100}level(\d+)/i); if (t && i && o) { e.id = t[2]; e.order = i[1]; e.indent = parseInt(o[1]) } } return e } function Ej(t, e) { const n = new Yl({ name: "span", styles: { "mso-list": "Ignore" } }); const i = e.createRangeIn(t); for (const t of i) { if (t.type === "elementStart" && n.match(t.item)) { e.remove(t.item) } } } function Dj(t, e) { if (!t) { return true } if (t.id !== e.id) { if (e.indent - t.indent === 1) { return false } return true } const n = e.element.previousSibling; if (!n) { return true } return !Sj(n) } function Sj(t) { return t.is("element", "ol") || t.is("element", "ul") } function Tj(t, e) { return t ? e.indent - t.indent : e.indent - 1 } function Ij(t, e) { const n = t.getAncestors({ parentFirst: true }); let i = null; let o = 0; for (const t of n) { if (t.is("element", "ul") || t.is("element", "ol")) { o++ } if (o === e) { i = t; break } } return i } const Mj = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i; class Bj { constructor(t) { this.document = t } isActive(t) { return Mj.test(t) } execute(t) { const e = new Uw(this.document); const { body: n } = t._parsedData; hj(n, e); bj(n, e); gj(n, e); t.content = n } } function Lj(t, e) { if (!t.childCount) { return } const n = new Uw(t.document); const i = zj(t, n); Pj(i, t, n); Rj(i, t, n); Oj(t, n); const o = Vj(t, n); if (o.length) { Fj(o, jj(e), n) } } function Nj(t) { return btoa(t.match(/\w{2}/g).map((t => String.fromCharCode(parseInt(t, 16)))).join("")) } function zj(t, e) { const n = e.createRangeIn(t); const i = new Yl({ name: /v:(.+)/ }); const o = []; for (const t of n) { if (t.type != "elementStart") { continue } const e = t.item; const n = e.previousSibling; const r = n && n.is("element") ? n.name : null; if (i.match(e) && e.getAttribute("o:gfxdata") && r !== "v:shapetype") { o.push(t.item.getAttribute("id")) } } return o } function Pj(t, e, n) { const i = n.createRangeIn(e); const o = new Yl({ name: "img" }); const r = []; for (const e of i) { if (e.item.is("element") && o.match(e.item)) { const n = e.item; const i = n.getAttribute("v:shapes") ? n.getAttribute("v:shapes").split(" ") : []; if (i.length && i.every((e => t.indexOf(e) > -1))) { r.push(n) } else if (!n.getAttribute("src")) { r.push(n) } } } for (const t of r) { n.remove(t) } } function Oj(t, e) { const n = e.createRangeIn(t); const i = new Yl({ name: /v:(.+)/ }); const o = []; for (const t of n) { if (t.type == "elementStart" && i.match(t.item)) { o.push(t.item) } } for (const t of o) { e.remove(t) } } function Rj(t, e, n) { const i = n.createRangeIn(e); const o = []; for (const e of i) { if (e.type == "elementStart" && e.item.is("element", "v:shape")) { const n = e.item.getAttribute("id"); if (t.includes(n)) { continue } if (!r(e.item.parent.getChildren(), n)) { o.push(e.item) } } } for (const t of o) { const e = { src: s(t) }; if (t.hasAttribute("alt")) { e.alt = t.getAttribute("alt") } const i = n.createElement("img", e); n.insertChild(t.index + 1, i, t.parent) } function r(t, e) { for (const n of t) { if (n.is("element")) { if (n.name == "img" && n.getAttribute("v:shapes") == e) { return true } if (r(n.getChildren(), e)) { return true } } } return false } function s(t) { for (const e of t.getChildren()) { if (e.is("element") && e.getAttribute("src")) { return e.getAttribute("src") } } } } function Vj(t, e) { const n = e.createRangeIn(t); const i = new Yl({ name: "img" }); const o = []; for (const t of n) { if (t.item.is("element") && i.match(t.item)) { if (t.item.getAttribute("src").startsWith("file://")) { o.push(t.item) } } } return o } function jj(t) { if (!t) { return [] } const e = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/; const n = new RegExp("(?:(" + e.source + "))([\\da-fA-F\\s]+)\\}", "g"); const i = t.match(n); const o = []; if (i) { for (const t of i) { let n = false; if (t.includes("\\pngblip")) { n = "image/png" } else if (t.includes("\\jpegblip")) { n = "image/jpeg" } if (n) { o.push({ hex: t.replace(e, "").replace(/[^\da-fA-F]/g, ""), type: n }) } } } return o } function Fj(t, e, n) { if (t.length === e.length) { for (let i = 0; i < t.length; i++) { const o = `data:${e[i].type};base64,${Nj(e[i].hex)}`; n.setAttribute("src", o, t[i]) } } } const Hj = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i; const Uj = /xmlns:o="urn:schemas-microsoft-com/i; class Wj { constructor(t) { this.document = t } isActive(t) { return Hj.test(t) || Uj.test(t) } execute(t) { const { body: e, stylesString: n } = t._parsedData; pj(e, n); Lj(e, t.dataTransfer.getData("text/rtf")); t.content = e } } function qj(t) { return $j($j(t)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/ <\//g, " </").replace(/ <o:p><\/o:p>/g, " <o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><") } function Gj(t) { t.querySelectorAll("span[style*=spacerun]").forEach((t => { const e = t; const n = e.innerText.length || 0; e.innerText = Array(n + 1).join("  ").substr(0, n) })) } function $j(t) { return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, ((t, e) => e.length === 1 ? " " : Array(e.length + 1).join("  ").substr(0, e.length))) } function Kj(t, e) { const n = new DOMParser; t = t.replace(/<!--\[if gte vml 1]>/g, ""); const i = qj(Zj(t)); const o = n.parseFromString(i, "text/html"); Gj(o); const r = o.body.innerHTML; const s = Yj(o, e); const a = Qj(o); return { body: s, bodyString: r, styles: a.styles, stylesString: a.stylesString } } function Yj(t, e) { const n = new ph(e); const i = new kg(n, { renderingMode: "data" }); const o = t.createDocumentFragment(); const r = t.body.childNodes; while (r.length > 0) { o.appendChild(r[0]) } return i.domToView(o, { skipComments: true }) } function Qj(t) { const e = []; const n = []; const i = Array.from(t.getElementsByTagName("style")); for (const t of i) { if (t.sheet && t.sheet.cssRules && t.sheet.cssRules.length) { e.push(t.sheet); n.push(t.innerHTML) } } return { styles: e, stylesString: n.join(" ") } } function Zj(t) { const e = "</body>"; const n = "</html>"; const i = t.indexOf(e); if (i < 0) { return t } const o = t.indexOf(n, i + e.length); return t.substring(0, i + e.length) + (o >= 0 ? t.substring(o) : "") } class Jj extends wl { static get pluginName() { return "PasteFromOffice" } static get requires() { return [aE] } init() { const t = this.editor; const e = t.plugins.get("ClipboardPipeline"); const n = t.editing.view.document; const i = []; i.push(new Wj(n)); i.push(new Bj(n)); e.on("inputTransformation", ((e, o) => { if (o._isTransformedWithPasteFromOffice) { return } const r = t.model.document.selection.getFirstPosition().parent; if (r.is("element", "codeBlock")) { return } const s = o.dataTransfer.getData("text/html"); const a = i.find((t => t.isActive(s))); if (a) { o._parsedData = Kj(s, n.stylesProcessor); a.execute(o); o._isTransformedWithPasteFromOffice = true } }), { priority: "high" }) } } const Xj = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>'; const tF = "removeFormat"; class eF extends wl { static get pluginName() { return "RemoveFormatUI" } init() { const t = this.editor; const e = t.t; t.ui.componentFactory.add(tF, (n => { const i = t.commands.get(tF); const o = new wC(n); o.set({ label: e("Remove Format"), icon: Xj, tooltip: true }); o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"); this.listenTo(o, "execute", (() => { t.execute(tF); t.editing.view.focus() })); return o })) } } class nF extends _l { refresh() { const t = this.editor.model; this.isEnabled = !!ol(this._getFormattingItems(t.document.selection, t.schema)) } execute() { const t = this.editor.model; const e = t.schema; t.change((n => { for (const i of this._getFormattingItems(t.document.selection, e)) { if (i.is("selection")) { for (const t of this._getFormattingAttributes(i, e)) { n.removeSelectionAttribute(t) } } else { const t = n.createRangeOn(i); for (const o of this._getFormattingAttributes(i, e)) { n.removeAttribute(o, t) } } } })) } *_getFormattingItems(t, e) { const n = t => !!ol(this._getFormattingAttributes(t, e)); for (const i of t.getRanges()) { for (const t of i.getItems()) { if (!e.isBlock(t) && n(t)) { yield t } } } for (const e of t.getSelectedBlocks()) { if (n(e)) { yield e } } if (n(t)) { yield t } } *_getFormattingAttributes(t, e) { for (const [n] of t.getAttributes()) { const t = e.getAttributeProperties(n); if (t && t.isFormatting) { yield n } } } } class iF extends wl { static get pluginName() { return "RemoveFormatEditing" } init() { const t = this.editor; t.commands.add("removeFormat", new nF(t)) } } class oF extends wl { static get requires() { return [iF, eF] } static get pluginName() { return "RemoveFormat" } } class rF extends Cy { constructor(t, e) { super(t); const n = t.t; this.set("class", "ck-special-characters-navigation"); this.groupDropdownView = this._createGroupDropdown(e); this.groupDropdownView.panelPosition = t.uiLanguageDirection === "rtl" ? "se" : "sw"; this.label = n("Special characters"); this.children.add(this.groupDropdownView) } get currentGroupName() { return this.groupDropdownView.value } focus() { this.groupDropdownView.focus() } _createGroupDropdown(t) { const e = this.locale; const n = e.t; const i = Dv(e); const o = this._getCharacterGroupListItemDefinitions(i, t); i.set("value", o.first.model.name); i.buttonView.bind("label").to(i, "value", (e => t.get(e))); i.buttonView.set({ isOn: false, withText: true, tooltip: n("Character categories"), class: ["ck-dropdown__button_label-width_auto"] }); i.on("execute", (t => { i.value = t.source.name })); i.delegate("execute").to(this); Iv(i, o); return i } _getCharacterGroupListItemDefinitions(t, e) { const n = new il; for (const [i, o] of e) { const e = new Fy({ name: i, label: o, withText: true }); e.bind("isOn").to(t, "value", (t => t === e.name)); n.add({ type: "button", model: e }) } return n } } var sF = n(4046); var aF = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; aF.insert = "head"; aF.singleton = true; var cF = Sl()(sF.Z, aF); const lF = sF.Z.locals || {}; class dF extends N_ { constructor(t) { super(t); this.tiles = this.createCollection(); this.setTemplate({ tag: "div", children: [{ tag: "div", attributes: { class: ["ck", "ck-character-grid__tiles"] }, children: this.tiles }], attributes: { class: ["ck", "ck-character-grid"] } }); this.focusTracker = new rl; this.keystrokes = new sl; D_({ keystrokeHandler: this.keystrokes, focusTracker: this.focusTracker, gridItems: this.tiles, numberOfColumns: () => Za.window.getComputedStyle(this.element.firstChild).getPropertyValue("grid-template-columns").split(" ").length, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection }) } createTile(t, e) { const n = new wC(this.locale); n.set({ label: t, withText: true, class: "ck-character-grid__tile" }); n.extendTemplate({ attributes: { title: e }, on: { mouseover: n.bindTemplate.to("mouseover"), focus: n.bindTemplate.to("focus") } }); n.on("mouseover", (() => { this.fire("tileHover", { name: e, character: t }) })); n.on("focus", (() => { this.fire("tileFocus", { name: e, character: t }) })); n.on("execute", (() => { this.fire("execute", { name: e, character: t }) })); return n } render() { super.render(); for (const t of this.tiles) { this.focusTracker.add(t.element) } this.tiles.on("change", ((t, { added: e, removed: n }) => { if (e.length > 0) { for (const t of e) { this.focusTracker.add(t.element) } } if (n.length > 0) { for (const t of n) { this.focusTracker.remove(t.element) } } })); this.keystrokes.listenTo(this.element) } destroy() { super.destroy(); this.keystrokes.destroy() } focus() { this.tiles.first.focus() } } var uF = n(4779); var hF = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; hF.insert = "head"; hF.singleton = true; var gF = Sl()(uF.Z, hF); const mF = uF.Z.locals || {}; class fF extends N_ { constructor(t) { super(t); const e = this.bindTemplate; this.set("character", null); this.set("name", null); this.bind("code").to(this, "character", pF); this.setTemplate({ tag: "div", children: [{ tag: "span", attributes: { class: ["ck-character-info__name"] }, children: [{ text: e.to("name", (t => t ? t : "​")) }] }, { tag: "span", attributes: { class: ["ck-character-info__code"] }, children: [{ text: e.to("code") }] }], attributes: { class: ["ck", "ck-character-info"] } }) } } function pF(t) { if (t === null) { return "" } const e = t.codePointAt(0).toString(16); return "U+" + ("0000" + e).slice(-4) } class bF extends N_ { constructor(t, e, n, i) { super(t); this.navigationView = e; this.gridView = n; this.infoView = i; this.items = this.createCollection(); this.focusTracker = new rl; this.keystrokes = new sl; this._focusCycler = new QC({ focusables: this.items, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }); this.setTemplate({ tag: "div", children: [this.navigationView, this.gridView, this.infoView], attributes: { tabindex: "-1" } }); this.items.add(this.navigationView.groupDropdownView.buttonView); this.items.add(this.gridView) } render() { super.render(); this.focusTracker.add(this.navigationView.groupDropdownView.buttonView.element); this.focusTracker.add(this.gridView.element); this.keystrokes.listenTo(this.element) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } focus() { this.navigationView.focus() } } const kF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2.5a7.47 7.47 0 0 1 4.231 1.31 7.268 7.268 0 0 1 2.703 3.454 7.128 7.128 0 0 1 .199 4.353c-.39 1.436-1.475 2.72-2.633 3.677h2.013c0-.226.092-.443.254-.603a.876.876 0 0 1 1.229 0c.163.16.254.377.254.603v.853c0 .209-.078.41-.22.567a.873.873 0 0 1-.547.28l-.101.006h-4.695a.517.517 0 0 1-.516-.518v-1.265c0-.21.128-.398.317-.489a5.601 5.601 0 0 0 2.492-2.371 5.459 5.459 0 0 0 .552-3.693 5.53 5.53 0 0 0-1.955-3.2A5.71 5.71 0 0 0 10 4.206 5.708 5.708 0 0 0 6.419 5.46 5.527 5.527 0 0 0 4.46 8.663a5.457 5.457 0 0 0 .554 3.695 5.6 5.6 0 0 0 2.497 2.37.55.55 0 0 1 .317.49v1.264c0 .286-.23.518-.516.518H2.618a.877.877 0 0 1-.614-.25.845.845 0 0 1-.254-.603v-.853c0-.226.091-.443.254-.603a.876.876 0 0 1 1.228 0c.163.16.255.377.255.603h1.925c-1.158-.958-2.155-2.241-2.545-3.678a7.128 7.128 0 0 1 .199-4.352 7.268 7.268 0 0 1 2.703-3.455A7.475 7.475 0 0 1 10 2.5z"/></svg>'; var wF = n(8170); var AF = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; AF.insert = "head"; AF.singleton = true; var _F = Sl()(wF.Z, AF); const CF = wF.Z.locals || {}; const vF = "All"; class yF extends wl { static get requires() { return [EE] } static get pluginName() { return "SpecialCharacters" } constructor(t) { super(t); const e = t.t; this._characters = new Map; this._groups = new Map; this._allSpecialCharactersGroupLabel = e("All") } init() { const t = this.editor; const e = t.t; const n = t.commands.get("insertText"); t.ui.componentFactory.add("specialCharacters", (i => { const o = Dv(i); let r; o.buttonView.set({ label: e("Special characters"), icon: kF, tooltip: true }); o.bind("isEnabled").to(n); o.on("execute", ((e, n) => { t.execute("insertText", { text: n.character }); t.editing.view.focus() })); o.on("change:isOpen", (() => { if (!r) { r = this._createDropdownPanelContent(i, o); const t = new bF(i, r.navigationView, r.gridView, r.infoView); o.panelView.children.add(t) } r.infoView.set({ character: null, name: null }) })); return o })) } addItems(t, e, n = { label: t }) { if (t === vF) { throw new I("special-character-invalid-group-name", null) } const i = this._getGroup(t, n.label); for (const t of e) { i.items.add(t.title); this._characters.set(t.title, t.character) } } getGroups() { const t = Array.from(this._groups.keys()); const e = this.editor.config.get("specialCharacters.order") || []; const n = e.find((e => !t.includes(e))); if (n) { throw new I("special-character-invalid-order-group-name", null, { invalidGroup: n }) } return new Set([...e, ...t]) } getCharactersForGroup(t) { if (t === vF) { return new Set(this._characters.keys()) } const e = this._groups.get(t); if (e) { return e.items } } getCharacter(t) { return this._characters.get(t) } _getGroup(t, e) { if (!this._groups.has(t)) { this._groups.set(t, { items: new Set, label: e }) } return this._groups.get(t) } _updateGrid(t, e) { e.tiles.clear(); const n = this.getCharactersForGroup(t); for (const t of n) { const n = this.getCharacter(t); e.tiles.add(e.createTile(n, t)) } } _createDropdownPanelContent(t, e) { const n = Array.from(this.getGroups()).map((t => [t, this._groups.get(t).label])); const i = new Map([[vF, this._allSpecialCharactersGroupLabel], ...n]); const o = new rF(t, i); const r = new dF(t); const s = new fF(t); r.delegate("execute").to(e); r.on("tileHover", ((t, e) => { s.set(e) })); r.on("tileFocus", ((t, e) => { s.set(e) })); o.on("execute", (() => { this._updateGrid(o.currentGroupName, r) })); this._updateGrid(o.currentGroupName, r); return { navigationView: o, gridView: r, infoView: s } } } class xF extends wl { static get pluginName() { return "SpecialCharactersArrows" } init() { const t = this.editor; const e = t.t; const n = t.plugins.get("SpecialCharacters"); n.addItems("Arrows", [{ title: e("leftwards simple arrow"), character: "←" }, { title: e("rightwards simple arrow"), character: "→" }, { title: e("upwards simple arrow"), character: "↑" }, { title: e("downwards simple arrow"), character: "↓" }, { title: e("leftwards double arrow"), character: "⇐" }, { title: e("rightwards double arrow"), character: "⇒" }, { title: e("upwards double arrow"), character: "⇑" }, { title: e("downwards double arrow"), character: "⇓" }, { title: e("leftwards dashed arrow"), character: "⇠" }, { title: e("rightwards dashed arrow"), character: "⇢" }, { title: e("upwards dashed arrow"), character: "⇡" }, { title: e("downwards dashed arrow"), character: "⇣" }, { title: e("leftwards arrow to bar"), character: "⇤" }, { title: e("rightwards arrow to bar"), character: "⇥" }, { title: e("upwards arrow to bar"), character: "⤒" }, { title: e("downwards arrow to bar"), character: "⤓" }, { title: e("up down arrow with base"), character: "↨" }, { title: e("back with leftwards arrow above"), character: "🔙" }, { title: e("end with leftwards arrow above"), character: "🔚" }, { title: e("on with exclamation mark with left right arrow above"), character: "🔛" }, { title: e("soon with rightwards arrow above"), character: "🔜" }, { title: e("top with upwards arrow above"), character: "🔝" }], { label: e("Arrows") }) } } class EF extends wl { static get pluginName() { return "SpecialCharactersCurrency" } init() { const t = this.editor; const e = t.t; const n = t.plugins.get("SpecialCharacters"); n.addItems("Currency", [{ character: "$", title: e("Dollar sign") }, { character: "€", title: e("Euro sign") }, { character: "¥", title: e("Yen sign") }, { character: "£", title: e("Pound sign") }, { character: "¢", title: e("Cent sign") }, { character: "₠", title: e("Euro-currency sign") }, { character: "₡", title: e("Colon sign") }, { character: "₢", title: e("Cruzeiro sign") }, { character: "₣", title: e("French franc sign") }, { character: "₤", title: e("Lira sign") }, { character: "¤", title: e("Currency sign") }, { character: "₿", title: e("Bitcoin sign") }, { character: "₥", title: e("Mill sign") }, { character: "₦", title: e("Naira sign") }, { character: "₧", title: e("Peseta sign") }, { character: "₨", title: e("Rupee sign") }, { character: "₩", title: e("Won sign") }, { character: "₪", title: e("New sheqel sign") }, { character: "₫", title: e("Dong sign") }, { character: "₭", title: e("Kip sign") }, { character: "₮", title: e("Tugrik sign") }, { character: "₯", title: e("Drachma sign") }, { character: "₰", title: e("German penny sign") }, { character: "₱", title: e("Peso sign") }, { character: "₲", title: e("Guarani sign") }, { character: "₳", title: e("Austral sign") }, { character: "₴", title: e("Hryvnia sign") }, { character: "₵", title: e("Cedi sign") }, { character: "₶", title: e("Livre tournois sign") }, { character: "₷", title: e("Spesmilo sign") }, { character: "₸", title: e("Tenge sign") }, { character: "₹", title: e("Indian rupee sign") }, { character: "₺", title: e("Turkish lira sign") }, { character: "₻", title: e("Nordic mark sign") }, { character: "₼", title: e("Manat sign") }, { character: "₽", title: e("Ruble sign") }], { label: e("Currency") }) } } class DF extends wl { static get pluginName() { return "SpecialCharactersMathematical" } init() { const t = this.editor; const e = t.t; const n = t.plugins.get("SpecialCharacters"); n.addItems("Mathematical", [{ character: "<", title: e("Less-than sign") }, { character: ">", title: e("Greater-than sign") }, { character: "≤", title: e("Less-than or equal to") }, { character: "≥", title: e("Greater-than or equal to") }, { character: "–", title: e("En dash") }, { character: "—", title: e("Em dash") }, { character: "¯", title: e("Macron") }, { character: "‾", title: e("Overline") }, { character: "°", title: e("Degree sign") }, { character: "−", title: e("Minus sign") }, { character: "±", title: e("Plus-minus sign") }, { character: "÷", title: e("Division sign") }, { character: "⁄", title: e("Fraction slash") }, { character: "×", title: e("Multiplication sign") }, { character: "ƒ", title: e("Latin small letter f with hook") }, { character: "∫", title: e("Integral") }, { character: "∑", title: e("N-ary summation") }, { character: "∞", title: e("Infinity") }, { character: "√", title: e("Square root") }, { character: "∼", title: e("Tilde operator") }, { character: "≅", title: e("Approximately equal to") }, { character: "≈", title: e("Almost equal to") }, { character: "≠", title: e("Not equal to") }, { character: "≡", title: e("Identical to") }, { character: "∈", title: e("Element of") }, { character: "∉", title: e("Not an element of") }, { character: "∋", title: e("Contains as member") }, { character: "∏", title: e("N-ary product") }, { character: "∧", title: e("Logical and") }, { character: "∨", title: e("Logical or") }, { character: "¬", title: e("Not sign") }, { character: "∩", title: e("Intersection") }, { character: "∪", title: e("Union") }, { character: "∂", title: e("Partial differential") }, { character: "∀", title: e("For all") }, { character: "∃", title: e("There exists") }, { character: "∅", title: e("Empty set") }, { character: "∇", title: e("Nabla") }, { character: "∗", title: e("Asterisk operator") }, { character: "∝", title: e("Proportional to") }, { character: "∠", title: e("Angle") }, { character: "¼", title: e("Vulgar fraction one quarter") }, { character: "½", title: e("Vulgar fraction one half") }, { character: "¾", title: e("Vulgar fraction three quarters") }], { label: e("Mathematical") }) } } class SF extends wl { static get pluginName() { return "SpecialCharactersLatin" } init() { const t = this.editor; const e = t.t; const n = t.plugins.get("SpecialCharacters"); n.addItems("Latin", [{ character: "Ā", title: e("Latin capital letter a with macron") }, { character: "ā", title: e("Latin small letter a with macron") }, { character: "Ă", title: e("Latin capital letter a with breve") }, { character: "ă", title: e("Latin small letter a with breve") }, { character: "Ą", title: e("Latin capital letter a with ogonek") }, { character: "ą", title: e("Latin small letter a with ogonek") }, { character: "Ć", title: e("Latin capital letter c with acute") }, { character: "ć", title: e("Latin small letter c with acute") }, { character: "Ĉ", title: e("Latin capital letter c with circumflex") }, { character: "ĉ", title: e("Latin small letter c with circumflex") }, { character: "Ċ", title: e("Latin capital letter c with dot above") }, { character: "ċ", title: e("Latin small letter c with dot above") }, { character: "Č", title: e("Latin capital letter c with caron") }, { character: "č", title: e("Latin small letter c with caron") }, { character: "Ď", title: e("Latin capital letter d with caron") }, { character: "ď", title: e("Latin small letter d with caron") }, { character: "Đ", title: e("Latin capital letter d with stroke") }, { character: "đ", title: e("Latin small letter d with stroke") }, { character: "Ē", title: e("Latin capital letter e with macron") }, { character: "ē", title: e("Latin small letter e with macron") }, { character: "Ĕ", title: e("Latin capital letter e with breve") }, { character: "ĕ", title: e("Latin small letter e with breve") }, { character: "Ė", title: e("Latin capital letter e with dot above") }, { character: "ė", title: e("Latin small letter e with dot above") }, { character: "Ę", title: e("Latin capital letter e with ogonek") }, { character: "ę", title: e("Latin small letter e with ogonek") }, { character: "Ě", title: e("Latin capital letter e with caron") }, { character: "ě", title: e("Latin small letter e with caron") }, { character: "Ĝ", title: e("Latin capital letter g with circumflex") }, { character: "ĝ", title: e("Latin small letter g with circumflex") }, { character: "Ğ", title: e("Latin capital letter g with breve") }, { character: "ğ", title: e("Latin small letter g with breve") }, { character: "Ġ", title: e("Latin capital letter g with dot above") }, { character: "ġ", title: e("Latin small letter g with dot above") }, { character: "Ģ", title: e("Latin capital letter g with cedilla") }, { character: "ģ", title: e("Latin small letter g with cedilla") }, { character: "Ĥ", title: e("Latin capital letter h with circumflex") }, { character: "ĥ", title: e("Latin small letter h with circumflex") }, { character: "Ħ", title: e("Latin capital letter h with stroke") }, { character: "ħ", title: e("Latin small letter h with stroke") }, { character: "Ĩ", title: e("Latin capital letter i with tilde") }, { character: "ĩ", title: e("Latin small letter i with tilde") }, { character: "Ī", title: e("Latin capital letter i with macron") }, { character: "ī", title: e("Latin small letter i with macron") }, { character: "Ĭ", title: e("Latin capital letter i with breve") }, { character: "ĭ", title: e("Latin small letter i with breve") }, { character: "Į", title: e("Latin capital letter i with ogonek") }, { character: "į", title: e("Latin small letter i with ogonek") }, { character: "İ", title: e("Latin capital letter i with dot above") }, { character: "ı", title: e("Latin small letter dotless i") }, { character: "Ĳ", title: e("Latin capital ligature ij") }, { character: "ĳ", title: e("Latin small ligature ij") }, { character: "Ĵ", title: e("Latin capital letter j with circumflex") }, { character: "ĵ", title: e("Latin small letter j with circumflex") }, { character: "Ķ", title: e("Latin capital letter k with cedilla") }, { character: "ķ", title: e("Latin small letter k with cedilla") }, { character: "ĸ", title: e("Latin small letter kra") }, { character: "Ĺ", title: e("Latin capital letter l with acute") }, { character: "ĺ", title: e("Latin small letter l with acute") }, { character: "Ļ", title: e("Latin capital letter l with cedilla") }, { character: "ļ", title: e("Latin small letter l with cedilla") }, { character: "Ľ", title: e("Latin capital letter l with caron") }, { character: "ľ", title: e("Latin small letter l with caron") }, { character: "Ŀ", title: e("Latin capital letter l with middle dot") }, { character: "ŀ", title: e("Latin small letter l with middle dot") }, { character: "Ł", title: e("Latin capital letter l with stroke") }, { character: "ł", title: e("Latin small letter l with stroke") }, { character: "Ń", title: e("Latin capital letter n with acute") }, { character: "ń", title: e("Latin small letter n with acute") }, { character: "Ņ", title: e("Latin capital letter n with cedilla") }, { character: "ņ", title: e("Latin small letter n with cedilla") }, { character: "Ň", title: e("Latin capital letter n with caron") }, { character: "ň", title: e("Latin small letter n with caron") }, { character: "ŉ", title: e("Latin small letter n preceded by apostrophe") }, { character: "Ŋ", title: e("Latin capital letter eng") }, { character: "ŋ", title: e("Latin small letter eng") }, { character: "Ō", title: e("Latin capital letter o with macron") }, { character: "ō", title: e("Latin small letter o with macron") }, { character: "Ŏ", title: e("Latin capital letter o with breve") }, { character: "ŏ", title: e("Latin small letter o with breve") }, { character: "Ő", title: e("Latin capital letter o with double acute") }, { character: "ő", title: e("Latin small letter o with double acute") }, { character: "Œ", title: e("Latin capital ligature oe") }, { character: "œ", title: e("Latin small ligature oe") }, { character: "Ŕ", title: e("Latin capital letter r with acute") }, { character: "ŕ", title: e("Latin small letter r with acute") }, { character: "Ŗ", title: e("Latin capital letter r with cedilla") }, { character: "ŗ", title: e("Latin small letter r with cedilla") }, { character: "Ř", title: e("Latin capital letter r with caron") }, { character: "ř", title: e("Latin small letter r with caron") }, { character: "Ś", title: e("Latin capital letter s with acute") }, { character: "ś", title: e("Latin small letter s with acute") }, { character: "Ŝ", title: e("Latin capital letter s with circumflex") }, { character: "ŝ", title: e("Latin small letter s with circumflex") }, { character: "Ş", title: e("Latin capital letter s with cedilla") }, { character: "ş", title: e("Latin small letter s with cedilla") }, { character: "Š", title: e("Latin capital letter s with caron") }, { character: "š", title: e("Latin small letter s with caron") }, { character: "Ţ", title: e("Latin capital letter t with cedilla") }, { character: "ţ", title: e("Latin small letter t with cedilla") }, { character: "Ť", title: e("Latin capital letter t with caron") }, { character: "ť", title: e("Latin small letter t with caron") }, { character: "Ŧ", title: e("Latin capital letter t with stroke") }, { character: "ŧ", title: e("Latin small letter t with stroke") }, { character: "Ũ", title: e("Latin capital letter u with tilde") }, { character: "ũ", title: e("Latin small letter u with tilde") }, { character: "Ū", title: e("Latin capital letter u with macron") }, { character: "ū", title: e("Latin small letter u with macron") }, { character: "Ŭ", title: e("Latin capital letter u with breve") }, { character: "ŭ", title: e("Latin small letter u with breve") }, { character: "Ů", title: e("Latin capital letter u with ring above") }, { character: "ů", title: e("Latin small letter u with ring above") }, { character: "Ű", title: e("Latin capital letter u with double acute") }, { character: "ű", title: e("Latin small letter u with double acute") }, { character: "Ų", title: e("Latin capital letter u with ogonek") }, { character: "ų", title: e("Latin small letter u with ogonek") }, { character: "Ŵ", title: e("Latin capital letter w with circumflex") }, { character: "ŵ", title: e("Latin small letter w with circumflex") }, { character: "Ŷ", title: e("Latin capital letter y with circumflex") }, { character: "ŷ", title: e("Latin small letter y with circumflex") }, { character: "Ÿ", title: e("Latin capital letter y with diaeresis") }, { character: "Ź", title: e("Latin capital letter z with acute") }, { character: "ź", title: e("Latin small letter z with acute") }, { character: "Ż", title: e("Latin capital letter z with dot above") }, { character: "ż", title: e("Latin small letter z with dot above") }, { character: "Ž", title: e("Latin capital letter z with caron") }, { character: "ž", title: e("Latin small letter z with caron") }, { character: "ſ", title: e("Latin small letter long s") }], { label: e("Latin") }) } } class TF extends wl { static get pluginName() { return "SpecialCharactersText" } init() { const t = this.editor; const e = t.t; const n = t.plugins.get("SpecialCharacters"); n.addItems("Text", [{ character: "‹", title: e("Single left-pointing angle quotation mark") }, { character: "›", title: e("Single right-pointing angle quotation mark") }, { character: "«", title: e("Left-pointing double angle quotation mark") }, { character: "»", title: e("Right-pointing double angle quotation mark") }, { character: "‘", title: e("Left single quotation mark") }, { character: "’", title: e("Right single quotation mark") }, { character: "“", title: e("Left double quotation mark") }, { character: "”", title: e("Right double quotation mark") }, { character: "‚", title: e("Single low-9 quotation mark") }, { character: "„", title: e("Double low-9 quotation mark") }, { character: "¡", title: e("Inverted exclamation mark") }, { character: "¿", title: e("Inverted question mark") }, { character: "‥", title: e("Two dot leader") }, { character: "…", title: e("Horizontal ellipsis") }, { character: "‡", title: e("Double dagger") }, { character: "‰", title: e("Per mille sign") }, { character: "‱", title: e("Per ten thousand sign") }, { character: "‼", title: e("Double exclamation mark") }, { character: "⁈", title: e("Question exclamation mark") }, { character: "⁉", title: e("Exclamation question mark") }, { character: "⁇", title: e("Double question mark") }, { character: "©", title: e("Copyright sign") }, { character: "®", title: e("Registered sign") }, { character: "™", title: e("Trade mark sign") }, { character: "§", title: e("Section sign") }, { character: "¶", title: e("Paragraph sign") }, { character: "⁋", title: e("Reversed paragraph sign") }], { label: e("Text") }) } } class IF extends wl { static get pluginName() { return "SpecialCharactersEssentials" } static get requires() { return [EF, TF, DF, xF, SF] } } const MF = "strikethrough"; class BF extends wl { static get pluginName() { return "StrikethroughEditing" } init() { const t = this.editor; t.model.schema.extend("$text", { allowAttributes: MF }); t.model.schema.setAttributeProperties(MF, { isFormatting: true, copyOnEnter: true }); t.conversion.attributeToElement({ model: MF, view: "s", upcastAlso: ["del", "strike", { styles: { "text-decoration": "line-through" } }] }); t.commands.add(MF, new FI(t, MF)); t.keystrokes.set("CTRL+SHIFT+X", "strikethrough") } } const LF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>'; const NF = "strikethrough"; class zF extends wl { static get pluginName() { return "StrikethroughUI" } init() { const t = this.editor; const e = t.t; t.ui.componentFactory.add(NF, (n => { const i = t.commands.get(NF); const o = new wC(n); o.set({ label: e("Strikethrough"), icon: LF, keystroke: "CTRL+SHIFT+X", tooltip: true, isToggleable: true }); o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"); this.listenTo(o, "execute", (() => { t.execute(NF); t.editing.view.focus() })); return o })) } } class PF extends wl { static get requires() { return [BF, zF] } static get pluginName() { return "Strikethrough" } } const OF = "subscript"; class RF extends wl { static get pluginName() { return "SubscriptEditing" } init() { const t = this.editor; t.model.schema.extend("$text", { allowAttributes: OF }); t.model.schema.setAttributeProperties(OF, { isFormatting: true, copyOnEnter: true }); t.conversion.attributeToElement({ model: OF, view: "sub", upcastAlso: [{ styles: { "vertical-align": "sub" } }] }); t.commands.add(OF, new FI(t, OF)) } } const VF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.03 10.349 3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82zm8.147 7.829h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309z"/></svg>'; const jF = "subscript"; class FF extends wl { static get pluginName() { return "SubscriptUI" } init() { const t = this.editor; const e = t.t; t.ui.componentFactory.add(jF, (n => { const i = t.commands.get(jF); const o = new wC(n); o.set({ label: e("Subscript"), icon: VF, tooltip: true, isToggleable: true }); o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"); this.listenTo(o, "execute", (() => { t.execute(jF); t.editing.view.focus() })); return o })) } } class HF extends wl { static get requires() { return [RF, FF] } static get pluginName() { return "Subscript" } } const UF = "superscript"; class WF extends wl { static get pluginName() { return "SuperscriptEditing" } init() { const t = this.editor; t.model.schema.extend("$text", { allowAttributes: UF }); t.model.schema.setAttributeProperties(UF, { isFormatting: true, copyOnEnter: true }); t.conversion.attributeToElement({ model: UF, view: "sup", upcastAlso: [{ styles: { "vertical-align": "super" } }] }); t.commands.add(UF, new FI(t, UF)) } } const qF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.677 8.678h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309zM7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82z"/></svg>'; const GF = "superscript"; class $F extends wl { static get pluginName() { return "SuperscriptUI" } init() { const t = this.editor; const e = t.t; t.ui.componentFactory.add(GF, (n => { const i = t.commands.get(GF); const o = new wC(n); o.set({ label: e("Superscript"), icon: qF, tooltip: true, isToggleable: true }); o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"); this.listenTo(o, "execute", (() => { t.execute(GF); t.editing.view.focus() })); return o })) } } class KF extends wl { static get requires() { return [WF, $F] } static get pluginName() { return "Superscript" } } function YF(t, e) { const { modelAttribute: n, styleName: i, viewElement: o, defaultValue: r, reduceBoxSides: s = false, shouldUpcast: a = (() => true) } = e; t.for("upcast").attributeToAttribute({ view: { name: o, styles: { [i]: /[\s\S]+/ } }, model: { key: n, value: t => { if (!a(t)) { return } const e = t.getNormalizedStyle(i); const n = s ? XF(e) : e; if (r !== n) { return n } } } }) } function QF(t, e, n, i) { t.for("upcast").add((t => t.on("element:" + e, ((t, e, o) => { if (!e.modelRange) { return } const r = ["border-top-width", "border-top-color", "border-top-style", "border-bottom-width", "border-bottom-color", "border-bottom-style", "border-right-width", "border-right-color", "border-right-style", "border-left-width", "border-left-color", "border-left-style"].filter((t => e.viewItem.hasStyle(t))); if (!r.length) { return } const s = { styles: r }; if (!o.consumable.test(e.viewItem, s)) { return } const a = [...e.modelRange.getItems({ shallow: true })].pop(); o.consumable.consume(e.viewItem, s); const c = { style: e.viewItem.getNormalizedStyle("border-style"), color: e.viewItem.getNormalizedStyle("border-color"), width: e.viewItem.getNormalizedStyle("border-width") }; const l = { style: XF(c.style), color: XF(c.color), width: XF(c.width) }; if (l.style !== i.style) { o.writer.setAttribute(n.style, l.style, a) } if (l.color !== i.color) { o.writer.setAttribute(n.color, l.color, a) } if (l.width !== i.width) { o.writer.setAttribute(n.width, l.width, a) } })))) } function ZF(t, e) { const { modelElement: n, modelAttribute: i, styleName: o } = e; t.for("downcast").attributeToAttribute({ model: { name: n, key: i }, view: t => ({ key: "style", value: { [o]: t } }) }) } function JF(t, e) { const { modelAttribute: n, styleName: i } = e; t.for("downcast").add((t => t.on(`attribute:${n}:table`, ((t, e, n) => { const { item: o, attributeNewValue: r } = e; const { mapper: s, writer: a } = n; if (!n.consumable.consume(e.item, t.name)) { return } const c = [...s.toViewElement(o).getChildren()].find((t => t.is("element", "table"))); if (r) { a.setStyle(i, r, c) } else { a.removeStyle(i, c) } })))) } function XF(t) { if (!t) { return } const e = ["top", "right", "bottom", "left"]; const n = e.every((e => t[e])); if (!n) { return t } const i = t.top; const o = e.every((e => t[e] === i)); if (!o) { return t } return i } function tH(t, e, n, i, o = 1) { if (e !== undefined && e !== null && o !== undefined && o !== null && e > o) { i.setAttribute(t, e, n) } else { i.removeAttribute(t, n) } } function eH(t, e, n = {}) { const i = t.createElement("tableCell", n); t.insertElement("paragraph", i); t.insert(i, e); return i } function nH(t, e) { const n = e.parent.parent; const i = parseInt(n.getAttribute("headingColumns") || "0"); const { column: o } = t.getCellLocation(e); return !!i && o < i } function iH(t, e, n) { const { modelAttribute: i } = n; t.extend("tableCell", { allowAttributes: [i] }); YF(e, { viewElement: /^(td|th)$/, ...n }); ZF(e, { modelElement: "tableCell", ...n }) } function oH() { return t => { t.on("element:figure", ((t, e, n) => { if (!n.consumable.test(e.viewItem, { name: true, classes: "table" })) { return } const i = cH(e.viewItem); if (!i || !n.consumable.test(i, { name: true })) { return } n.consumable.consume(e.viewItem, { name: true, classes: "table" }); const o = n.convertItem(i, e.modelCursor); const r = ol(o.modelRange.getItems()); if (!r) { n.consumable.revert(e.viewItem, { name: true, classes: "table" }); return } n.convertChildren(e.viewItem, n.writer.createPositionAt(r, "end")); n.updateConversionResult(r, e) })) } } function rH() { return t => { t.on("element:table", ((t, e, n) => { const i = e.viewItem; if (!n.consumable.test(i, { name: true })) { return } const { rows: o, headingRows: r, headingColumns: s } = lH(i); const a = {}; if (s) { a.headingColumns = s } if (r) { a.headingRows = r } const c = n.writer.createElement("table", a); if (!n.safeInsert(c, e.modelCursor)) { return } n.consumable.consume(i, { name: true }); o.forEach((t => n.convertItem(t, n.writer.createPositionAt(c, "end")))); n.convertChildren(i, n.writer.createPositionAt(c, "end")); if (c.isEmpty) { const t = n.writer.createElement("tableRow"); n.writer.insert(t, n.writer.createPositionAt(c, "end")); eH(n.writer, n.writer.createPositionAt(t, "end")) } n.updateConversionResult(c, e) })) } } function sH() { return t => { t.on("element:tr", ((t, e) => { if (e.viewItem.isEmpty && e.modelCursor.index == 0) { t.stop() } }), { priority: "high" }) } } function aH(t) { return e => { e.on(`element:${t}`, ((t, e, { writer: n }) => { if (!e.modelRange) { return } const i = e.modelRange.start.nodeAfter; const o = n.createPositionAt(i, 0); if (e.viewItem.isEmpty) { n.insertElement("paragraph", o); return } const r = Array.from(i.getChildren()); if (r.every((t => t.is("element", "$marker")))) { const t = n.createElement("paragraph"); n.insert(t, n.createPositionAt(i, 0)); for (const e of r) { n.move(n.createRangeOn(e), n.createPositionAt(t, "end")) } } }), { priority: "low" }) } } function cH(t) { for (const e of t.getChildren()) { if (e.is("element", "table")) { return e } } } function lH(t) { let e = 0; let n = undefined; const i = []; const o = []; let r; for (const s of Array.from(t.getChildren())) { if (s.name !== "tbody" && s.name !== "thead" && s.name !== "tfoot") { continue } if (s.name === "thead" && !r) { r = s } const t = Array.from(s.getChildren()).filter((t => t.is("element", "tr"))); for (const a of t) { if (r && s === r || s.name === "tbody" && Array.from(a.getChildren()).length && Array.from(a.getChildren()).every((t => t.is("element", "th")))) { e++; i.push(a) } else { o.push(a); const t = dH(a); if (!n || t < n) { n = t } } } } return { headingRows: e, headingColumns: n || 0, rows: [...i, ...o] } } function dH(t) { let e = 0; let n = 0; const i = Array.from(t.getChildren()).filter((t => t.name === "th" || t.name === "td")); while (n < i.length && i[n].name === "th") { const t = i[n]; const o = parseInt(t.getAttribute("colspan") || "1"); e = e + o; n++ } return e } class uH { constructor(t, e = {}) { this._table = t; this._startRow = e.row !== undefined ? e.row : e.startRow || 0; this._endRow = e.row !== undefined ? e.row : e.endRow; this._startColumn = e.column !== undefined ? e.column : e.startColumn || 0; this._endColumn = e.column !== undefined ? e.column : e.endColumn; this._includeAllSlots = !!e.includeAllSlots; this._skipRows = new Set; this._row = 0; this._rowIndex = 0; this._column = 0; this._cellIndex = 0; this._spannedCells = new Map; this._nextCellAtColumn = -1 } [Symbol.iterator]() { return this } next() { const t = this._table.getChild(this._rowIndex); if (!t || this._isOverEndRow()) { return { done: true, value: undefined } } if (!t.is("element", "tableRow")) { this._rowIndex++; return this.next() } if (this._isOverEndColumn()) { return this._advanceToNextRow() } let e = null; const n = this._getSpanned(); if (n) { if (this._includeAllSlots && !this._shouldSkipSlot()) { e = this._formatOutValue(n.cell, n.row, n.column) } } else { const n = t.getChild(this._cellIndex); if (!n) { return this._advanceToNextRow() } const i = parseInt(n.getAttribute("colspan") || "1"); const o = parseInt(n.getAttribute("rowspan") || "1"); if (i > 1 || o > 1) { this._recordSpans(n, o, i) } if (!this._shouldSkipSlot()) { e = this._formatOutValue(n) } this._nextCellAtColumn = this._column + i } this._column++; if (this._column == this._nextCellAtColumn) { this._cellIndex++ } return e || this.next() } skipRow(t) { this._skipRows.add(t) } _advanceToNextRow() { this._row++; this._rowIndex++; this._column = 0; this._cellIndex = 0; this._nextCellAtColumn = -1; return this.next() } _isOverEndRow() { return this._endRow !== undefined && this._row > this._endRow } _isOverEndColumn() { return this._endColumn !== undefined && this._column > this._endColumn } _formatOutValue(t, e = this._row, n = this._column) { return { done: false, value: new hH(this, t, e, n) } } _shouldSkipSlot() { const t = this._skipRows.has(this._row); const e = this._row < this._startRow; const n = this._column < this._startColumn; const i = this._endColumn !== undefined && this._column > this._endColumn; return t || e || n || i } _getSpanned() { const t = this._spannedCells.get(this._row); if (!t) { return null } return t.get(this._column) || null } _recordSpans(t, e, n) { const i = { cell: t, row: this._row, column: this._column }; for (let t = this._row; t < this._row + e; t++) { for (let e = this._column; e < this._column + n; e++) { if (t != this._row || e != this._column) { this._markSpannedCell(t, e, i) } } } } _markSpannedCell(t, e, n) { if (!this._spannedCells.has(t)) { this._spannedCells.set(t, new Map) } const i = this._spannedCells.get(t); i.set(e, n) } } class hH { constructor(t, e, n, i) { this.cell = e; this.row = t._row; this.column = t._column; this.cellAnchorRow = n; this.cellAnchorColumn = i; this._cellIndex = t._cellIndex; this._rowIndex = t._rowIndex; this._table = t._table } get isAnchor() { return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn } get cellWidth() { return parseInt(this.cell.getAttribute("colspan") || "1") } get cellHeight() { return parseInt(this.cell.getAttribute("rowspan") || "1") } get rowIndex() { return this._rowIndex } getPositionBefore() { const t = this._table.root.document.model; return t.createPositionAt(this._table.getChild(this.row), this._cellIndex) } } function gH(t, e) { return (n, { writer: i }) => { const o = n.getAttribute("headingRows") || 0; const r = i.createContainerElement("table", null, []); const s = i.createContainerElement("figure", { class: "table" }, r); if (o > 0) { i.insert(i.createPositionAt(r, "end"), i.createContainerElement("thead", null, i.createSlot((t => t.is("element", "tableRow") && t.index < o)))) } if (o < t.getRows(n)) { i.insert(i.createPositionAt(r, "end"), i.createContainerElement("tbody", null, i.createSlot((t => t.is("element", "tableRow") && t.index >= o)))) } for (const { positionOffset: t, filter: n } of e.additionalSlots) { i.insert(i.createPositionAt(r, t), i.createSlot(n)) } i.insert(i.createPositionAt(r, "after"), i.createSlot((t => { if (t.is("element", "tableRow")) { return false } return !e.additionalSlots.some((({ filter: e }) => e(t))) }))); return e.asWidget ? kH(s, i) : s } } function mH() { return (t, { writer: e }) => t.isEmpty ? e.createEmptyElement("tr") : e.createContainerElement("tr") } function fH(t = {}) { return (e, { writer: n }) => { const i = e.parent; const o = i.parent; const r = o.getChildIndex(i); const s = new uH(o, { row: r }); const a = o.getAttribute("headingRows") || 0; const c = o.getAttribute("headingColumns") || 0; let l = null; for (const i of s) { if (i.cell == e) { const e = i.row < a || i.column < c; const o = e ? "th" : "td"; l = t.asWidget ? yD(n.createEditableElement(o), n) : n.createContainerElement(o); break } } return l } } function pH(t = {}) { return (e, { writer: n }) => { if (!e.parent.is("element", "tableCell")) { return null } if (!bH(e)) { return null } if (t.asWidget) { return n.createContainerElement("span", { class: "ck-table-bogus-paragraph" }) } else { const t = n.createContainerElement("p"); n.setCustomProperty("dataPipeline:transparentRendering", true, t); return t } } } function bH(t) { const e = t.parent; const n = e.childCount == 1; return n && !wH(t) } function kH(t, e) { e.setCustomProperty("table", true, t); return kD(t, e, { hasSelectionHandle: true }) } function wH(t) { const e = t.getAttributeKeys().next(); return !e.done } class AH extends _l { refresh() { const t = this.editor.model; const e = t.document.selection; const n = t.schema; this.isEnabled = _H(e, n) } execute(t = {}) { const e = this.editor; const n = e.model; const i = e.plugins.get("TableUtils"); const o = e.config.get("table.defaultHeadings.rows"); const r = e.config.get("table.defaultHeadings.columns"); if (t.headingRows === undefined && o) { t.headingRows = o } if (t.headingColumns === undefined && r) { t.headingColumns = r } n.change((e => { const o = i.createTable(e, t); n.insertObject(o, null, null, { findOptimalPosition: "auto" }); e.setSelection(e.createPositionAt(o.getNodeByPath([0, 0, 0]), 0)) })) } } function _H(t, e) { const n = t.getFirstPosition().parent; const i = n === n.root ? n : n.parent; return e.checkChild(i, "table") } class CH extends _l { constructor(t, e = {}) { super(t); this.order = e.order || "below" } refresh() { const t = this.editor.model.document.selection; const e = this.editor.plugins.get("TableUtils"); const n = !!e.getSelectionAffectedTableCells(t).length; this.isEnabled = n } execute() { const t = this.editor; const e = t.model.document.selection; const n = t.plugins.get("TableUtils"); const i = this.order === "above"; const o = n.getSelectionAffectedTableCells(e); const r = n.getRowIndexes(o); const s = i ? r.first : r.last; const a = o[0].findAncestor("table"); n.insertRows(a, { at: i ? s : s + 1, copyStructureFromAbove: !i }) } } class vH extends _l { constructor(t, e = {}) { super(t); this.order = e.order || "right" } refresh() { const t = this.editor.model.document.selection; const e = this.editor.plugins.get("TableUtils"); const n = !!e.getSelectionAffectedTableCells(t).length; this.isEnabled = n } execute() { const t = this.editor; const e = t.model.document.selection; const n = t.plugins.get("TableUtils"); const i = this.order === "left"; const o = n.getSelectionAffectedTableCells(e); const r = n.getColumnIndexes(o); const s = i ? r.first : r.last; const a = o[0].findAncestor("table"); n.insertColumns(a, { columns: 1, at: i ? s : s + 1 }) } } class yH extends _l { constructor(t, e = {}) { super(t); this.direction = e.direction || "horizontally" } refresh() { const t = this.editor.plugins.get("TableUtils"); const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection); this.isEnabled = e.length === 1 } execute() { const t = this.editor.plugins.get("TableUtils"); const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection)[0]; const n = this.direction === "horizontally"; if (n) { t.splitCellHorizontally(e, 2) } else { t.splitCellVertically(e, 2) } } } function xH(t, e, n) { const { startRow: i, startColumn: o, endRow: r, endColumn: s } = e; const a = n.createElement("table"); const c = r - i + 1; for (let t = 0; t < c; t++) { n.insertElement("tableRow", a, "end") } const l = [...new uH(t, { startRow: i, endRow: r, startColumn: o, endColumn: s, includeAllSlots: true })]; for (const { row: t, column: e, cell: c, isAnchor: d, cellAnchorRow: u, cellAnchorColumn: h } of l) { const l = t - i; const g = a.getChild(l); if (!d) { if (u < i || h < o) { eH(n, n.createPositionAt(g, "end")) } } else { const i = n.cloneElement(c); n.append(i, g); IH(i, t, e, r, s, n) } } MH(a, t, i, o, n); return a } function EH(t, e, n = 0) { const i = []; const o = new uH(t, { startRow: n, endRow: e - 1 }); for (const t of o) { const { row: n, cellHeight: o } = t; const r = n + o - 1; if (n < e && e <= r) { i.push(t) } } return i } function DH(t, e, n) { const i = t.parent; const o = i.parent; const r = i.index; const s = parseInt(t.getAttribute("rowspan")); const a = e - r; const c = {}; const l = s - a; if (l > 1) { c.rowspan = l } const d = parseInt(t.getAttribute("colspan") || "1"); if (d > 1) { c.colspan = d } const u = r; const h = u + a; const g = [...new uH(o, { startRow: u, endRow: h, includeAllSlots: true })]; let m = null; let f; for (const e of g) { const { row: i, column: o, cell: r } = e; if (r === t && f === undefined) { f = o } if (f !== undefined && f === o && i === h) { m = eH(n, e.getPositionBefore(), c) } } tH("rowspan", a, t, n); return m } function SH(t, e) { const n = []; const i = new uH(t); for (const t of i) { const { column: i, cellWidth: o } = t; const r = i + o - 1; if (i < e && e <= r) { n.push(t) } } return n } function TH(t, e, n, i) { const o = parseInt(t.getAttribute("colspan")); const r = n - e; const s = {}; const a = o - r; if (a > 1) { s.colspan = a } const c = parseInt(t.getAttribute("rowspan") || "1"); if (c > 1) { s.rowspan = c } const l = eH(i, i.createPositionAfter(t), s); tH("colspan", r, t, i); return l } function IH(t, e, n, i, o, r) { const s = parseInt(t.getAttribute("colspan") || "1"); const a = parseInt(t.getAttribute("rowspan") || "1"); const c = n + s - 1; if (c > o) { const e = o - n + 1; tH("colspan", e, t, r, 1) } const l = e + a - 1; if (l > i) { const n = i - e + 1; tH("rowspan", n, t, r, 1) } } function MH(t, e, n, i, o) { const r = parseInt(e.getAttribute("headingRows") || "0"); if (r > 0) { const e = r - n; tH("headingRows", e, t, o, 0) } const s = parseInt(e.getAttribute("headingColumns") || "0"); if (s > 0) { const e = s - i; tH("headingColumns", e, t, o, 0) } } function BH(t, e) { const n = e.getColumns(t); const i = new Array(n).fill(0); for (const { column: e } of new uH(t)) { i[e]++ } const o = i.reduce(((t, e, n) => e ? t : [...t, n]), []); if (o.length > 0) { const n = o[o.length - 1]; e.removeColumns(t, { at: n }); return true } return false } function LH(t, e) { const n = []; const i = e.getRows(t); for (let e = 0; e < i; e++) { const i = t.getChild(e); if (i.isEmpty) { n.push(e) } } if (n.length > 0) { const i = n[n.length - 1]; e.removeRows(t, { at: i }); return true } return false } function NH(t, e) { const n = BH(t, e); if (!n) { LH(t, e) } } function zH(t, e) { const n = Array.from(new uH(t, { startColumn: e.firstColumn, endColumn: e.lastColumn, row: e.lastRow })); const i = n.every((({ cellHeight: t }) => t === 1)); if (i) { return e.lastRow } const o = n[0].cellHeight - 1; return e.lastRow + o } function PH(t, e) { const n = Array.from(new uH(t, { startRow: e.firstRow, endRow: e.lastRow, column: e.lastColumn })); const i = n.every((({ cellWidth: t }) => t === 1)); if (i) { return e.lastColumn } const o = n[0].cellWidth - 1; return e.lastColumn + o } class OH extends _l { constructor(t, e) { super(t); this.direction = e.direction; this.isHorizontal = this.direction == "right" || this.direction == "left" } refresh() { const t = this._getMergeableCell(); this.value = t; this.isEnabled = !!t } execute() { const t = this.editor.model; const e = t.document; const n = this.editor.plugins.get("TableUtils"); const i = n.getTableCellsContainingSelection(e.selection)[0]; const o = this.value; const r = this.direction; t.change((t => { const e = r == "right" || r == "down"; const n = e ? i : o; const s = e ? o : i; const a = s.parent; jH(s, n, t); const c = this.isHorizontal ? "colspan" : "rowspan"; const l = parseInt(i.getAttribute(c) || "1"); const d = parseInt(o.getAttribute(c) || "1"); t.setAttribute(c, l + d, n); t.setSelection(t.createRangeIn(n)); const u = this.editor.plugins.get("TableUtils"); const h = a.findAncestor("table"); NH(h, u) })) } _getMergeableCell() { const t = this.editor.model; const e = t.document; const n = this.editor.plugins.get("TableUtils"); const i = n.getTableCellsContainingSelection(e.selection)[0]; if (!i) { return } const o = this.isHorizontal ? RH(i, this.direction, n) : VH(i, this.direction, n); if (!o) { return } const r = this.isHorizontal ? "rowspan" : "colspan"; const s = parseInt(i.getAttribute(r) || "1"); const a = parseInt(o.getAttribute(r) || "1"); if (a === s) { return o } } } function RH(t, e, n) { const i = t.parent; const o = i.parent; const r = e == "right" ? t.nextSibling : t.previousSibling; const s = (o.getAttribute("headingColumns") || 0) > 0; if (!r) { return } const a = e == "right" ? t : r; const c = e == "right" ? r : t; const { column: l } = n.getCellLocation(a); const { column: d } = n.getCellLocation(c); const u = parseInt(a.getAttribute("colspan") || "1"); const h = nH(n, a); const g = nH(n, c); if (s && h != g) { return } const m = l + u === d; return m ? r : undefined } function VH(t, e, n) { const i = t.parent; const o = i.parent; const r = o.getChildIndex(i); if (e == "down" && r === n.getRows(o) - 1 || e == "up" && r === 0) { return null } const s = parseInt(t.getAttribute("rowspan") || "1"); const a = o.getAttribute("headingRows") || 0; const c = e == "down" && r + s === a; const l = e == "up" && r === a; if (a && (c || l)) { return null } const d = parseInt(t.getAttribute("rowspan") || "1"); const u = e == "down" ? r + d : r; const h = [...new uH(o, { endRow: u })]; const g = h.find((e => e.cell === t)); const m = g.column; const f = h.find((({ row: t, cellHeight: n, column: i }) => { if (i !== m) { return false } if (e == "down") { return t === u } else { return u === t + n } })); return f && f.cell ? f.cell : null } function jH(t, e, n) { if (!FH(t)) { if (FH(e)) { n.remove(n.createRangeIn(e)) } n.move(n.createRangeIn(t), n.createPositionAt(e, "end")) } n.remove(t) } function FH(t) { const e = t.getChild(0); return t.childCount == 1 && e.is("element", "paragraph") && e.isEmpty } class HH extends _l { refresh() { const t = this.editor.plugins.get("TableUtils"); const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection); const n = e[0]; if (n) { const i = n.findAncestor("table"); const o = t.getRows(i); const r = o - 1; const s = t.getRowIndexes(e); const a = s.first === 0 && s.last === r; this.isEnabled = !a } else { this.isEnabled = false } } execute() { const t = this.editor.model; const e = this.editor.plugins.get("TableUtils"); const n = e.getSelectionAffectedTableCells(t.document.selection); const i = e.getRowIndexes(n); const o = n[0]; const r = o.findAncestor("table"); const s = e.getCellLocation(o).column; t.change((t => { const n = i.last - i.first + 1; e.removeRows(r, { at: i.first, rows: n }); const o = UH(r, i.first, s, e.getRows(r)); t.setSelection(t.createPositionAt(o, 0)) })) } } function UH(t, e, n, i) { const o = t.getChild(Math.min(e, i - 1)); let r = o.getChild(0); let s = 0; for (const t of o.getChildren()) { if (s > n) { return r } r = t; s += parseInt(t.getAttribute("colspan") || "1") } return r } class WH extends _l { refresh() { const t = this.editor.plugins.get("TableUtils"); const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection); const n = e[0]; if (n) { const i = n.findAncestor("table"); const o = t.getColumns(i); const { first: r, last: s } = t.getColumnIndexes(e); this.isEnabled = s - r < o - 1 } else { this.isEnabled = false } } execute() { const t = this.editor.plugins.get("TableUtils"); const [e, n] = GH(this.editor.model.document.selection, t); const i = e.parent.parent; const o = [...new uH(i)]; const r = { first: o.find((t => t.cell === e)).column, last: o.find((t => t.cell === n)).column }; const s = qH(o, e, n, r); this.editor.model.change((e => { const n = r.last - r.first + 1; t.removeColumns(i, { at: r.first, columns: n }); e.setSelection(e.createPositionAt(s, 0)) })) } } function qH(t, e, n, i) { const o = parseInt(n.getAttribute("colspan") || "1"); if (o > 1) { return n } else if (e.previousSibling || n.nextSibling) { return n.nextSibling || e.previousSibling } else { if (i.first) { return t.reverse().find((({ column: t }) => t < i.first)).cell } else { return t.reverse().find((({ column: t }) => t > i.last)).cell } } } function GH(t, e) { const n = e.getSelectionAffectedTableCells(t); const i = n[0]; const o = n.pop(); const r = [i, o]; return i.isBefore(o) ? r : r.reverse() } class $H extends _l { refresh() { const t = this.editor.plugins.get("TableUtils"); const e = this.editor.model; const n = t.getSelectionAffectedTableCells(e.document.selection); const i = n.length > 0; this.isEnabled = i; this.value = i && n.every((t => this._isInHeading(t, t.parent.parent))) } execute(t = {}) { if (t.forceValue === this.value) { return } const e = this.editor.plugins.get("TableUtils"); const n = this.editor.model; const i = e.getSelectionAffectedTableCells(n.document.selection); const o = i[0].findAncestor("table"); const { first: r, last: s } = e.getRowIndexes(i); const a = this.value ? r : s + 1; const c = o.getAttribute("headingRows") || 0; n.change((t => { if (a) { const e = a > c ? c : 0; const n = EH(o, a, e); for (const { cell: e } of n) { DH(e, a, t) } } tH("headingRows", a, o, t, 0) })) } _isInHeading(t, e) { const n = parseInt(e.getAttribute("headingRows") || "0"); return !!n && t.parent.index < n } } class KH extends _l { refresh() { const t = this.editor.model; const e = this.editor.plugins.get("TableUtils"); const n = e.getSelectionAffectedTableCells(t.document.selection); const i = n.length > 0; this.isEnabled = i; this.value = i && n.every((t => nH(e, t))) } execute(t = {}) { if (t.forceValue === this.value) { return } const e = this.editor.plugins.get("TableUtils"); const n = this.editor.model; const i = e.getSelectionAffectedTableCells(n.document.selection); const o = i[0].findAncestor("table"); const { first: r, last: s } = e.getColumnIndexes(i); const a = this.value ? r : s + 1; n.change((t => { if (a) { const e = SH(o, a); for (const { cell: n, column: i } of e) { TH(n, i, a, t) } } tH("headingColumns", a, o, t, 0) })) } } class YH extends wl { static get pluginName() { return "TableUtils" } init() { this.decorate("insertColumns"); this.decorate("insertRows") } getCellLocation(t) { const e = t.parent; const n = e.parent; const i = n.getChildIndex(e); const o = new uH(n, { row: i }); for (const { cell: e, row: n, column: i } of o) { if (e === t) { return { row: n, column: i } } } return undefined } createTable(t, e) { const n = t.createElement("table"); const i = e.rows || 2; const o = e.columns || 2; QH(t, n, 0, i, o); if (e.headingRows) { tH("headingRows", Math.min(e.headingRows, i), n, t, 0) } if (e.headingColumns) { tH("headingColumns", Math.min(e.headingColumns, o), n, t, 0) } return n } insertRows(t, e = {}) { const n = this.editor.model; const i = e.at || 0; const o = e.rows || 1; const r = e.copyStructureFromAbove !== undefined; const s = e.copyStructureFromAbove ? i - 1 : i; const a = this.getRows(t); const c = this.getColumns(t); if (i > a) { throw new I("tableutils-insertrows-insert-out-of-range", this, { options: e }) } n.change((e => { const n = t.getAttribute("headingRows") || 0; if (n > i) { tH("headingRows", n + o, t, e, 0) } if (!r && (i === 0 || i === a)) { QH(e, t, i, o, c); return } const l = r ? Math.max(i, s) : i; const d = new uH(t, { endRow: l }); const u = new Array(c).fill(1); for (const { row: t, column: n, cellHeight: a, cellWidth: c, cell: l } of d) { const d = t + a - 1; const h = t < i && i <= d; const g = t <= s && s <= d; if (h) { e.setAttribute("rowspan", a + o, l); u[n] = -c } else if (r && g) { u[n] = c } } for (let n = 0; n < o; n++) { const n = e.createElement("tableRow"); e.insert(n, t, i); for (let t = 0; t < u.length; t++) { const i = u[t]; const o = e.createPositionAt(n, "end"); if (i > 0) { eH(e, o, i > 1 ? { colspan: i } : undefined) } t += Math.abs(i) - 1 } } })) } insertColumns(t, e = {}) { const n = this.editor.model; const i = e.at || 0; const o = e.columns || 1; n.change((e => { const n = t.getAttribute("headingColumns"); if (i < n) { e.setAttribute("headingColumns", n + o, t) } const r = this.getColumns(t); if (i === 0 || r === i) { for (const n of t.getChildren()) { if (!n.is("element", "tableRow")) { continue } ZH(o, e, e.createPositionAt(n, i ? "end" : 0)) } return } const s = new uH(t, { column: i, includeAllSlots: true }); for (const t of s) { const { row: n, cell: r, cellAnchorColumn: a, cellAnchorRow: c, cellWidth: l, cellHeight: d } = t; if (a < i) { e.setAttribute("colspan", l + o, r); const t = c + d - 1; for (let e = n; e <= t; e++) { s.skipRow(e) } } else { ZH(o, e, t.getPositionBefore()) } } })) } removeRows(t, e) { const n = this.editor.model; const i = e.rows || 1; const o = this.getRows(t); const r = e.at; const s = r + i - 1; if (s > o - 1) { throw new I("tableutils-removerows-row-index-out-of-range", this, { table: t, options: e }) } n.change((e => { const n = { first: r, last: s }; const { cellsToMove: i, cellsToTrim: o } = eU(t, n); if (i.size) { const n = s + 1; nU(t, n, i, e) } for (let n = s; n >= r; n--) { e.remove(t.getChild(n)) } for (const { rowspan: t, cell: n } of o) { tH("rowspan", t, n, e) } tU(t, n, e); if (!BH(t, this)) { LH(t, this) } })) } removeColumns(t, e) { const n = this.editor.model; const i = e.at; const o = e.columns || 1; const r = e.at + o - 1; n.change((e => { XH(t, { first: i, last: r }, e); for (let n = r; n >= i; n--) { for (const { cell: i, column: o, cellWidth: r } of [...new uH(t)]) { if (o <= n && r > 1 && o + r > n) { tH("colspan", r - 1, i, e) } else if (o === n) { e.remove(i) } } } if (!LH(t, this)) { BH(t, this) } })) } splitCellVertically(t, e = 2) { const n = this.editor.model; const i = t.parent; const o = i.parent; const r = parseInt(t.getAttribute("rowspan") || "1"); const s = parseInt(t.getAttribute("colspan") || "1"); n.change((n => { if (s > 1) { const { newCellsSpan: i, updatedSpan: o } = JH(s, e); tH("colspan", o, t, n); const a = {}; if (i > 1) { a.colspan = i } if (r > 1) { a.rowspan = r } const c = s > e ? e - 1 : s - 1; ZH(c, n, n.createPositionAfter(t), a) } if (s < e) { const i = e - s; const a = [...new uH(o)]; const { column: c } = a.find((({ cell: e }) => e === t)); const l = a.filter((({ cell: e, cellWidth: n, column: i }) => { const o = e !== t && i === c; const r = i < c && i + n > c; return o || r })); for (const { cell: t, cellWidth: e } of l) { n.setAttribute("colspan", e + i, t) } const d = {}; if (r > 1) { d.rowspan = r } ZH(i, n, n.createPositionAfter(t), d); const u = o.getAttribute("headingColumns") || 0; if (u > c) { tH("headingColumns", u + i, o, n) } } })) } splitCellHorizontally(t, e = 2) { const n = this.editor.model; const i = t.parent; const o = i.parent; const r = o.getChildIndex(i); const s = parseInt(t.getAttribute("rowspan") || "1"); const a = parseInt(t.getAttribute("colspan") || "1"); n.change((n => { if (s > 1) { const i = [...new uH(o, { startRow: r, endRow: r + s - 1, includeAllSlots: true })]; const { newCellsSpan: c, updatedSpan: l } = JH(s, e); tH("rowspan", l, t, n); const { column: d } = i.find((({ cell: e }) => e === t)); const u = {}; if (c > 1) { u.rowspan = c } if (a > 1) { u.colspan = a } for (const t of i) { const { column: e, row: i } = t; const o = i >= r + l; const s = e === d; const a = (i + r + l) % c === 0; if (o && s && a) { ZH(1, n, t.getPositionBefore(), u) } } } if (s < e) { const i = e - s; const c = [...new uH(o, { startRow: 0, endRow: r })]; for (const { cell: e, cellHeight: o, row: s } of c) { if (e !== t && s + o > r) { const t = o + i; n.setAttribute("rowspan", t, e) } } const l = {}; if (a > 1) { l.colspan = a } QH(n, o, r + 1, i, 1, l); const d = o.getAttribute("headingRows") || 0; if (d > r) { tH("headingRows", d + i, o, n) } } })) } getColumns(t) { const e = t.getChild(0); return [...e.getChildren()].reduce(((t, e) => { const n = parseInt(e.getAttribute("colspan") || "1"); return t + n }), 0) } getRows(t) { return Array.from(t.getChildren()).reduce(((t, e) => e.is("element", "tableRow") ? t + 1 : t), 0) } createTableWalker(t, e = {}) { return new uH(t, e) } getSelectedTableCells(t) { const e = []; for (const n of this.sortRanges(t.getRanges())) { const t = n.getContainedElement(); if (t && t.is("element", "tableCell")) { e.push(t) } } return e } getTableCellsContainingSelection(t) { const e = []; for (const n of t.getRanges()) { const t = n.start.findAncestor("tableCell"); if (t) { e.push(t) } } return e } getSelectionAffectedTableCells(t) { const e = this.getSelectedTableCells(t); if (e.length) { return e } return this.getTableCellsContainingSelection(t) } getRowIndexes(t) { const e = t.map((t => t.parent.index)); return this._getFirstLastIndexesObject(e) } getColumnIndexes(t) { const e = t[0].findAncestor("table"); const n = [...new uH(e)]; const i = n.filter((e => t.includes(e.cell))).map((t => t.column)); return this._getFirstLastIndexesObject(i) } isSelectionRectangular(t) { if (t.length < 2 || !this._areCellInTheSameTableSection(t)) { return false } const e = new Set; const n = new Set; let i = 0; for (const o of t) { const { row: t, column: r } = this.getCellLocation(o); const s = parseInt(o.getAttribute("rowspan")) || 1; const a = parseInt(o.getAttribute("colspan")) || 1; e.add(t); n.add(r); if (s > 1) { e.add(t + s - 1) } if (a > 1) { n.add(r + a - 1) } i += s * a } const o = oU(e, n); return o == i } sortRanges(t) { return Array.from(t).sort(iU) } _getFirstLastIndexesObject(t) { const e = t.sort(((t, e) => t - e)); const n = e[0]; const i = e[e.length - 1]; return { first: n, last: i } } _areCellInTheSameTableSection(t) { const e = t[0].findAncestor("table"); const n = this.getRowIndexes(t); const i = parseInt(e.getAttribute("headingRows")) || 0; if (!this._areIndexesInSameSection(n, i)) { return false } const o = this.getColumnIndexes(t); const r = parseInt(e.getAttribute("headingColumns")) || 0; return this._areIndexesInSameSection(o, r) } _areIndexesInSameSection({ first: t, last: e }, n) { const i = t < n; const o = e < n; return i === o } } function QH(t, e, n, i, o, r = {}) { for (let s = 0; s < i; s++) { const i = t.createElement("tableRow"); t.insert(i, e, n); ZH(o, t, t.createPositionAt(i, "end"), r) } } function ZH(t, e, n, i = {}) { for (let o = 0; o < t; o++) { eH(e, n, i) } } function JH(t, e) { if (t < e) { return { newCellsSpan: 1, updatedSpan: 1 } } const n = Math.floor(t / e); const i = t - n * e + n; return { newCellsSpan: n, updatedSpan: i } } function XH(t, e, n) { const i = t.getAttribute("headingColumns") || 0; if (i && e.first < i) { const o = Math.min(i - 1, e.last) - e.first + 1; n.setAttribute("headingColumns", i - o, t) } } function tU(t, { first: e, last: n }, i) { const o = t.getAttribute("headingRows") || 0; if (e < o) { const r = n < o ? o - (n - e + 1) : e; tH("headingRows", r, t, i, 0) } } function eU(t, { first: e, last: n }) { const i = new Map; const o = []; for (const { row: r, column: s, cellHeight: a, cell: c } of new uH(t, { endRow: n })) { const t = r + a - 1; const l = r >= e && r <= n && t > n; if (l) { const t = n - r + 1; const e = a - t; i.set(s, { cell: c, rowspan: e }) } const d = r < e && t >= e; if (d) { let i; if (t >= n) { i = n - e + 1 } else { i = t - e + 1 } o.push({ cell: c, rowspan: a - i }) } } return { cellsToMove: i, cellsToTrim: o } } function nU(t, e, n, i) { const o = new uH(t, { includeAllSlots: true, row: e }); const r = [...o]; const s = t.getChild(e); let a; for (const { column: t, cell: e, isAnchor: o } of r) { if (n.has(t)) { const { cell: e, rowspan: o } = n.get(t); const r = a ? i.createPositionAfter(a) : i.createPositionAt(s, 0); i.move(i.createRangeOn(e), r); tH("rowspan", o, e, i); a = e } else if (o) { a = e } } } function iU(t, e) { const n = t.start; const i = e.start; return n.isBefore(i) ? -1 : 1 } function oU(t, e) { const n = Array.from(t.values()); const i = Array.from(e.values()); const o = Math.max(...n); const r = Math.min(...n); const s = Math.max(...i); const a = Math.min(...i); return (o - r + 1) * (s - a + 1) } class rU extends _l { refresh() { const t = this.editor.plugins.get(YH); const e = t.getSelectedTableCells(this.editor.model.document.selection); this.isEnabled = t.isSelectionRectangular(e) } execute() { const t = this.editor.model; const e = this.editor.plugins.get(YH); t.change((n => { const i = e.getSelectedTableCells(t.document.selection); const o = i.shift(); const { mergeWidth: r, mergeHeight: s } = cU(o, i, e); tH("colspan", r, o, n); tH("rowspan", s, o, n); for (const t of i) { sU(t, o, n) } const a = o.findAncestor("table"); NH(a, e); n.setSelection(o, "in") })) } } function sU(t, e, n) { if (!aU(t)) { if (aU(e)) { n.remove(n.createRangeIn(e)) } n.move(n.createRangeIn(t), n.createPositionAt(e, "end")) } n.remove(t) } function aU(t) { const e = t.getChild(0); return t.childCount == 1 && e.is("element", "paragraph") && e.isEmpty } function cU(t, e, n) { let i = 0; let o = 0; for (const t of e) { const { row: e, column: r } = n.getCellLocation(t); i = lU(t, r, i, "colspan"); o = lU(t, e, o, "rowspan") } const { row: r, column: s } = n.getCellLocation(t); const a = i - s; const c = o - r; return { mergeWidth: a, mergeHeight: c } } function lU(t, e, n, i) { const o = parseInt(t.getAttribute(i) || "1"); return Math.max(n, e + o) } class dU extends _l { constructor(t) { super(t); this.affectsData = false } refresh() { const t = this.editor.plugins.get("TableUtils"); const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection); this.isEnabled = e.length > 0 } execute() { const t = this.editor.model; const e = this.editor.plugins.get("TableUtils"); const n = e.getSelectionAffectedTableCells(t.document.selection); const i = e.getRowIndexes(n); const o = n[0].findAncestor("table"); const r = []; for (let e = i.first; e <= i.last; e++) { for (const n of o.getChild(e).getChildren()) { r.push(t.createRangeOn(n)) } } t.change((t => { t.setSelection(r) })) } } class uU extends _l { constructor(t) { super(t); this.affectsData = false } refresh() { const t = this.editor.plugins.get("TableUtils"); const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection); this.isEnabled = e.length > 0 } execute() { const t = this.editor.plugins.get("TableUtils"); const e = this.editor.model; const n = t.getSelectionAffectedTableCells(e.document.selection); const i = n[0]; const o = n.pop(); const r = i.findAncestor("table"); const s = t.getCellLocation(i); const a = t.getCellLocation(o); const c = Math.min(s.column, a.column); const l = Math.max(s.column, a.column); const d = []; for (const t of new uH(r, { startColumn: c, endColumn: l })) { d.push(e.createRangeOn(t.cell)) } e.change((t => { t.setSelection(d) })) } } function hU(t) { t.document.registerPostFixer((e => gU(e, t))) } function gU(t, e) { const n = e.document.differ.getChanges(); let i = false; const o = new Set; for (const e of n) { let n = null; if (e.type == "insert" && e.name == "table") { n = e.position.nodeAfter } if ((e.type == "insert" || e.type == "remove") && (e.name == "tableRow" || e.name == "tableCell")) { n = e.position.findAncestor("table") } if (kU(e)) { n = e.range.start.findAncestor("table") } if (n && !o.has(n)) { i = mU(n, t) || i; i = fU(n, t) || i; o.add(n) } } return i } function mU(t, e) { let n = false; const i = pU(t); if (i.length) { n = true; for (const t of i) { tH("rowspan", t.rowspan, t.cell, e, 1) } } return n } function fU(t, e) { let n = false; const i = bU(t); const o = []; for (const [e, n] of i.entries()) { if (!n && t.getChild(e).is("element", "tableRow")) { o.push(e) } } if (o.length) { n = true; for (const n of o.reverse()) { e.remove(t.getChild(n)); i.splice(n, 1) } } const r = i.filter(((e, n) => t.getChild(n).is("element", "tableRow"))); const s = r[0]; const a = r.every((t => t === s)); if (!a) { const i = r.reduce(((t, e) => e > t ? e : t), 0); for (const [o, s] of r.entries()) { const r = i - s; if (r) { for (let n = 0; n < r; n++) { eH(e, e.createPositionAt(t.getChild(o), "end")) } n = true } } } return n } function pU(t) { const e = parseInt(t.getAttribute("headingRows") || "0"); const n = Array.from(t.getChildren()).reduce(((t, e) => e.is("element", "tableRow") ? t + 1 : t), 0); const i = []; for (const { row: o, cell: r, cellHeight: s } of new uH(t)) { if (s < 2) { continue } const t = o < e; const a = t ? e : n; if (o + s > a) { const t = a - o; i.push({ cell: r, rowspan: t }) } } return i } function bU(t) { const e = new Array(t.childCount).fill(0); for (const { rowIndex: n } of new uH(t, { includeAllSlots: true })) { e[n]++ } return e } function kU(t) { if (t.type !== "attribute") { return false } const e = t.attributeKey; return e === "headingRows" || e === "colspan" || e === "rowspan" } function wU(t) { t.document.registerPostFixer((e => AU(e, t))) } function AU(t, e) { const n = e.document.differ.getChanges(); let i = false; for (const e of n) { if (e.type == "insert" && e.name == "table") { i = _U(e.position.nodeAfter, t) || i } if (e.type == "insert" && e.name == "tableRow") { i = CU(e.position.nodeAfter, t) || i } if (e.type == "insert" && e.name == "tableCell") { i = vU(e.position.nodeAfter, t) || i } if ((e.type == "remove" || e.type == "insert") && yU(e)) { i = vU(e.position.parent, t) || i } } return i } function _U(t, e) { let n = false; for (const i of t.getChildren()) { if (i.is("element", "tableRow")) { n = CU(i, e) || n } } return n } function CU(t, e) { let n = false; for (const i of t.getChildren()) { n = vU(i, e) || n } return n } function vU(t, e) { if (t.childCount == 0) { e.insertElement("paragraph", t); return true } const n = Array.from(t.getChildren()).filter((t => t.is("$text"))); for (const t of n) { e.wrap(e.createRangeOn(t), "paragraph") } return !!n.length } function yU(t) { if (!t.position.parent.is("element", "tableCell")) { return false } return t.type == "insert" && t.name == "$text" || t.type == "remove" } function xU(t, e) { const n = t.document.differ; for (const t of n.getChanges()) { let n; let i = false; if (t.type == "attribute") { const e = t.range.start.nodeAfter; if (!e || !e.is("element", "table")) { continue } if (t.attributeKey != "headingRows" && t.attributeKey != "headingColumns") { continue } n = e; i = t.attributeKey == "headingRows" } else if (t.name == "tableRow" || t.name == "tableCell") { n = t.position.findAncestor("table"); i = t.name == "tableRow" } if (!n) { continue } const o = n.getAttribute("headingRows") || 0; const r = n.getAttribute("headingColumns") || 0; const s = new uH(n); for (const t of s) { const n = t.row < o || t.column < r; const s = n ? "th" : "td"; const a = e.mapper.toViewElement(t.cell); if (a && a.is("element") && a.name != s) { e.reconvertItem(i ? t.cell.parent : t.cell) } } } } function EU(t, e) { const n = t.document.differ; const i = new Set; for (const t of n.getChanges()) { const e = t.type == "attribute" ? t.range.start.parent : t.position.parent; if (e.is("element", "tableCell")) { i.add(e) } } for (const t of i.values()) { const n = Array.from(t.getChildren()).filter((t => DU(t, e.mapper))); for (const t of n) { e.reconvertItem(t) } } } function DU(t, e) { if (!t.is("element", "paragraph")) { return false } const n = e.toViewElement(t); if (!n) { return false } return bH(t) !== n.is("element", "span") } var SU = n(4777); var TU = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; TU.insert = "head"; TU.singleton = true; var IU = Sl()(SU.Z, TU); const MU = SU.Z.locals || {}; class BU extends wl { static get pluginName() { return "TableEditing" } static get requires() { return [YH] } constructor(t) { super(t); this._additionalSlots = [] } init() { const t = this.editor; const e = t.model; const n = e.schema; const i = t.conversion; const o = t.plugins.get(YH); n.register("table", { inheritAllFrom: "$blockObject", allowAttributes: ["headingRows", "headingColumns"] }); n.register("tableRow", { allowIn: "table", isLimit: true }); n.register("tableCell", { allowContentOf: "$container", allowIn: "tableRow", allowAttributes: ["colspan", "rowspan"], isLimit: true, isSelectable: true }); i.for("upcast").add(oH()); i.for("upcast").add(rH()); i.for("editingDowncast").elementToStructure({ model: { name: "table", attributes: ["headingRows"] }, view: gH(o, { asWidget: true, additionalSlots: this._additionalSlots }) }); i.for("dataDowncast").elementToStructure({ model: { name: "table", attributes: ["headingRows"] }, view: gH(o, { additionalSlots: this._additionalSlots }) }); i.for("upcast").elementToElement({ model: "tableRow", view: "tr" }); i.for("upcast").add(sH()); i.for("downcast").elementToElement({ model: "tableRow", view: mH() }); i.for("upcast").elementToElement({ model: "tableCell", view: "td" }); i.for("upcast").elementToElement({ model: "tableCell", view: "th" }); i.for("upcast").add(aH("td")); i.for("upcast").add(aH("th")); i.for("editingDowncast").elementToElement({ model: "tableCell", view: fH({ asWidget: true }) }); i.for("dataDowncast").elementToElement({ model: "tableCell", view: fH() }); i.for("editingDowncast").elementToElement({ model: "paragraph", view: pH({ asWidget: true }), converterPriority: "high" }); i.for("dataDowncast").elementToElement({ model: "paragraph", view: pH(), converterPriority: "high" }); i.for("downcast").attributeToAttribute({ model: "colspan", view: "colspan" }); i.for("upcast").attributeToAttribute({ model: { key: "colspan", value: LU("colspan") }, view: "colspan" }); i.for("downcast").attributeToAttribute({ model: "rowspan", view: "rowspan" }); i.for("upcast").attributeToAttribute({ model: { key: "rowspan", value: LU("rowspan") }, view: "rowspan" }); t.config.define("table.defaultHeadings.rows", 0); t.config.define("table.defaultHeadings.columns", 0); t.commands.add("insertTable", new AH(t)); t.commands.add("insertTableRowAbove", new CH(t, { order: "above" })); t.commands.add("insertTableRowBelow", new CH(t, { order: "below" })); t.commands.add("insertTableColumnLeft", new vH(t, { order: "left" })); t.commands.add("insertTableColumnRight", new vH(t, { order: "right" })); t.commands.add("removeTableRow", new HH(t)); t.commands.add("removeTableColumn", new WH(t)); t.commands.add("splitTableCellVertically", new yH(t, { direction: "vertically" })); t.commands.add("splitTableCellHorizontally", new yH(t, { direction: "horizontally" })); t.commands.add("mergeTableCells", new rU(t)); t.commands.add("mergeTableCellRight", new OH(t, { direction: "right" })); t.commands.add("mergeTableCellLeft", new OH(t, { direction: "left" })); t.commands.add("mergeTableCellDown", new OH(t, { direction: "down" })); t.commands.add("mergeTableCellUp", new OH(t, { direction: "up" })); t.commands.add("setTableColumnHeader", new KH(t)); t.commands.add("setTableRowHeader", new $H(t)); t.commands.add("selectTableRow", new dU(t)); t.commands.add("selectTableColumn", new uU(t)); hU(e); wU(e); this.listenTo(e.document, "change:data", (() => { xU(e, t.editing); EU(e, t.editing) })) } registerAdditionalSlot(t) { this._additionalSlots.push(t) } } function LU(t) { return e => { const n = parseInt(e.getAttribute(t)); if (Number.isNaN(n) || n <= 0) { return null } return n } } var NU = n(8085); var zU = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; zU.insert = "head"; zU.singleton = true; var PU = Sl()(NU.Z, zU); const OU = NU.Z.locals || {}; class RU extends N_ { constructor(t) { super(t); const e = this.bindTemplate; this.items = this._createGridCollection(); this.keystrokes = new sl; this.focusTracker = new rl; this.set("rows", 0); this.set("columns", 0); this.bind("label").to(this, "columns", this, "rows", ((t, e) => `${e} × ${t}`)); this.setTemplate({ tag: "div", attributes: { class: ["ck"] }, children: [{ tag: "div", attributes: { class: ["ck-insert-table-dropdown__grid"] }, on: { "mouseover@.ck-insert-table-dropdown-grid-box": e.to("boxover") }, children: this.items }, { tag: "div", attributes: { class: ["ck", "ck-insert-table-dropdown__label"], "aria-hidden": true }, children: [{ text: e.to("label") }] }], on: { mousedown: e.to((t => { t.preventDefault() })), click: e.to((() => { this.fire("execute") })) } }); this.on("boxover", ((t, e) => { const { row: n, column: i } = e.target.dataset; this.items.get((parseInt(n, 10) - 1) * 10 + (parseInt(i, 10) - 1)).focus() })); this.focusTracker.on("change:focusedElement", ((t, e, n) => { if (!n) { return } const { row: i, column: o } = n.dataset; this.set({ rows: parseInt(i), columns: parseInt(o) }) })); this.on("change:columns", (() => this._highlightGridBoxes())); this.on("change:rows", (() => this._highlightGridBoxes())) } render() { super.render(); D_({ keystrokeHandler: this.keystrokes, focusTracker: this.focusTracker, gridItems: this.items, numberOfColumns: 10, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection }); for (const t of this.items) { this.focusTracker.add(t.element) } this.keystrokes.listenTo(this.element) } focus() { this.items.get(0).focus() } focusLast() { this.items.get(0).focus() } _highlightGridBoxes() { const t = this.rows; const e = this.columns; this.items.map(((n, i) => { const o = Math.floor(i / 10); const r = i % 10; const s = o < t && r < e; n.set("isOn", s) })) } _createGridButton(t, e, n, i) { const o = new wC(t); o.set({ label: i, class: "ck-insert-table-dropdown-grid-box" }); o.extendTemplate({ attributes: { "data-row": e, "data-column": n } }); return o } _createGridCollection() { const t = []; for (let e = 0; e < 100; e++) { const n = Math.floor(e / 10); const i = e % 10; const o = `${n + 1} × ${i + 1}`; t.push(this._createGridButton(this.locale, n + 1, i + 1, o)) } return this.createCollection(t) } } const VU = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>'; const jU = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>'; const FU = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>'; const HU = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>'; class UU extends wl { static get pluginName() { return "TableUI" } init() { const t = this.editor; const e = this.editor.t; const n = t.locale.contentLanguageDirection; const i = n === "ltr"; t.ui.componentFactory.add("insertTable", (n => { const i = t.commands.get("insertTable"); const o = Dv(n); o.bind("isEnabled").to(i); o.buttonView.set({ icon: VU, label: e("Insert table"), tooltip: true }); let r; o.on("change:isOpen", (() => { if (r) { return } r = new RU(n); o.panelView.children.add(r); r.delegate("execute").to(o); o.on("execute", (() => { t.execute("insertTable", { rows: r.rows, columns: r.columns }); t.editing.view.focus() })) })); return o })); t.ui.componentFactory.add("tableColumn", (t => { const n = [{ type: "switchbutton", model: { commandName: "setTableColumnHeader", label: e("Header column"), bindIsOn: true } }, { type: "separator" }, { type: "button", model: { commandName: i ? "insertTableColumnLeft" : "insertTableColumnRight", label: e("Insert column left") } }, { type: "button", model: { commandName: i ? "insertTableColumnRight" : "insertTableColumnLeft", label: e("Insert column right") } }, { type: "button", model: { commandName: "removeTableColumn", label: e("Delete column") } }, { type: "button", model: { commandName: "selectTableColumn", label: e("Select column") } }]; return this._prepareDropdown(e("Column"), jU, n, t) })); t.ui.componentFactory.add("tableRow", (t => { const n = [{ type: "switchbutton", model: { commandName: "setTableRowHeader", label: e("Header row"), bindIsOn: true } }, { type: "separator" }, { type: "button", model: { commandName: "insertTableRowAbove", label: e("Insert row above") } }, { type: "button", model: { commandName: "insertTableRowBelow", label: e("Insert row below") } }, { type: "button", model: { commandName: "removeTableRow", label: e("Delete row") } }, { type: "button", model: { commandName: "selectTableRow", label: e("Select row") } }]; return this._prepareDropdown(e("Row"), FU, n, t) })); t.ui.componentFactory.add("mergeTableCells", (t => { const n = [{ type: "button", model: { commandName: "mergeTableCellUp", label: e("Merge cell up") } }, { type: "button", model: { commandName: i ? "mergeTableCellRight" : "mergeTableCellLeft", label: e("Merge cell right") } }, { type: "button", model: { commandName: "mergeTableCellDown", label: e("Merge cell down") } }, { type: "button", model: { commandName: i ? "mergeTableCellLeft" : "mergeTableCellRight", label: e("Merge cell left") } }, { type: "separator" }, { type: "button", model: { commandName: "splitTableCellVertically", label: e("Split cell vertically") } }, { type: "button", model: { commandName: "splitTableCellHorizontally", label: e("Split cell horizontally") } }]; return this._prepareMergeSplitButtonDropdown(e("Merge cells"), HU, n, t) })) } _prepareDropdown(t, e, n, i) { const o = this.editor; const r = Dv(i); const s = this._fillDropdownWithListOptions(r, n); r.buttonView.set({ label: t, icon: e, tooltip: true }); r.bind("isEnabled").toMany(s, "isEnabled", ((...t) => t.some((t => t)))); this.listenTo(r, "execute", (t => { o.execute(t.source.commandName); if (!(t.source instanceof yC)) { o.editing.view.focus() } })); return r } _prepareMergeSplitButtonDropdown(t, e, n, i) { const o = this.editor; const r = Dv(i, YC); const s = "mergeTableCells"; const a = o.commands.get(s); const c = this._fillDropdownWithListOptions(r, n); r.buttonView.set({ label: t, icon: e, tooltip: true, isEnabled: true }); r.bind("isEnabled").toMany([a, ...c], "isEnabled", ((...t) => t.some((t => t)))); this.listenTo(r.buttonView, "execute", (() => { o.execute(s); o.editing.view.focus() })); this.listenTo(r, "execute", (t => { o.execute(t.source.commandName); o.editing.view.focus() })); return r } _fillDropdownWithListOptions(t, e) { const n = this.editor; const i = []; const o = new il; for (const t of e) { WU(t, n, i, o) } Iv(t, o); return i } } function WU(t, e, n, i) { if (t.type === "button" || t.type === "switchbutton") { const i = t.model = new Fy(t.model); const { commandName: o, bindIsOn: r } = t.model; const s = e.commands.get(o); n.push(s); i.set({ commandName: o }); i.bind("isEnabled").to(s); if (r) { i.bind("isOn").to(s, "value") } i.set({ withText: true }) } i.add(t) } var qU = n(5593); var GU = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; GU.insert = "head"; GU.singleton = true; var $U = Sl()(qU.Z, GU); const KU = qU.Z.locals || {}; class YU extends wl { static get pluginName() { return "TableSelection" } static get requires() { return [YH, YH] } init() { const t = this.editor; const e = t.model; const n = t.editing.view; this.listenTo(e, "deleteContent", ((t, e) => this._handleDeleteContent(t, e)), { priority: "high" }); this.listenTo(n.document, "insertText", ((t, e) => this._handleInsertTextEvent(t, e)), { priority: "high" }); this._defineSelectionConverter(); this._enablePluginDisabling() } getSelectedTableCells() { const t = this.editor.plugins.get(YH); const e = this.editor.model.document.selection; const n = t.getSelectedTableCells(e); if (n.length == 0) { return null } return n } getSelectionAsFragment() { const t = this.editor.plugins.get(YH); const e = this.getSelectedTableCells(); if (!e) { return null } return this.editor.model.change((n => { const i = n.createDocumentFragment(); const { first: o, last: r } = t.getColumnIndexes(e); const { first: s, last: a } = t.getRowIndexes(e); const c = e[0].findAncestor("table"); let l = a; let d = r; if (t.isSelectionRectangular(e)) { const t = { firstColumn: o, lastColumn: r, firstRow: s, lastRow: a }; l = zH(c, t); d = PH(c, t) } const u = { startRow: s, startColumn: o, endRow: l, endColumn: d }; const h = xH(c, u, n); n.insert(h, i, 0); return i })) } setCellSelection(t, e) { const n = this._getCellsToSelect(t, e); this.editor.model.change((t => { t.setSelection(n.cells.map((e => t.createRangeOn(e))), { backward: n.backward }) })) } getFocusCell() { const t = this.editor.model.document.selection; const e = [...t.getRanges()].pop(); const n = e.getContainedElement(); if (n && n.is("element", "tableCell")) { return n } return null } getAnchorCell() { const t = this.editor.model.document.selection; const e = ol(t.getRanges()); const n = e.getContainedElement(); if (n && n.is("element", "tableCell")) { return n } return null } _defineSelectionConverter() { const t = this.editor; const e = new Set; t.conversion.for("editingDowncast").add((t => t.on("selection", ((t, i, o) => { const r = o.writer; n(r); const s = this.getSelectedTableCells(); if (!s) { return } for (const t of s) { const n = o.mapper.toViewElement(t); r.addClass("ck-editor__editable_selected", n); e.add(n) } const a = o.mapper.toViewElement(s[s.length - 1]); r.setSelection(a, 0) }), { priority: "lowest" }))); function n(t) { for (const n of e) { t.removeClass("ck-editor__editable_selected", n) } e.clear() } } _enablePluginDisabling() { const t = this.editor; this.on("change:isEnabled", (() => { if (!this.isEnabled) { const e = this.getSelectedTableCells(); if (!e) { return } t.model.change((n => { const i = n.createPositionAt(e[0], 0); const o = t.model.schema.getNearestSelectionRange(i); n.setSelection(o) })) } })) } _handleDeleteContent(t, e) { const n = this.editor.plugins.get(YH); const i = e[0]; const o = e[1]; const r = this.editor.model; const s = !o || o.direction == "backward"; const a = n.getSelectedTableCells(i); if (!a.length) { return } t.stop(); r.change((t => { const e = a[s ? a.length - 1 : 0]; r.change((t => { for (const e of a) { r.deleteContent(t.createSelection(e, "in")) } })); const n = r.schema.getNearestSelectionRange(t.createPositionAt(e, 0)); if (i.is("documentSelection")) { t.setSelection(n) } else { i.setTo(n) } })) } _handleInsertTextEvent(t, e) { const n = this.editor; const i = this.getSelectedTableCells(); if (!i) { return } const o = n.editing.view; const r = n.editing.mapper; const s = i.map((t => o.createRangeOn(r.toViewElement(t)))); e.selection = o.createSelection(s) } _getCellsToSelect(t, e) { const n = this.editor.plugins.get("TableUtils"); const i = n.getCellLocation(t); const o = n.getCellLocation(e); const r = Math.min(i.row, o.row); const s = Math.max(i.row, o.row); const a = Math.min(i.column, o.column); const c = Math.max(i.column, o.column); const l = new Array(s - r + 1).fill(null).map((() => [])); const d = { startRow: r, endRow: s, startColumn: a, endColumn: c }; for (const { row: e, cell: n } of new uH(t.findAncestor("table"), d)) { l[e - r].push(n) } const u = o.row < i.row; const h = o.column < i.column; if (u) { l.reverse() } if (h) { l.forEach((t => t.reverse())) } return { cells: l.flat(), backward: u || h } } } class QU extends wl { static get pluginName() { return "TableClipboard" } static get requires() { return [YU, YH] } init() { const t = this.editor; const e = t.editing.view.document; this.listenTo(e, "copy", ((t, e) => this._onCopyCut(t, e))); this.listenTo(e, "cut", ((t, e) => this._onCopyCut(t, e))); this.listenTo(t.model, "insertContent", ((t, [e, n]) => this._onInsertContent(t, e, n)), { priority: "high" }); this.decorate("_replaceTableSlotCell") } _onCopyCut(t, e) { const n = this.editor.plugins.get(YU); if (!n.getSelectedTableCells()) { return } if (t.name == "cut" && this.editor.isReadOnly) { return } e.preventDefault(); t.stop(); const i = this.editor.data; const o = this.editor.editing.view.document; const r = i.toView(n.getSelectionAsFragment()); o.fire("clipboardOutput", { dataTransfer: e.dataTransfer, content: r, method: t.name }) } _onInsertContent(t, e, n) { if (n && !n.is("documentSelection")) { return } const i = this.editor.model; const o = this.editor.plugins.get(YH); let r = this.getTableIfOnlyTableInContent(e, i); if (!r) { return } const s = o.getSelectionAffectedTableCells(i.document.selection); if (!s.length) { NH(r, o); return } t.stop(); i.change((t => { const e = { width: o.getColumns(r), height: o.getRows(r) }; const n = ZU(s, e, t, o); const i = n.lastRow - n.firstRow + 1; const a = n.lastColumn - n.firstColumn + 1; const c = { startRow: 0, startColumn: 0, endRow: Math.min(i, e.height) - 1, endColumn: Math.min(a, e.width) - 1 }; r = xH(r, c, t); const l = s[0].findAncestor("table"); const d = this._replaceSelectedCellsWithPasted(r, e, l, n, t); if (this.editor.plugins.get("TableSelection").isEnabled) { const e = o.sortRanges(d.map((e => t.createRangeOn(e)))); t.setSelection(e) } else { t.setSelection(d[0], 0) } })) } _replaceSelectedCellsWithPasted(t, e, n, i, o) { const { width: r, height: s } = e; const a = XU(t, r, s); const c = [...new uH(n, { startRow: i.firstRow, endRow: i.lastRow, startColumn: i.firstColumn, endColumn: i.lastColumn, includeAllSlots: true })]; const l = []; let d; for (const t of c) { const { row: e, column: n } = t; if (n === i.firstColumn) { d = t.getPositionBefore() } const c = e - i.firstRow; const u = n - i.firstColumn; const h = a[c % s][u % r]; const g = h ? o.cloneElement(h) : null; const m = this._replaceTableSlotCell(t, g, d, o); if (!m) { continue } IH(m, e, n, i.lastRow, i.lastColumn, o); l.push(m); d = o.createPositionAfter(m) } const u = parseInt(n.getAttribute("headingRows") || "0"); const h = parseInt(n.getAttribute("headingColumns") || "0"); const g = i.firstRow < u && u <= i.lastRow; const m = i.firstColumn < h && h <= i.lastColumn; if (g) { const t = { first: i.firstColumn, last: i.lastColumn }; const e = eW(n, u, t, o, i.firstRow); l.push(...e) } if (m) { const t = { first: i.firstRow, last: i.lastRow }; const e = nW(n, h, t, o); l.push(...e) } return l } _replaceTableSlotCell(t, e, n, i) { const { cell: o, isAnchor: r } = t; if (r) { i.remove(o) } if (!e) { return null } i.insert(e, n); return e } getTableIfOnlyTableInContent(t, e) { if (!t.is("documentFragment") && !t.is("element")) { return null } if (t.is("element", "table")) { return t } if (t.childCount == 1 && t.getChild(0).is("element", "table")) { return t.getChild(0) } const n = e.createRangeIn(t); for (const t of n.getItems()) { if (t.is("element", "table")) { const i = e.createRange(n.start, e.createPositionBefore(t)); if (e.hasContent(i, { ignoreWhitespaces: true })) { return null } const o = e.createRange(e.createPositionAfter(t), n.end); if (e.hasContent(o, { ignoreWhitespaces: true })) { return null } return t } } return null } } function ZU(t, e, n, i) { const o = t[0].findAncestor("table"); const r = i.getColumnIndexes(t); const s = i.getRowIndexes(t); const a = { firstColumn: r.first, lastColumn: r.last, firstRow: s.first, lastRow: s.last }; const c = t.length === 1; if (c) { a.lastRow += e.height - 1; a.lastColumn += e.width - 1; JU(o, a.lastRow + 1, a.lastColumn + 1, i) } if (c || !i.isSelectionRectangular(t)) { tW(o, a, n) } else { a.lastRow = zH(o, a); a.lastColumn = PH(o, a) } return a } function JU(t, e, n, i) { const o = i.getColumns(t); const r = i.getRows(t); if (n > o) { i.insertColumns(t, { at: o, columns: n - o }) } if (e > r) { i.insertRows(t, { at: r, rows: e - r }) } } function XU(t, e, n) { const i = new Array(n).fill(null).map((() => new Array(e).fill(null))); for (const { column: e, row: n, cell: o } of new uH(t)) { i[n][e] = o } return i } function tW(t, e, n) { const { firstRow: i, lastRow: o, firstColumn: r, lastColumn: s } = e; const a = { first: i, last: o }; const c = { first: r, last: s }; nW(t, r, a, n); nW(t, s + 1, a, n); eW(t, i, c, n); eW(t, o + 1, c, n, i) } function eW(t, e, n, i, o = 0) { if (e < 1) { return } const r = EH(t, e, o); const s = r.filter((({ column: t, cellWidth: e }) => iW(t, e, n))); return s.map((({ cell: t }) => DH(t, e, i))) } function nW(t, e, n, i) { if (e < 1) { return } const o = SH(t, e); const r = o.filter((({ row: t, cellHeight: e }) => iW(t, e, n))); return r.map((({ cell: t, column: n }) => TH(t, n, e, i))) } function iW(t, e, n) { const i = t + e - 1; const { first: o, last: r } = n; const s = t >= o && t <= r; const a = t < o && i >= o; return s || a } class oW extends wl { static get pluginName() { return "TableKeyboard" } static get requires() { return [YU, YH] } init() { const t = this.editor.editing.view; const e = t.document; this.listenTo(e, "arrowKey", ((...t) => this._onArrowKey(...t)), { context: "table" }); this.listenTo(e, "tab", ((...t) => this._handleTabOnSelectedTable(...t)), { context: "figure" }); this.listenTo(e, "tab", ((...t) => this._handleTab(...t)), { context: ["th", "td"] }) } _handleTabOnSelectedTable(t, e) { const n = this.editor; const i = n.model.document.selection; const o = i.getSelectedElement(); if (!o || !o.is("element", "table")) { return } e.preventDefault(); e.stopPropagation(); t.stop(); n.model.change((t => { t.setSelection(t.createRangeIn(o.getChild(0).getChild(0))) })) } _handleTab(t, e) { const n = this.editor; const i = this.editor.plugins.get(YH); const o = this.editor.plugins.get("TableSelection"); const r = n.model.document.selection; const s = !e.shiftKey; let a = i.getTableCellsContainingSelection(r)[0]; if (!a) { a = o.getFocusCell() } if (!a) { return } e.preventDefault(); e.stopPropagation(); t.stop(); const c = a.parent; const l = c.parent; const d = l.getChildIndex(c); const u = c.getChildIndex(a); const h = u === 0; if (!s && h && d === 0) { n.model.change((t => { t.setSelection(t.createRangeOn(l)) })); return } const g = u === c.childCount - 1; const m = d === i.getRows(l) - 1; if (s && m && g) { n.execute("insertTableRowBelow"); if (d === i.getRows(l) - 1) { n.model.change((t => { t.setSelection(t.createRangeOn(l)) })); return } } let f; if (s && g) { const t = l.getChild(d + 1); f = t.getChild(0) } else if (!s && h) { const t = l.getChild(d - 1); f = t.getChild(t.childCount - 1) } else { f = c.getChild(u + (s ? 1 : -1)) } n.model.change((t => { t.setSelection(t.createRangeIn(f)) })) } _onArrowKey(t, e) { const n = this.editor; const i = e.keyCode; const o = Hc(i, n.locale.contentLanguageDirection); const r = this._handleArrowKeys(o, e.shiftKey); if (r) { e.preventDefault(); e.stopPropagation(); t.stop() } } _handleArrowKeys(t, e) { const n = this.editor.plugins.get(YH); const i = this.editor.plugins.get("TableSelection"); const o = this.editor.model; const r = o.document.selection; const s = ["right", "down"].includes(t); const a = n.getSelectedTableCells(r); if (a.length) { let n; if (e) { n = i.getFocusCell() } else { n = s ? a[a.length - 1] : a[0] } this._navigateFromCellInDirection(n, t, e); return true } const c = r.focus.findAncestor("tableCell"); if (!c) { return false } if (!r.isCollapsed) { if (e) { if (r.isBackward == s && !r.containsEntireContent(c)) { return false } } else { const t = r.getSelectedElement(); if (!t || !o.schema.isObject(t)) { return false } } } if (this._isSelectionAtCellEdge(r, c, s)) { this._navigateFromCellInDirection(c, t, e); return true } return false } _isSelectionAtCellEdge(t, e, n) { const i = this.editor.model; const o = this.editor.model.schema; const r = n ? t.getLastPosition() : t.getFirstPosition(); if (!o.getLimitElement(r).is("element", "tableCell")) { const t = i.createPositionAt(e, n ? "end" : 0); return t.isTouching(r) } const s = i.createSelection(r); i.modifySelection(s, { direction: n ? "forward" : "backward" }); return r.isEqual(s.focus) } _navigateFromCellInDirection(t, e, n = false) { const i = this.editor.model; const o = t.findAncestor("table"); const r = [...new uH(o, { includeAllSlots: true })]; const { row: s, column: a } = r[r.length - 1]; const c = r.find((({ cell: e }) => e == t)); let { row: l, column: d } = c; switch (e) { case "left": d--; break; case "up": l--; break; case "right": d += c.cellWidth; break; case "down": l += c.cellHeight; break }const u = l < 0 || l > s; const h = d < 0 && l <= 0; const g = d > a && l >= s; if (u || h || g) { i.change((t => { t.setSelection(t.createRangeOn(o)) })); return } if (d < 0) { d = n ? 0 : a; l-- } else if (d > a) { d = n ? a : 0; l++ } const m = r.find((t => t.row == l && t.column == d)).cell; const f = ["right", "down"].includes(e); const p = this.editor.plugins.get("TableSelection"); if (n && p.isEnabled) { const e = p.getAnchorCell() || t; p.setCellSelection(e, m) } else { const t = i.createPositionAt(m, f ? 0 : "end"); i.change((e => { e.setSelection(t) })) } } } class rW extends Sg { constructor() { super(...arguments); this.domEventType = ["mousemove", "mouseleave"] } onDomEvent(t) { this.fire(t.type, t) } } class sW extends wl { static get pluginName() { return "TableMouse" } static get requires() { return [YU, YH] } init() { const t = this.editor; t.editing.view.addObserver(rW); this._enableShiftClickSelection(); this._enableMouseDragSelection() } _enableShiftClickSelection() { const t = this.editor; const e = t.plugins.get(YH); let n = false; const i = t.plugins.get(YU); this.listenTo(t.editing.view.document, "mousedown", ((o, r) => { const s = t.model.document.selection; if (!this.isEnabled || !i.isEnabled) { return } if (!r.domEvent.shiftKey) { return } const a = i.getAnchorCell() || e.getTableCellsContainingSelection(s)[0]; if (!a) { return } const c = this._getModelTableCellFromDomEvent(r); if (c && aW(a, c)) { n = true; i.setCellSelection(a, c); r.preventDefault() } })); this.listenTo(t.editing.view.document, "mouseup", (() => { n = false })); this.listenTo(t.editing.view.document, "selectionChange", (t => { if (n) { t.stop() } }), { priority: "highest" }) } _enableMouseDragSelection() { const t = this.editor; let e, n; let i = false; let o = false; const r = t.plugins.get(YU); this.listenTo(t.editing.view.document, "mousedown", ((t, n) => { if (!this.isEnabled || !r.isEnabled) { return } if (n.domEvent.shiftKey || n.domEvent.ctrlKey || n.domEvent.altKey) { return } e = this._getModelTableCellFromDomEvent(n) })); this.listenTo(t.editing.view.document, "mousemove", ((t, s) => { if (!s.domEvent.buttons) { return } if (!e) { return } const a = this._getModelTableCellFromDomEvent(s); if (a && aW(e, a)) { n = a; if (!i && n != e) { i = true } } if (!i) { return } o = true; r.setCellSelection(e, n); s.preventDefault() })); this.listenTo(t.editing.view.document, "mouseup", (() => { i = false; o = false; e = null; n = null })); this.listenTo(t.editing.view.document, "selectionChange", (t => { if (o) { t.stop() } }), { priority: "highest" }) } _getModelTableCellFromDomEvent(t) { const e = t.target; const n = this.editor.editing.view.createPositionAt(e, 0); const i = this.editor.editing.mapper.toModelPosition(n); const o = i.parent; return o.findAncestor("tableCell", { includeSelf: true }) } } function aW(t, e) { return t.parent.parent == e.parent.parent } var cW = n(4104); var lW = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; lW.insert = "head"; lW.singleton = true; var dW = Sl()(cW.Z, lW); const uW = cW.Z.locals || {}; class hW extends wl { static get requires() { return [BU, UU, YU, sW, oW, QU, oS] } static get pluginName() { return "Table" } } function gW(t) { t.document.registerPostFixer((e => mW(e, t))) } function mW(t, e) { const n = e.document.differ.getChanges(); let i = false; for (const e of n) { if (e.type != "insert") { continue } const n = e.position.parent; if (n.is("element", "table") || e.name == "table") { const o = e.name == "table" ? e.position.nodeAfter : n; const r = Array.from(o.getChildren()).filter((t => t.is("element", "caption"))); const s = r.shift(); if (!s) { continue } for (const e of r) { t.move(t.createRangeIn(e), s, "end"); t.remove(e) } if (s.nextSibling) { t.move(t.createRangeOn(s), o, "end"); i = true } i = !!r.length || i } } return i } function fW(t) { return !!t && t.is("element", "table") } function pW(t) { for (const e of t.getChildren()) { if (e.is("element", "caption")) { return e } } return null } function bW(t) { const e = wW(t); if (!e) { return null } return pW(e) } function kW(t) { const e = t.parent; if (t.name == "figcaption" && e && e.is("element", "figure") && e.hasClass("table")) { return { name: true } } if (t.name == "caption" && e && e.is("element", "table")) { return { name: true } } return null } function wW(t) { const e = t.getSelectedElement(); if (e && e.is("element", "table")) { return e } return t.getFirstPosition().findAncestor("table") } class AW extends _l { refresh() { const t = this.editor; const e = wW(t.model.document.selection); this.isEnabled = !!e; if (!this.isEnabled) { this.value = false } else { this.value = !!pW(e) } } execute({ focusCaptionOnShow: t = false } = {}) { this.editor.model.change((e => { if (this.value) { this._hideTableCaption(e) } else { this._showTableCaption(e, t) } })) } _showTableCaption(t, e) { const n = this.editor.model; const i = wW(n.document.selection); const o = this.editor.plugins.get("TableCaptionEditing"); const r = o._getSavedCaption(i); const s = r || t.createElement("caption"); n.insertContent(s, i, "end"); if (e) { t.setSelection(s, "in") } } _hideTableCaption(t) { const e = this.editor.model; const n = wW(e.document.selection); const i = this.editor.plugins.get("TableCaptionEditing"); const o = pW(n); i._saveCaption(n, o); e.deleteContent(t.createSelection(o, "on")) } } class _W extends wl { static get pluginName() { return "TableCaptionEditing" } constructor(t) { super(t); this._savedCaptionsMap = new WeakMap } init() { const t = this.editor; const e = t.model.schema; const n = t.editing.view; const i = t.t; if (!e.isRegistered("caption")) { e.register("caption", { allowIn: "table", allowContentOf: "$block", isLimit: true }) } else { e.extend("caption", { allowIn: "table" }) } t.commands.add("toggleTableCaption", new AW(this.editor)); t.conversion.for("upcast").elementToElement({ view: kW, model: "caption" }); t.conversion.for("dataDowncast").elementToElement({ model: "caption", view: (t, { writer: e }) => { if (!fW(t.parent)) { return null } return e.createContainerElement("figcaption") } }); t.conversion.for("editingDowncast").elementToElement({ model: "caption", view: (t, { writer: e }) => { if (!fW(t.parent)) { return null } const o = e.createEditableElement("figcaption"); e.setCustomProperty("tableCaption", true, o); Nl({ view: n, element: o, text: i("Enter table caption"), keepOnFocus: true }); return yD(o, e) } }); gW(t.model) } _getSavedCaption(t) { const e = this._savedCaptionsMap.get(t); return e ? gf.fromJSON(e) : null } _saveCaption(t, e) { this._savedCaptionsMap.set(t, e.toJSON()) } } class CW extends wl { static get pluginName() { return "TableCaptionUI" } init() { const t = this.editor; const e = t.editing.view; const n = t.t; t.ui.componentFactory.add("toggleTableCaption", (i => { const o = t.commands.get("toggleTableCaption"); const r = new wC(i); r.set({ icon: v_.caption, tooltip: true, isToggleable: true }); r.bind("isOn", "isEnabled").to(o, "value", "isEnabled"); r.bind("label").to(o, "value", (t => t ? n("Toggle caption off") : n("Toggle caption on"))); this.listenTo(r, "execute", (() => { t.execute("toggleTableCaption", { focusCaptionOnShow: true }); if (o.value) { const n = bW(t.model.document.selection); const i = t.editing.mapper.toViewElement(n); if (!i) { return } e.scrollToTheSelection(); e.change((t => { t.addClass("table__caption_highlighted", i) })) } t.editing.view.focus() })); return r })) } } var vW = n(9888); var yW = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; yW.insert = "head"; yW.singleton = true; var xW = Sl()(vW.Z, yW); const EW = vW.Z.locals || {}; class DW extends wl { static get pluginName() { return "TableCaption" } static get requires() { return [_W, CW] } } var SW = n(4082); var TW = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; TW.insert = "head"; TW.singleton = true; var IW = Sl()(SW.Z, TW); const MW = SW.Z.locals || {}; class BW extends N_ { constructor(t, e) { super(t); this.set("value", ""); this.set("isReadOnly", false); this.set("isFocused", false); this.set("isEmpty", true); this.options = e; this.focusTracker = new rl; this._focusables = new S_; this.dropdownView = this._createDropdownView(); this.inputView = this._createInputTextView(); this.keystrokes = new sl; this._stillTyping = false; this._focusCycler = new QC({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }); this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-input-color"] }, children: [this.dropdownView, this.inputView] }); this.on("change:value", ((t, e, n) => this._setInputValue(n))) } render() { super.render(); this.keystrokes.listenTo(this.dropdownView.panelView.element) } focus() { this.inputView.focus() } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } _createDropdownView() { const t = this.locale; const e = t.t; const n = this.bindTemplate; const i = this._createColorGrid(t); const o = Dv(t); const r = new N_; const s = this._createRemoveColorButton(); r.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-input-color__button__preview"], style: { backgroundColor: n.to("value") } }, children: [{ tag: "span", attributes: { class: ["ck", "ck-input-color__button__preview__no-color-indicator", n.if("value", "ck-hidden", (t => t != ""))] } }] }); o.buttonView.extendTemplate({ attributes: { class: "ck-input-color__button" } }); o.buttonView.children.add(r); o.buttonView.label = e("Color picker"); o.buttonView.tooltip = true; o.panelPosition = t.uiLanguageDirection === "rtl" ? "se" : "sw"; o.panelView.children.add(s); o.panelView.children.add(i); o.bind("isEnabled").to(this, "isReadOnly", (t => !t)); this._focusables.add(s); this._focusables.add(i); this.focusTracker.add(s.element); this.focusTracker.add(i.element); return o } _createInputTextView() { const t = this.locale; const e = new Ty(t); e.extendTemplate({ on: { blur: e.bindTemplate.to("blur") } }); e.value = this.value; e.bind("isReadOnly", "hasError").to(this); this.bind("isFocused", "isEmpty").to(e); e.on("input", (() => { const t = e.element.value; const n = this.options.colorDefinitions.find((e => t === e.label)); this._stillTyping = true; this.value = n && n.color || t })); e.on("blur", (() => { this._stillTyping = false; this._setInputValue(e.element.value) })); e.delegate("input").to(this); return e } _createRemoveColorButton() { const t = this.locale; const e = t.t; const n = new wC(t); const i = this.options.defaultColorValue || ""; const o = i ? e("Restore default") : e("Remove color"); n.class = "ck-input-color__remove-color"; n.withText = true; n.icon = v_.eraser; n.label = o; n.on("execute", (() => { this.value = i; this.dropdownView.isOpen = false; this.fire("input") })); return n } _createColorGrid(t) { const e = new NC(t, { colorDefinitions: this.options.colorDefinitions, columns: this.options.columns }); e.on("execute", ((t, e) => { this.value = e.value; this.dropdownView.isOpen = false; this.fire("input") })); e.bind("selectedColor").to(this, "value"); return e } _setInputValue(t) { if (!this._stillTyping) { const e = LW(t); const n = this.options.colorDefinitions.find((t => e === LW(t.color))); if (n) { this.inputView.value = n.label } else { this.inputView.value = t || "" } } } } function LW(t) { return t.replace(/([(,])\s+/g, "$1").replace(/^\s+|\s+(?=[),\s]|$)/g, "").replace(/,|\s/g, " ") } const NW = t => t === ""; function zW(t) { return { none: t("None"), solid: t("Solid"), dotted: t("Dotted"), dashed: t("Dashed"), double: t("Double"), groove: t("Groove"), ridge: t("Ridge"), inset: t("Inset"), outset: t("Outset") } } function PW(t) { return t('The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".') } function OW(t) { return t('The value is invalid. Try "10px" or "2em" or simply "2".') } function RW(t) { t = t.trim(); return NW(t) || Qw(t) } function VW(t) { t = t.trim(); return NW(t) || qW(t) || tA(t) || nA(t) } function jW(t) { t = t.trim(); return NW(t) || qW(t) || tA(t) } function FW(t, e) { const n = new il; const i = zW(t.t); for (const o in i) { const r = { type: "button", model: new Fy({ _borderStyleValue: o, label: i[o], withText: true }) }; if (o === "none") { r.model.bind("isOn").to(t, "borderStyle", (t => { if (e === "none") { return !t } return t === o })) } else { r.model.bind("isOn").to(t, "borderStyle", (t => t === o)) } n.add(r) } return n } function HW(t) { const { view: e, icons: n, toolbar: i, labels: o, propertyName: r, nameToValue: s, defaultValue: a } = t; for (const t in o) { const c = new wC(e.locale); c.set({ label: o[t], icon: n[t], tooltip: o[t] }); const l = s ? s(t) : t; c.bind("isOn").to(e, r, (t => { let e = t; if (t === "" && a) { e = a } return l === e })); c.on("execute", (() => { e[r] = l })); i.items.add(c) } } const UW = [{ color: "hsl(0, 0%, 0%)", label: "Black" }, { color: "hsl(0, 0%, 30%)", label: "Dim grey" }, { color: "hsl(0, 0%, 60%)", label: "Grey" }, { color: "hsl(0, 0%, 90%)", label: "Light grey" }, { color: "hsl(0, 0%, 100%)", label: "White", hasBorder: true }, { color: "hsl(0, 75%, 60%)", label: "Red" }, { color: "hsl(30, 75%, 60%)", label: "Orange" }, { color: "hsl(60, 75%, 60%)", label: "Yellow" }, { color: "hsl(90, 75%, 60%)", label: "Light green" }, { color: "hsl(120, 75%, 60%)", label: "Green" }, { color: "hsl(150, 75%, 60%)", label: "Aquamarine" }, { color: "hsl(180, 75%, 60%)", label: "Turquoise" }, { color: "hsl(210, 75%, 60%)", label: "Light blue" }, { color: "hsl(240, 75%, 60%)", label: "Blue" }, { color: "hsl(270, 75%, 60%)", label: "Purple" }]; function WW(t) { return (e, n, i) => { const o = new BW(e.locale, { colorDefinitions: GW(t.colorConfig), columns: t.columns, defaultColorValue: t.defaultColorValue }); o.inputView.set({ id: n, ariaDescribedById: i }); o.bind("isReadOnly").to(e, "isEnabled", (t => !t)); o.bind("hasError").to(e, "errorText", (t => !!t)); o.on("input", (() => { e.errorText = null })); e.bind("isEmpty", "isFocused").to(o); return o } } function qW(t) { const e = parseFloat(t); return !Number.isNaN(e) && t === String(e) } function GW(t) { return t.map((t => ({ color: t.model, label: t.label, options: { hasBorder: t.hasBorder } }))) } var $W = n(9865); var KW = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; KW.insert = "head"; KW.singleton = true; var YW = Sl()($W.Z, KW); const QW = $W.Z.locals || {}; class ZW extends N_ { constructor(t, e = {}) { super(t); const n = this.bindTemplate; this.set("class", e.class || null); this.children = this.createCollection(); if (e.children) { e.children.forEach((t => this.children.add(t))) } this.set("_role", null); this.set("_ariaLabelledBy", null); if (e.labelView) { this.set({ _role: "group", _ariaLabelledBy: e.labelView.id }) } this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-form__row", n.to("class")], role: n.to("_role"), "aria-labelledby": n.to("_ariaLabelledBy") }, children: this.children }) } } var JW = n(4880); var XW = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; XW.insert = "head"; XW.singleton = true; var tq = Sl()(JW.Z, XW); const eq = JW.Z.locals || {}; var nq = n(198); var iq = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; iq.insert = "head"; iq.singleton = true; var oq = Sl()(nq.Z, iq); const rq = nq.Z.locals || {}; var sq = n(5737); var aq = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; aq.insert = "head"; aq.singleton = true; var cq = Sl()(sq.Z, aq); const lq = sq.Z.locals || {}; const dq = { left: v_.alignLeft, center: v_.alignCenter, right: v_.alignRight, justify: v_.alignJustify, top: v_.alignTop, middle: v_.alignMiddle, bottom: v_.alignBottom }; class uq extends N_ { constructor(t, e) { super(t); this.set({ borderStyle: "", borderWidth: "", borderColor: "", padding: "", backgroundColor: "", width: "", height: "", horizontalAlignment: "", verticalAlignment: "" }); this.options = e; const { borderStyleDropdown: n, borderWidthInput: i, borderColorInput: o, borderRowLabel: r } = this._createBorderFields(); const { backgroundRowLabel: s, backgroundInput: a } = this._createBackgroundFields(); const { widthInput: c, operatorLabel: l, heightInput: d, dimensionsLabel: u } = this._createDimensionFields(); const { horizontalAlignmentToolbar: h, verticalAlignmentToolbar: g, alignmentLabel: m } = this._createAlignmentFields(); this.focusTracker = new rl; this.keystrokes = new sl; this.children = this.createCollection(); this.borderStyleDropdown = n; this.borderWidthInput = i; this.borderColorInput = o; this.backgroundInput = a; this.paddingInput = this._createPaddingField(); this.widthInput = c; this.heightInput = d; this.horizontalAlignmentToolbar = h; this.verticalAlignmentToolbar = g; const { saveButtonView: f, cancelButtonView: p } = this._createActionButtons(); this.saveButtonView = f; this.cancelButtonView = p; this._focusables = new S_; this._focusCycler = new QC({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }); this.children.add(new Cy(t, { label: this.t("Cell properties") })); this.children.add(new ZW(t, { labelView: r, children: [r, n, o, i], class: "ck-table-form__border-row" })); this.children.add(new ZW(t, { labelView: s, children: [s, a], class: "ck-table-form__background-row" })); this.children.add(new ZW(t, { children: [new ZW(t, { labelView: u, children: [u, c, l, d], class: "ck-table-form__dimensions-row" }), new ZW(t, { children: [this.paddingInput], class: "ck-table-cell-properties-form__padding-row" })] })); this.children.add(new ZW(t, { labelView: m, children: [m, h, g], class: "ck-table-cell-properties-form__alignment-row" })); this.children.add(new ZW(t, { children: [this.saveButtonView, this.cancelButtonView], class: "ck-table-form__action-row" })); this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-form", "ck-table-form", "ck-table-cell-properties-form"], tabindex: "-1" }, children: this.children }) } render() { super.render(); E_({ view: this });[this.borderStyleDropdown, this.borderColorInput, this.borderColorInput.fieldView.dropdownView.buttonView, this.borderWidthInput, this.backgroundInput, this.backgroundInput.fieldView.dropdownView.buttonView, this.widthInput, this.heightInput, this.paddingInput, this.horizontalAlignmentToolbar, this.verticalAlignmentToolbar, this.saveButtonView, this.cancelButtonView].forEach((t => { this._focusables.add(t); this.focusTracker.add(t.element) })); this.keystrokes.listenTo(this.element) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } focus() { this._focusCycler.focusFirst() } _createBorderFields() { const t = this.options.defaultTableCellProperties; const e = { style: t.borderStyle, width: t.borderWidth, color: t.borderColor }; const n = WW({ colorConfig: this.options.borderColors, columns: 5, defaultColorValue: e.color }); const i = this.locale; const o = this.t; const r = new my(i); r.text = o("Border"); const s = zW(o); const a = new Py(i, Vy); a.set({ label: o("Style"), class: "ck-table-form__border-style" }); a.fieldView.buttonView.set({ isOn: false, withText: true, tooltip: o("Style") }); a.fieldView.buttonView.bind("label").to(this, "borderStyle", (t => s[t ? t : "none"])); a.fieldView.on("execute", (t => { this.borderStyle = t.source._borderStyleValue })); a.bind("isEmpty").to(this, "borderStyle", (t => !t)); Iv(a.fieldView, FW(this, e.style)); const c = new Py(i, Oy); c.set({ label: o("Width"), class: "ck-table-form__border-width" }); c.fieldView.bind("value").to(this, "borderWidth"); c.bind("isEnabled").to(this, "borderStyle", hq); c.fieldView.on("input", (() => { this.borderWidth = c.fieldView.element.value })); const l = new Py(i, n); l.set({ label: o("Color"), class: "ck-table-form__border-color" }); l.fieldView.bind("value").to(this, "borderColor"); l.bind("isEnabled").to(this, "borderStyle", hq); l.fieldView.on("input", (() => { this.borderColor = l.fieldView.value })); this.on("change:borderStyle", ((t, n, i, o) => { if (!hq(i)) { this.borderColor = ""; this.borderWidth = "" } if (!hq(o)) { this.borderColor = e.color; this.borderWidth = e.width } })); return { borderRowLabel: r, borderStyleDropdown: a, borderColorInput: l, borderWidthInput: c } } _createBackgroundFields() { const t = this.locale; const e = this.t; const n = new my(t); n.text = e("Background"); const i = WW({ colorConfig: this.options.backgroundColors, columns: 5, defaultColorValue: this.options.defaultTableCellProperties.backgroundColor }); const o = new Py(t, i); o.set({ label: e("Color"), class: "ck-table-cell-properties-form__background" }); o.fieldView.bind("value").to(this, "backgroundColor"); o.fieldView.on("input", (() => { this.backgroundColor = o.fieldView.value })); return { backgroundRowLabel: n, backgroundInput: o } } _createDimensionFields() { const t = this.locale; const e = this.t; const n = new my(t); n.text = e("Dimensions"); const i = new Py(t, Oy); i.set({ label: e("Width"), class: "ck-table-form__dimensions-row__width" }); i.fieldView.bind("value").to(this, "width"); i.fieldView.on("input", (() => { this.width = i.fieldView.element.value })); const o = new N_(t); o.setTemplate({ tag: "span", attributes: { class: ["ck-table-form__dimension-operator"] }, children: [{ text: "×" }] }); const r = new Py(t, Oy); r.set({ label: e("Height"), class: "ck-table-form__dimensions-row__height" }); r.fieldView.bind("value").to(this, "height"); r.fieldView.on("input", (() => { this.height = r.fieldView.element.value })); return { dimensionsLabel: n, widthInput: i, operatorLabel: o, heightInput: r } } _createPaddingField() { const t = this.locale; const e = this.t; const n = new Py(t, Oy); n.set({ label: e("Padding"), class: "ck-table-cell-properties-form__padding" }); n.fieldView.bind("value").to(this, "padding"); n.fieldView.on("input", (() => { this.padding = n.fieldView.element.value })); return n } _createAlignmentFields() { const t = this.locale; const e = this.t; const n = new my(t); n.text = e("Table cell text alignment"); const i = new cv(t); const o = t.contentLanguageDirection === "rtl"; i.set({ isCompact: true, ariaLabel: e("Horizontal text alignment toolbar") }); HW({ view: this, icons: dq, toolbar: i, labels: this._horizontalAlignmentLabels, propertyName: "horizontalAlignment", nameToValue: t => { if (o) { if (t === "left") { return "right" } else if (t === "right") { return "left" } } return t }, defaultValue: this.options.defaultTableCellProperties.horizontalAlignment }); const r = new cv(t); r.set({ isCompact: true, ariaLabel: e("Vertical text alignment toolbar") }); HW({ view: this, icons: dq, toolbar: r, labels: this._verticalAlignmentLabels, propertyName: "verticalAlignment", defaultValue: this.options.defaultTableCellProperties.verticalAlignment }); return { horizontalAlignmentToolbar: i, verticalAlignmentToolbar: r, alignmentLabel: n } } _createActionButtons() { const t = this.locale; const e = this.t; const n = new wC(t); const i = new wC(t); const o = [this.borderWidthInput, this.borderColorInput, this.backgroundInput, this.paddingInput]; n.set({ label: e("Save"), icon: v_.check, class: "ck-button-save", type: "submit", withText: true }); n.bind("isEnabled").toMany(o, "errorText", ((...t) => t.every((t => !t)))); i.set({ label: e("Cancel"), icon: v_.cancel, class: "ck-button-cancel", withText: true }); i.delegate("execute").to(this, "cancel"); return { saveButtonView: n, cancelButtonView: i } } get _horizontalAlignmentLabels() { const t = this.locale; const e = this.t; const n = e("Align cell text to the left"); const i = e("Align cell text to the center"); const o = e("Align cell text to the right"); const r = e("Justify cell text"); if (t.uiLanguageDirection === "rtl") { return { right: o, center: i, left: n, justify: r } } else { return { left: n, center: i, right: o, justify: r } } } get _verticalAlignmentLabels() { const t = this.t; return { top: t("Align cell text to the top"), middle: t("Align cell text to the middle"), bottom: t("Align cell text to the bottom") } } } function hq(t) { return t !== "none" } function gq(t) { const e = t.getSelectedElement(); if (e && fq(e)) { return e } return null } function mq(t) { const e = t.getFirstPosition(); if (!e) { return null } let n = e.parent; while (n) { if (n.is("element") && fq(n)) { return n } n = n.parent } return null } function fq(t) { return !!t.getCustomProperty("table") && bD(t) } const pq = Gv.defaultPositions; const bq = [pq.northArrowSouth, pq.northArrowSouthWest, pq.northArrowSouthEast, pq.southArrowNorth, pq.southArrowNorthWest, pq.southArrowNorthEast, pq.viewportStickyNorth]; function kq(t, e) { const n = t.plugins.get("ContextualBalloon"); if (mq(t.editing.view.document.selection)) { let i; if (e === "cell") { i = Aq(t) } else { i = wq(t) } n.updatePosition(i) } } function wq(t) { const e = t.model.document.selection.getFirstPosition(); const n = e.findAncestor("table"); const i = t.editing.mapper.toViewElement(n); return { target: t.editing.view.domConverter.mapViewToDom(i), positions: bq } } function Aq(t) { const e = t.editing.mapper; const n = t.editing.view.domConverter; const i = t.model.document.selection; if (i.rangeCount > 1) { return { target: () => Cq(i.getRanges(), t), positions: bq } } const o = _q(i.getFirstPosition()); const r = e.toViewElement(o); return { target: n.mapViewToDom(r), positions: bq } } function _q(t) { const e = t.nodeAfter && t.nodeAfter.is("element", "tableCell"); return e ? t.nodeAfter : t.findAncestor("tableCell") } function Cq(t, e) { const n = e.editing.mapper; const i = e.editing.view.domConverter; const o = Array.from(t).map((t => { const e = _q(t.start); const o = n.toViewElement(e); return new oc(i.mapViewToDom(o)) })); return oc.getBoundingRect(o) } const vq = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.105 18-.17 1H2.5A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1h15A1.5 1.5 0 0 1 19 2.5v9.975l-.85-.124-.15-.302V8h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5h3.105zM2 12h5V8H2v4zm10-4H8v4h4V8zM2 2v5h5V2H2zm0 16h5v-5H2v5zM13 7h5V2h-5v5zM8 2v5h4V2H8z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM13 6a1 1 0 0 1 1 1v3.172a2.047 2.047 0 0 0-.293.443l-.858 1.736-1.916.28-.151.027A1.976 1.976 0 0 0 9.315 14H7a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h6zm-1 2H8v4h4V8z"/></svg>'; function yq(t) { if (!t || !nt(t)) { return t } const { top: e, right: n, bottom: i, left: o } = t; if (e == n && n == i && i == o) { return e } } function xq(t, e) { const n = parseFloat(t); if (Number.isNaN(n)) { return t } if (String(n) !== String(t)) { return t } return `${n}${e}` } function Eq(t, e = {}) { const n = { borderStyle: "none", borderWidth: "", borderColor: "", backgroundColor: "", width: "", height: "", ...t }; if (e.includeAlignmentProperty && !n.alignment) { n.alignment = "center" } if (e.includePaddingProperty && !n.padding) { n.padding = "" } if (e.includeVerticalAlignmentProperty && !n.verticalAlignment) { n.verticalAlignment = "middle" } if (e.includeHorizontalAlignmentProperty && !n.horizontalAlignment) { n.horizontalAlignment = e.isRightToLeftContent ? "right" : "left" } return n } const Dq = 500; const Sq = { borderStyle: "tableCellBorderStyle", borderColor: "tableCellBorderColor", borderWidth: "tableCellBorderWidth", height: "tableCellHeight", width: "tableCellWidth", padding: "tableCellPadding", backgroundColor: "tableCellBackgroundColor", horizontalAlignment: "tableCellHorizontalAlignment", verticalAlignment: "tableCellVerticalAlignment" }; class Tq extends wl { static get requires() { return [Xy] } static get pluginName() { return "TableCellPropertiesUI" } constructor(t) { super(t); t.config.define("table.tableCellProperties", { borderColors: UW, backgroundColors: UW }) } init() { const t = this.editor; const e = t.t; this._defaultTableCellProperties = Eq(t.config.get("table.tableCellProperties.defaultProperties"), { includeVerticalAlignmentProperty: true, includeHorizontalAlignmentProperty: true, includePaddingProperty: true, isRightToLeftContent: t.locale.contentLanguageDirection === "rtl" }); this._balloon = t.plugins.get(Xy); this.view = null; this._isReady = false; t.ui.componentFactory.add("tableCellProperties", (n => { const i = new wC(n); i.set({ label: e("Cell properties"), icon: vq, tooltip: true }); this.listenTo(i, "execute", (() => this._showView())); const o = Object.values(Sq).map((e => t.commands.get(e))); i.bind("isEnabled").toMany(o, "isEnabled", ((...t) => t.some((t => t)))); return i })) } destroy() { super.destroy(); if (this.view) { this.view.destroy() } } _createPropertiesView() { const t = this.editor; const e = t.config.get("table.tableCellProperties"); const n = EC(e.borderColors); const i = xC(t.locale, n); const o = EC(e.backgroundColors); const r = xC(t.locale, o); const s = new uq(t.locale, { borderColors: i, backgroundColors: r, defaultTableCellProperties: this._defaultTableCellProperties }); const a = t.t; s.render(); this.listenTo(s, "submit", (() => { this._hideView() })); this.listenTo(s, "cancel", (() => { if (this._undoStepBatch.operations.length) { t.execute("undo", this._undoStepBatch) } this._hideView() })); s.keystrokes.set("Esc", ((t, e) => { this._hideView(); e() })); y_({ emitter: s, activator: () => this._isViewInBalloon, contextElements: [this._balloon.view.element], callback: () => this._hideView() }); const c = PW(a); const l = OW(a); s.on("change:borderStyle", this._getPropertyChangeCallback("tableCellBorderStyle")); s.on("change:borderColor", this._getValidatedPropertyChangeCallback({ viewField: s.borderColorInput, commandName: "tableCellBorderColor", errorText: c, validator: RW })); s.on("change:borderWidth", this._getValidatedPropertyChangeCallback({ viewField: s.borderWidthInput, commandName: "tableCellBorderWidth", errorText: l, validator: jW })); s.on("change:padding", this._getValidatedPropertyChangeCallback({ viewField: s.paddingInput, commandName: "tableCellPadding", errorText: l, validator: VW })); s.on("change:width", this._getValidatedPropertyChangeCallback({ viewField: s.widthInput, commandName: "tableCellWidth", errorText: l, validator: VW })); s.on("change:height", this._getValidatedPropertyChangeCallback({ viewField: s.heightInput, commandName: "tableCellHeight", errorText: l, validator: VW })); s.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({ viewField: s.backgroundInput, commandName: "tableCellBackgroundColor", errorText: c, validator: RW })); s.on("change:horizontalAlignment", this._getPropertyChangeCallback("tableCellHorizontalAlignment")); s.on("change:verticalAlignment", this._getPropertyChangeCallback("tableCellVerticalAlignment")); return s } _fillViewFormFromCommandValues() { const t = this.editor.commands; const e = t.get("tableCellBorderStyle"); Object.entries(Sq).map((([e, n]) => { const i = this._defaultTableCellProperties[e] || ""; return [e, t.get(n).value || i] })).forEach((([t, n]) => { if ((t === "borderColor" || t === "borderWidth") && e.value === "none") { return } this.view.set(t, n) })); this._isReady = true } _showView() { const t = this.editor; if (!this.view) { this.view = this._createPropertiesView() } this.listenTo(t.ui, "update", (() => { this._updateView() })); this._fillViewFormFromCommandValues(); this._balloon.add({ view: this.view, position: Aq(t) }); this._undoStepBatch = t.model.createBatch(); this.view.focus() } _hideView() { const t = this.editor; this.stopListening(t.ui, "update"); this._isReady = false; this.view.saveButtonView.focus(); this._balloon.remove(this.view); this.editor.editing.view.focus() } _updateView() { const t = this.editor; const e = t.editing.view.document; if (!mq(e.selection)) { this._hideView() } else if (this._isViewVisible) { kq(t, "cell") } } get _isViewVisible() { return !!this.view && this._balloon.visibleView === this.view } get _isViewInBalloon() { return !!this.view && this._balloon.hasView(this.view) } _getPropertyChangeCallback(t) { return (e, n, i) => { if (!this._isReady) { return } this.editor.execute(t, { value: i, batch: this._undoStepBatch }) } } _getValidatedPropertyChangeCallback(t) { const { commandName: e, viewField: n, validator: i, errorText: o } = t; const r = Yg((() => { n.errorText = o }), Dq); return (t, o, s) => { r.cancel(); if (!this._isReady) { return } if (i(s)) { this.editor.execute(e, { value: s, batch: this._undoStepBatch }); n.errorText = null } else { r() } } } } class Iq extends _l { constructor(t, e, n) { super(t); this.attributeName = e; this._defaultValue = n } refresh() { const t = this.editor; const e = this.editor.plugins.get("TableUtils"); const n = e.getSelectionAffectedTableCells(t.model.document.selection); this.isEnabled = !!n.length; this.value = this._getSingleValue(n) } execute(t = {}) { const { value: e, batch: n } = t; const i = this.editor.model; const o = this.editor.plugins.get("TableUtils"); const r = o.getSelectionAffectedTableCells(i.document.selection); const s = this._getValueToSet(e); i.enqueueChange(n, (t => { if (s) { r.forEach((e => t.setAttribute(this.attributeName, s, e))) } else { r.forEach((e => t.removeAttribute(this.attributeName, e))) } })) } _getAttribute(t) { if (!t) { return } const e = t.getAttribute(this.attributeName); if (e === this._defaultValue) { return } return e } _getValueToSet(t) { if (t === this._defaultValue) { return } return t } _getSingleValue(t) { const e = this._getAttribute(t[0]); const n = t.every((t => this._getAttribute(t) === e)); return n ? e : undefined } } class Mq extends Iq { constructor(t, e) { super(t, "tableCellWidth", e) } _getValueToSet(t) { t = xq(t, "px"); if (t === this._defaultValue) { return } return t } } class Bq extends wl { static get pluginName() { return "TableCellWidthEditing" } static get requires() { return [BU] } init() { const t = this.editor; const e = Eq(t.config.get("table.tableCellProperties.defaultProperties")); iH(t.model.schema, t.conversion, { modelAttribute: "tableCellWidth", styleName: "width", defaultValue: e.width }); t.commands.add("tableCellWidth", new Mq(t, e.width)) } } class Lq extends Iq { constructor(t, e) { super(t, "tableCellPadding", e) } _getAttribute(t) { if (!t) { return } const e = yq(t.getAttribute(this.attributeName)); if (e === this._defaultValue) { return } return e } _getValueToSet(t) { const e = xq(t, "px"); if (e === this._defaultValue) { return } return e } } class Nq extends Iq { constructor(t, e) { super(t, "tableCellHeight", e) } _getValueToSet(t) { const e = xq(t, "px"); if (e === this._defaultValue) { return } return e } } class zq extends Iq { constructor(t, e) { super(t, "tableCellBackgroundColor", e) } } class Pq extends Iq { constructor(t, e) { super(t, "tableCellVerticalAlignment", e) } } class Oq extends Iq { constructor(t, e) { super(t, "tableCellHorizontalAlignment", e) } } class Rq extends Iq { constructor(t, e) { super(t, "tableCellBorderStyle", e) } _getAttribute(t) { if (!t) { return } const e = yq(t.getAttribute(this.attributeName)); if (e === this._defaultValue) { return } return e } } class Vq extends Iq { constructor(t, e) { super(t, "tableCellBorderColor", e) } _getAttribute(t) { if (!t) { return } const e = yq(t.getAttribute(this.attributeName)); if (e === this._defaultValue) { return } return e } } class jq extends Iq { constructor(t, e) { super(t, "tableCellBorderWidth", e) } _getAttribute(t) { if (!t) { return } const e = yq(t.getAttribute(this.attributeName)); if (e === this._defaultValue) { return } return e } _getValueToSet(t) { const e = xq(t, "px"); if (e === this._defaultValue) { return } return e } } const Fq = /^(top|middle|bottom)$/; const Hq = /^(left|center|right|justify)$/; class Uq extends wl { static get pluginName() { return "TableCellPropertiesEditing" } static get requires() { return [BU, Bq] } init() { const t = this.editor; const e = t.model.schema; const n = t.conversion; t.config.define("table.tableCellProperties.defaultProperties", {}); const i = Eq(t.config.get("table.tableCellProperties.defaultProperties"), { includeVerticalAlignmentProperty: true, includeHorizontalAlignmentProperty: true, includePaddingProperty: true, isRightToLeftContent: t.locale.contentLanguageDirection === "rtl" }); t.data.addStyleProcessorRules(AA); Wq(e, n, { color: i.borderColor, style: i.borderStyle, width: i.borderWidth }); t.commands.add("tableCellBorderStyle", new Rq(t, i.borderStyle)); t.commands.add("tableCellBorderColor", new Vq(t, i.borderColor)); t.commands.add("tableCellBorderWidth", new jq(t, i.borderWidth)); iH(e, n, { modelAttribute: "tableCellHeight", styleName: "height", defaultValue: i.height }); t.commands.add("tableCellHeight", new Nq(t, i.height)); t.data.addStyleProcessorRules(LA); iH(e, n, { modelAttribute: "tableCellPadding", styleName: "padding", reduceBoxSides: true, defaultValue: i.padding }); t.commands.add("tableCellPadding", new Lq(t, i.padding)); t.data.addStyleProcessorRules(pA); iH(e, n, { modelAttribute: "tableCellBackgroundColor", styleName: "background-color", defaultValue: i.backgroundColor }); t.commands.add("tableCellBackgroundColor", new zq(t, i.backgroundColor)); qq(e, n, i.horizontalAlignment); t.commands.add("tableCellHorizontalAlignment", new Oq(t, i.horizontalAlignment)); Gq(e, n, i.verticalAlignment); t.commands.add("tableCellVerticalAlignment", new Pq(t, i.verticalAlignment)) } } function Wq(t, e, n) { const i = { width: "tableCellBorderWidth", color: "tableCellBorderColor", style: "tableCellBorderStyle" }; t.extend("tableCell", { allowAttributes: Object.values(i) }); QF(e, "td", i, n); QF(e, "th", i, n); ZF(e, { modelElement: "tableCell", modelAttribute: i.style, styleName: "border-style" }); ZF(e, { modelElement: "tableCell", modelAttribute: i.color, styleName: "border-color" }); ZF(e, { modelElement: "tableCell", modelAttribute: i.width, styleName: "border-width" }) } function qq(t, e, n) { t.extend("tableCell", { allowAttributes: ["tableCellHorizontalAlignment"] }); e.for("downcast").attributeToAttribute({ model: { name: "tableCell", key: "tableCellHorizontalAlignment" }, view: t => ({ key: "style", value: { "text-align": t } }) }); e.for("upcast").attributeToAttribute({ view: { name: /^(td|th)$/, styles: { "text-align": Hq } }, model: { key: "tableCellHorizontalAlignment", value: t => { const e = t.getStyle("text-align"); return e === n ? null : e } } }).attributeToAttribute({ view: { name: /^(td|th)$/, attributes: { align: Hq } }, model: { key: "tableCellHorizontalAlignment", value: t => { const e = t.getAttribute("align"); return e === n ? null : e } } }) } function Gq(t, e, n) { t.extend("tableCell", { allowAttributes: ["tableCellVerticalAlignment"] }); e.for("downcast").attributeToAttribute({ model: { name: "tableCell", key: "tableCellVerticalAlignment" }, view: t => ({ key: "style", value: { "vertical-align": t } }) }); e.for("upcast").attributeToAttribute({ view: { name: /^(td|th)$/, styles: { "vertical-align": Fq } }, model: { key: "tableCellVerticalAlignment", value: t => { const e = t.getStyle("vertical-align"); return e === n ? null : e } } }).attributeToAttribute({ view: { name: /^(td|th)$/, attributes: { valign: Fq } }, model: { key: "tableCellVerticalAlignment", value: t => { const e = t.getAttribute("valign"); return e === n ? null : e } } }) } class $q extends wl { static get pluginName() { return "TableCellProperties" } static get requires() { return [Uq, Tq] } } const Kq = 5; const Yq = 40; const Qq = 2; function Zq(t) { const e = new Set; for (const n of t.document.differ.getChanges()) { let i = null; switch (n.type) { case "insert": i = ["table", "tableRow", "tableCell"].includes(n.name) ? n.position : null; break; case "remove": i = ["tableRow", "tableCell"].includes(n.name) ? n.position : null; break; case "attribute": if (n.range.start.nodeAfter) { i = ["table", "tableRow", "tableCell"].includes(n.range.start.nodeAfter.name) ? n.range.start : null } break }if (!i) { continue } const o = i.nodeAfter && i.nodeAfter.is("element", "table") ? i.nodeAfter : i.findAncestor("table"); for (const n of t.createRangeOn(o).getItems()) { if (!n.is("element", "table")) { continue } if (!uG(n)) { continue } e.add(n) } } return e } function Jq(t, e) { return Yq * 100 / Xq(t, e) } function Xq(t, e) { const n = tG(t, "tbody", e) || tG(t, "thead", e); const i = e.editing.view.domConverter.mapViewToDom(n); return eG(i) } function tG(t, e, n) { const i = n.editing.mapper.toViewElement(t); const o = [...i.getChildren()].find((t => t.is("element", "table"))); return [...o.getChildren()].find((t => t.is("element", e))) } function eG(t) { const e = Za.window.getComputedStyle(t); if (e.boxSizing === "border-box") { return parseFloat(e.width) - parseFloat(e.paddingLeft) - parseFloat(e.paddingRight) - parseFloat(e.borderLeftWidth) - parseFloat(e.borderRightWidth) } else { return parseFloat(e.width) } } function nG(t, e) { const n = e.getCellLocation(t).column; const i = t.getAttribute("colspan") || 1; return { leftEdge: n, rightEdge: n + i - 1 } } function iG(t) { const e = Math.pow(10, Qq); const n = typeof t === "number" ? t : parseFloat(t); return Math.round(n * e) / e } function oG(t, e, n) { if (t <= e) { return iG(e) } if (t >= n) { return iG(n) } return iG(t) } function rG(t, e) { return Array(t).fill(e) } function sG(t) { return t.map((t => typeof t === "number" ? t : parseFloat(t))).filter((t => !Number.isNaN(t))).reduce(((t, e) => t + e), 0) } function aG(t) { const e = t.map((t => { if (t === "auto") { return t } return parseFloat(t.replace("%", "")) })); let n = cG(e); const i = sG(n); if (i !== 100) { n = n.map((t => iG(t * 100 / i))).map(((t, e, n) => { const i = e === n.length - 1; if (!i) { return t } const o = sG(n); return iG(t + 100 - o) })) } return n.map((t => t + "%")) } function cG(t) { const e = t.filter((t => t === "auto")).length; if (e === 0) { return t.map((t => iG(t))) } const n = sG(t); const i = Math.max((100 - n) / e, Kq); return t.map((t => t === "auto" ? i : t)).map((t => iG(t))) } function lG(t) { const e = Za.window.getComputedStyle(t); if (e.boxSizing === "border-box") { return parseInt(e.width) } else { return parseFloat(e.width) + parseFloat(e.paddingLeft) + parseFloat(e.paddingRight) + parseFloat(e.borderWidth) } } function dG(t, e, n, i) { for (let o = 0; o < Math.max(n.length, t.length); o++) { const r = t[o]; const s = n[o]; if (!s) { i.remove(r) } else if (!r) { i.appendElement("tableColumn", { columnWidth: s }, e) } else { i.setAttribute("columnWidth", s, r) } } } function uG(t) { if (t.is("element", "tableColumnGroup")) { return t } const e = t.getChildren(); return Array.from(e).find((t => t.is("element", "tableColumnGroup"))) } function hG(t) { return Array.from(uG(t).getChildren()) } function gG(t) { return hG(t).map((t => t.getAttribute("columnWidth"))) } class mG extends _l { refresh() { this.isEnabled = true } execute(t = {}) { const { model: e, plugins: n } = this.editor; let { table: i = e.document.selection.getSelectedElement(), columnWidths: o, tableWidth: r } = t; if (o) { o = Array.isArray(o) ? o : o.split(",") } e.change((t => { if (r) { t.setAttribute("tableWidth", r, i) } else { t.removeAttribute("tableWidth", i) } const e = n.get("TableColumnResizeEditing").getColumnGroupElement(i); if (!o && !e) { return } if (!o) { return t.remove(e) } const s = aG(o); if (!e) { const e = t.createElement("tableColumnGroup"); s.forEach((n => t.appendElement("tableColumn", { columnWidth: n }, e))); t.append(e, i) } else { Array.from(e.getChildren()).forEach(((e, n) => t.setAttribute("columnWidth", s[n], e))) } })) } } function fG(t) { return e => e.on("element:colgroup", ((e, n, i) => { const o = n.modelCursor.findAncestor("table"); const r = uG(o); if (!r) { return } const s = hG(r); let a = gG(r); const c = t.getColumns(o); a = Array.from({ length: c }, ((t, e) => a[e] || "auto")); if (a.length != s.length || a.includes("auto")) { dG(s, r, aG(a), i.writer) } }), { priority: "low" }) } function pG() { return t => t.on("insert:table", ((t, e, n) => { const i = n.writer; const o = e.item; const r = n.mapper.toViewElement(o); const s = r.is("element", "table") ? r : Array.from(r.getChildren()).find((t => t.is("element", "table"))); const a = uG(e.item); if (a) { i.addClass("ck-table-resized", s) } else { i.removeClass("ck-table-resized", s) } }), { priority: "low" }) } class bG extends wl { static get requires() { return [BU, YH] } static get pluginName() { return "TableColumnResizeEditing" } constructor(t) { super(t); this._isResizingActive = false; this.set("_isResizingAllowed", true); this._resizingData = null; this._domEmitter = new (Ga()); this._tableUtilsPlugin = t.plugins.get("TableUtils"); this.on("change:_isResizingAllowed", ((e, n, i) => { t.editing.view.change((e => { e[i ? "removeClass" : "addClass"]("ck-column-resize_disabled", t.editing.view.document.getRoot()) })) })) } init() { this._extendSchema(); this._registerPostFixer(); this._registerConverters(); this._registerResizingListeners(); this._registerResizerInserter(); const t = this.editor; const e = t.plugins.get("TableColumnResize"); const n = t.plugins.get("TableEditing"); n.registerAdditionalSlot({ filter: t => t.is("element", "tableColumnGroup"), positionOffset: 0 }); const i = new mG(t); t.commands.add("resizeTableWidth", i); t.commands.add("resizeColumnWidths", i); this.bind("_isResizingAllowed").to(t, "isReadOnly", e, "isEnabled", i, "isEnabled", ((t, e, n) => !t && e && n)) } destroy() { this._domEmitter.stopListening(); super.destroy() } getColumnGroupElement(t) { return uG(t) } getTableColumnElements(t) { return hG(t) } getTableColumnsWidths(t) { return gG(t) } _extendSchema() { this.editor.model.schema.extend("table", { allowAttributes: ["tableWidth"] }); this.editor.model.schema.register("tableColumnGroup", { allowIn: "table", isLimit: true }); this.editor.model.schema.register("tableColumn", { allowIn: "tableColumnGroup", allowAttributes: ["columnWidth"], isLimit: true }) } _registerPostFixer() { const t = this.editor; const e = t.model; e.document.registerPostFixer((t => { let i = false; for (const o of Zq(e)) { const e = this.getColumnGroupElement(o); const r = this.getTableColumnElements(e); const s = this.getTableColumnsWidths(e); let a = aG(s); a = n(a, o, this); if (kk(s, a)) { continue } dG(r, e, a, t); i = true } return i })); function n(t, e, n) { const o = n._tableUtilsPlugin.getColumns(e); const r = o - t.length; if (r === 0) { return t } const s = t.map((t => Number(t.replace("%", "")))); const a = i(n.editor.model.document.differ, e); for (const t of a) { const i = o - s.length; if (i === 0) { continue } const r = i > 0; const a = n._tableUtilsPlugin.getCellLocation(t).column; if (r) { const t = Jq(e, n.editor); const o = rG(i, t); s.splice(a, 0, ...o) } else { const t = s.splice(a, Math.abs(i)); s[a] += sG(t) } } return s.map((t => t + "%")) } function i(t, e) { const n = new Set; for (const i of t.getChanges()) { if (i.type == "insert" && i.position.nodeAfter && i.position.nodeAfter.name == "tableCell" && i.position.nodeAfter.getAncestors().includes(e)) { n.add(i.position.nodeAfter) } else if (i.type == "remove") { const t = i.position.nodeBefore || i.position.nodeAfter; if (t.name == "tableCell" && t.getAncestors().includes(e)) { n.add(t) } } } return n } } _registerConverters() { const t = this.editor; const e = t.conversion; e.for("upcast").attributeToAttribute({ view: { name: "figure", key: "style", value: { width: /[\s\S]+/ } }, model: { name: "table", key: "tableWidth", value: t => t.getStyle("width") } }); e.for("downcast").attributeToAttribute({ model: { name: "table", key: "tableWidth" }, view: t => ({ name: "figure", key: "style", value: { width: t } }) }); e.elementToElement({ model: "tableColumnGroup", view: "colgroup" }); e.elementToElement({ model: "tableColumn", view: "col" }); e.for("downcast").add(pG()); e.for("upcast").add(fG(this._tableUtilsPlugin)); e.for("upcast").attributeToAttribute({ view: { name: "col", styles: { width: /.*/ } }, model: { key: "columnWidth", value: t => { const e = t.getStyle("width"); if (!e || !e.endsWith("%")) { return "auto" } return e } } }); e.for("downcast").attributeToAttribute({ model: { name: "tableColumn", key: "columnWidth" }, view: t => ({ key: "style", value: { width: t } }) }) } _registerResizingListeners() { const t = this.editor.editing.view; t.addObserver(rW); t.document.on("mousedown", this._onMouseDownHandler.bind(this), { priority: "high" }); this._domEmitter.listenTo(Za.window.document, "mousemove", Sx(this._onMouseMoveHandler.bind(this), 50)); this._domEmitter.listenTo(Za.window.document, "mouseup", this._onMouseUpHandler.bind(this)) } _onMouseDownHandler(t, e) { const n = e.target; if (!n.hasClass("ck-table-column-resizer")) { return } if (!this._isResizingAllowed) { return } e.preventDefault(); t.stop(); const i = this.editor; const o = i.editing.mapper.toModelElement(n.findAncestor("figure")); const r = c(o, this._tableUtilsPlugin, i); const s = n.findAncestor("table"); const a = i.editing.view; if (!Array.from(s.getChildren()).find((t => t.is("element", "colgroup")))) { a.change((t => { l(t, r, s) })) } this._isResizingActive = true; this._resizingData = this._getResizingData(e, r); a.change((t => d(t, s, this._resizingData))); function c(t, e, n) { const i = Array(e.getColumns(t)); const o = new uH(t); for (const t of o) { const e = n.editing.mapper.toViewElement(t.cell); const o = n.editing.view.domConverter.mapViewToDom(e); const r = lG(o); if (!i[t.column] || r < i[t.column]) { i[t.column] = iG(r) } } return i } function l(t, e, n) { const i = t.createContainerElement("colgroup"); for (let n = 0; n < e.length; n++) { const o = t.createEmptyElement("col"); const r = `${iG(e[n] / sG(e) * 100)}%`; t.setStyle("width", r, o); t.insert(t.createPositionAt(i, "end"), o) } t.insert(t.createPositionAt(n, 0), i) } function d(t, e, n) { const i = n.widths.viewFigureWidth / n.widths.viewFigureParentWidth; t.addClass("ck-table-resized", e); t.addClass("ck-table-column-resizer__active", n.elements.viewResizer); t.setStyle("width", `${iG(i * 100)}%`, e.findAncestor("figure")) } } _onMouseMoveHandler(t, e) { if (!this._isResizingActive) { return } if (!this._isResizingAllowed) { this._onMouseUpHandler(); return } const { columnPosition: n, flags: { isRightEdge: i, isTableCentered: o, isLtrContent: r }, elements: { viewFigure: s, viewLeftColumn: a, viewRightColumn: c }, widths: { viewFigureParentWidth: l, tableWidth: d, leftColumnWidth: u, rightColumnWidth: h } } = this._resizingData; const g = -u + Yq; const m = i ? l - d : h - Yq; const f = (r ? 1 : -1) * (i && o ? 2 : 1); const p = oG((e.clientX - n) * f, Math.min(g, 0), Math.max(m, 0)); if (p === 0) { return } this.editor.editing.view.change((t => { const e = iG((u + p) * 100 / d); t.setStyle("width", `${e}%`, a); if (i) { const e = iG((d + p) * 100 / l); t.setStyle("width", `${e}%`, s) } else { const e = iG((h - p) * 100 / d); t.setStyle("width", `${e}%`, c) } })) } _onMouseUpHandler() { if (!this._isResizingActive) { return } const { viewResizer: t, modelTable: e, viewFigure: n, viewColgroup: i } = this._resizingData.elements; const o = this.editor; const r = o.editing.view; const s = this.getColumnGroupElement(e); const a = Array.from(i.getChildren()).filter((t => t.is("view:element"))); const c = s ? this.getTableColumnsWidths(s) : null; const l = a.map((t => t.getStyle("width"))); const d = !kk(c, l); const u = e.getAttribute("tableWidth"); const h = n.getStyle("width"); const g = u !== h; if (d || g) { if (this._isResizingAllowed) { o.execute("resizeTableWidth", { table: e, tableWidth: `${iG(h)}%`, columnWidths: l }) } else { r.change((t => { if (c) { for (const e of a) { t.setStyle("width", c.shift(), e) } } else { t.remove(i) } if (g) { if (u) { t.setStyle("width", u, n) } else { t.removeStyle("width", n) } } if (!c && !u) { t.removeClass("ck-table-resized", [...n.getChildren()].find((t => t.name === "table"))) } })) } } r.change((e => { e.removeClass("ck-table-column-resizer__active", t) })); this._isResizingActive = false; this._resizingData = null } _getResizingData(t, e) { const n = this.editor; const i = t.domEvent.clientX; const o = t.target; const r = o.findAncestor("td") || o.findAncestor("th"); const s = n.editing.mapper.toModelElement(r); const a = s.findAncestor("table"); const c = nG(s, this._tableUtilsPlugin).rightEdge; const l = this._tableUtilsPlugin.getColumns(a) - 1; const d = c === l; const u = !a.hasAttribute("tableAlignment"); const h = n.locale.contentLanguageDirection !== "rtl"; const g = r.findAncestor("table"); const m = g.findAncestor("figure"); const f = [...g.getChildren()].find((t => t.is("element", "colgroup"))); const p = f.getChild(c); const b = d ? undefined : f.getChild(c + 1); const k = eG(n.editing.view.domConverter.mapViewToDom(m.parent)); const w = eG(n.editing.view.domConverter.mapViewToDom(m)); const A = Xq(a, n); const _ = e[c]; const C = d ? undefined : e[c + 1]; return { columnPosition: i, flags: { isRightEdge: d, isTableCentered: u, isLtrContent: h }, elements: { viewResizer: o, modelTable: a, viewFigure: m, viewColgroup: f, viewLeftColumn: p, viewRightColumn: b }, widths: { viewFigureParentWidth: k, viewFigureWidth: w, tableWidth: A, leftColumnWidth: _, rightColumnWidth: C } } } _registerResizerInserter() { this.editor.conversion.for("editingDowncast").add((t => { t.on("insert:tableCell", ((t, e, n) => { const i = e.item; const o = n.mapper.toViewElement(i); const r = n.writer; r.insert(r.createPositionAt(o, "end"), r.createUIElement("div", { class: "ck-table-column-resizer" })) }), { priority: "lowest" }) })) } } var kG = n(728); var wG = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; wG.insert = "head"; wG.singleton = true; var AG = Sl()(kG.Z, wG); const _G = kG.Z.locals || {}; class CG extends wl { static get requires() { return [bG, Bq] } static get pluginName() { return "TableColumnResize" } } class vG extends _l { constructor(t, e, n) { super(t); this.attributeName = e; this._defaultValue = n } refresh() { const t = this.editor; const e = t.model.document.selection; const n = e.getFirstPosition().findAncestor("table"); this.isEnabled = !!n; this.value = this._getValue(n) } execute(t = {}) { const e = this.editor.model; const n = e.document.selection; const { value: i, batch: o } = t; const r = n.getFirstPosition().findAncestor("table"); const s = this._getValueToSet(i); e.enqueueChange(o, (t => { if (s) { t.setAttribute(this.attributeName, s, r) } else { t.removeAttribute(this.attributeName, r) } })) } _getValue(t) { if (!t) { return } const e = t.getAttribute(this.attributeName); if (e === this._defaultValue) { return } return e } _getValueToSet(t) { if (t === this._defaultValue) { return } return t } } class yG extends vG { constructor(t, e) { super(t, "tableBackgroundColor", e) } } class xG extends vG { constructor(t, e) { super(t, "tableBorderColor", e) } _getValue(t) { if (!t) { return } const e = yq(t.getAttribute(this.attributeName)); if (e === this._defaultValue) { return } return e } } class EG extends vG { constructor(t, e) { super(t, "tableBorderStyle", e) } _getValue(t) { if (!t) { return } const e = yq(t.getAttribute(this.attributeName)); if (e === this._defaultValue) { return } return e } } class DG extends vG { constructor(t, e) { super(t, "tableBorderWidth", e) } _getValue(t) { if (!t) { return } const e = yq(t.getAttribute(this.attributeName)); if (e === this._defaultValue) { return } return e } _getValueToSet(t) { const e = xq(t, "px"); if (e === this._defaultValue) { return } return e } } class SG extends vG { constructor(t, e) { super(t, "tableWidth", e) } _getValueToSet(t) { t = xq(t, "px"); if (t === this._defaultValue) { return } return t } } class TG extends vG { constructor(t, e) { super(t, "tableHeight", e) } _getValueToSet(t) { t = xq(t, "px"); if (t === this._defaultValue) { return } return t } } class IG extends vG { constructor(t, e) { super(t, "tableAlignment", e) } } const MG = /^(left|center|right)$/; const BG = /^(left|none|right)$/; class LG extends wl { static get pluginName() { return "TablePropertiesEditing" } static get requires() { return [BU] } init() { const t = this.editor; const e = t.model.schema; const n = t.conversion; t.config.define("table.tableProperties.defaultProperties", {}); const i = Eq(t.config.get("table.tableProperties.defaultProperties"), { includeAlignmentProperty: true }); t.data.addStyleProcessorRules(AA); NG(e, n, { color: i.borderColor, style: i.borderStyle, width: i.borderWidth }); t.commands.add("tableBorderColor", new xG(t, i.borderColor)); t.commands.add("tableBorderStyle", new EG(t, i.borderStyle)); t.commands.add("tableBorderWidth", new DG(t, i.borderWidth)); zG(e, n, i.alignment); t.commands.add("tableAlignment", new IG(t, i.alignment)); OG(e, n, { modelAttribute: "tableWidth", styleName: "width", defaultValue: i.width }); t.commands.add("tableWidth", new SG(t, i.width)); OG(e, n, { modelAttribute: "tableHeight", styleName: "height", defaultValue: i.height }); t.commands.add("tableHeight", new TG(t, i.height)); t.data.addStyleProcessorRules(pA); PG(e, n, { modelAttribute: "tableBackgroundColor", styleName: "background-color", defaultValue: i.backgroundColor }); t.commands.add("tableBackgroundColor", new yG(t, i.backgroundColor)) } } function NG(t, e, n) { const i = { width: "tableBorderWidth", color: "tableBorderColor", style: "tableBorderStyle" }; t.extend("table", { allowAttributes: Object.values(i) }); QF(e, "table", i, n); JF(e, { modelAttribute: i.color, styleName: "border-color" }); JF(e, { modelAttribute: i.style, styleName: "border-style" }); JF(e, { modelAttribute: i.width, styleName: "border-width" }) } function zG(t, e, n) { t.extend("table", { allowAttributes: ["tableAlignment"] }); e.for("downcast").attributeToAttribute({ model: { name: "table", key: "tableAlignment" }, view: t => ({ key: "style", value: { float: t === "center" ? "none" : t } }), converterPriority: "high" }); e.for("upcast").attributeToAttribute({ view: { name: /^(table|figure)$/, styles: { float: BG } }, model: { key: "tableAlignment", value: t => { let e = t.getStyle("float"); if (e === "none") { e = "center" } return e === n ? null : e } } }).attributeToAttribute({ view: { attributes: { align: MG } }, model: { name: "table", key: "tableAlignment", value: t => { const e = t.getAttribute("align"); return e === n ? null : e } } }) } function PG(t, e, n) { const { modelAttribute: i } = n; t.extend("table", { allowAttributes: [i] }); YF(e, { viewElement: "table", ...n }); JF(e, n) } function OG(t, e, n) { const { modelAttribute: i } = n; t.extend("table", { allowAttributes: [i] }); YF(e, { viewElement: /^(table|figure)$/, shouldUpcast: t => !(t.name == "table" && t.parent.name == "figure"), ...n }); ZF(e, { modelElement: "table", ...n }) } var RG = n(9221); var VG = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; VG.insert = "head"; VG.singleton = true; var jG = Sl()(RG.Z, VG); const FG = RG.Z.locals || {}; const HG = { left: v_.objectLeft, center: v_.objectCenter, right: v_.objectRight }; class UG extends N_ { constructor(t, e) { super(t); this.set({ borderStyle: "", borderWidth: "", borderColor: "", backgroundColor: "", width: "", height: "", alignment: "" }); this.options = e; const { borderStyleDropdown: n, borderWidthInput: i, borderColorInput: o, borderRowLabel: r } = this._createBorderFields(); const { backgroundRowLabel: s, backgroundInput: a } = this._createBackgroundFields(); const { widthInput: c, operatorLabel: l, heightInput: d, dimensionsLabel: u } = this._createDimensionFields(); const { alignmentToolbar: h, alignmentLabel: g } = this._createAlignmentFields(); this.focusTracker = new rl; this.keystrokes = new sl; this.children = this.createCollection(); this.borderStyleDropdown = n; this.borderWidthInput = i; this.borderColorInput = o; this.backgroundInput = a; this.widthInput = c; this.heightInput = d; this.alignmentToolbar = h; const { saveButtonView: m, cancelButtonView: f } = this._createActionButtons(); this.saveButtonView = m; this.cancelButtonView = f; this._focusables = new S_; this._focusCycler = new QC({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }); this.children.add(new Cy(t, { label: this.t("Table properties") })); this.children.add(new ZW(t, { labelView: r, children: [r, n, o, i], class: "ck-table-form__border-row" })); this.children.add(new ZW(t, { labelView: s, children: [s, a], class: "ck-table-form__background-row" })); this.children.add(new ZW(t, { children: [new ZW(t, { labelView: u, children: [u, c, l, d], class: "ck-table-form__dimensions-row" }), new ZW(t, { labelView: g, children: [g, h], class: "ck-table-properties-form__alignment-row" })] })); this.children.add(new ZW(t, { children: [this.saveButtonView, this.cancelButtonView], class: "ck-table-form__action-row" })); this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-form", "ck-table-form", "ck-table-properties-form"], tabindex: "-1" }, children: this.children }) } render() { super.render(); E_({ view: this });[this.borderStyleDropdown, this.borderColorInput, this.borderColorInput.fieldView.dropdownView.buttonView, this.borderWidthInput, this.backgroundInput, this.backgroundInput.fieldView.dropdownView.buttonView, this.widthInput, this.heightInput, this.alignmentToolbar, this.saveButtonView, this.cancelButtonView].forEach((t => { this._focusables.add(t); this.focusTracker.add(t.element) })); this.keystrokes.listenTo(this.element) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } focus() { this._focusCycler.focusFirst() } _createBorderFields() { const t = this.options.defaultTableProperties; const e = { style: t.borderStyle, width: t.borderWidth, color: t.borderColor }; const n = WW({ colorConfig: this.options.borderColors, columns: 5, defaultColorValue: e.color }); const i = this.locale; const o = this.t; const r = new my(i); r.text = o("Border"); const s = zW(o); const a = new Py(i, Vy); a.set({ label: o("Style"), class: "ck-table-form__border-style" }); a.fieldView.buttonView.set({ isOn: false, withText: true, tooltip: o("Style") }); a.fieldView.buttonView.bind("label").to(this, "borderStyle", (t => s[t ? t : "none"])); a.fieldView.on("execute", (t => { this.borderStyle = t.source._borderStyleValue })); a.bind("isEmpty").to(this, "borderStyle", (t => !t)); Iv(a.fieldView, FW(this, e.style)); const c = new Py(i, Oy); c.set({ label: o("Width"), class: "ck-table-form__border-width" }); c.fieldView.bind("value").to(this, "borderWidth"); c.bind("isEnabled").to(this, "borderStyle", WG); c.fieldView.on("input", (() => { this.borderWidth = c.fieldView.element.value })); const l = new Py(i, n); l.set({ label: o("Color"), class: "ck-table-form__border-color" }); l.fieldView.bind("value").to(this, "borderColor"); l.bind("isEnabled").to(this, "borderStyle", WG); l.fieldView.on("input", (() => { this.borderColor = l.fieldView.value })); this.on("change:borderStyle", ((t, n, i, o) => { if (!WG(i)) { this.borderColor = ""; this.borderWidth = "" } if (!WG(o)) { this.borderColor = e.color; this.borderWidth = e.width } })); return { borderRowLabel: r, borderStyleDropdown: a, borderColorInput: l, borderWidthInput: c } } _createBackgroundFields() { const t = this.locale; const e = this.t; const n = new my(t); n.text = e("Background"); const i = WW({ colorConfig: this.options.backgroundColors, columns: 5, defaultColorValue: this.options.defaultTableProperties.backgroundColor }); const o = new Py(t, i); o.set({ label: e("Color"), class: "ck-table-properties-form__background" }); o.fieldView.bind("value").to(this, "backgroundColor"); o.fieldView.on("input", (() => { this.backgroundColor = o.fieldView.value })); return { backgroundRowLabel: n, backgroundInput: o } } _createDimensionFields() { const t = this.locale; const e = this.t; const n = new my(t); n.text = e("Dimensions"); const i = new Py(t, Oy); i.set({ label: e("Width"), class: "ck-table-form__dimensions-row__width" }); i.fieldView.bind("value").to(this, "width"); i.fieldView.on("input", (() => { this.width = i.fieldView.element.value })); const o = new N_(t); o.setTemplate({ tag: "span", attributes: { class: ["ck-table-form__dimension-operator"] }, children: [{ text: "×" }] }); const r = new Py(t, Oy); r.set({ label: e("Height"), class: "ck-table-form__dimensions-row__height" }); r.fieldView.bind("value").to(this, "height"); r.fieldView.on("input", (() => { this.height = r.fieldView.element.value })); return { dimensionsLabel: n, widthInput: i, operatorLabel: o, heightInput: r } } _createAlignmentFields() { const t = this.locale; const e = this.t; const n = new my(t); n.text = e("Alignment"); const i = new cv(t); i.set({ isCompact: true, ariaLabel: e("Table alignment toolbar") }); HW({ view: this, icons: HG, toolbar: i, labels: this._alignmentLabels, propertyName: "alignment", defaultValue: this.options.defaultTableProperties.alignment }); return { alignmentLabel: n, alignmentToolbar: i } } _createActionButtons() { const t = this.locale; const e = this.t; const n = new wC(t); const i = new wC(t); const o = [this.borderWidthInput, this.borderColorInput, this.backgroundInput, this.widthInput, this.heightInput]; n.set({ label: e("Save"), icon: v_.check, class: "ck-button-save", type: "submit", withText: true }); n.bind("isEnabled").toMany(o, "errorText", ((...t) => t.every((t => !t)))); i.set({ label: e("Cancel"), icon: v_.cancel, class: "ck-button-cancel", withText: true }); i.delegate("execute").to(this, "cancel"); return { saveButtonView: n, cancelButtonView: i } } get _alignmentLabels() { const t = this.locale; const e = this.t; const n = e("Align table to the left"); const i = e("Center table"); const o = e("Align table to the right"); if (t.uiLanguageDirection === "rtl") { return { right: o, center: i, left: n } } else { return { left: n, center: i, right: o } } } } function WG(t) { return t !== "none" } const qG = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v5h4V2h1v5h5v1h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5H7v-5H2v-1h5V8H2V7h5V2h1zm4 6H8v4h4V8z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM17 1a2 2 0 0 1 2 2v9.475l-.85-.124-.857-1.736a2.048 2.048 0 0 0-.292-.44L17 3H3v14h7.808l.402.392L10.935 19H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14z"/></svg>'; const GG = 500; const $G = { borderStyle: "tableBorderStyle", borderColor: "tableBorderColor", borderWidth: "tableBorderWidth", backgroundColor: "tableBackgroundColor", width: "tableWidth", height: "tableHeight", alignment: "tableAlignment" }; class KG extends wl { static get requires() { return [Xy] } static get pluginName() { return "TablePropertiesUI" } constructor(t) { super(t); this.view = null; t.config.define("table.tableProperties", { borderColors: UW, backgroundColors: UW }) } init() { const t = this.editor; const e = t.t; this._defaultTableProperties = Eq(t.config.get("table.tableProperties.defaultProperties"), { includeAlignmentProperty: true }); this._balloon = t.plugins.get(Xy); t.ui.componentFactory.add("tableProperties", (n => { const i = new wC(n); i.set({ label: e("Table properties"), icon: qG, tooltip: true }); this.listenTo(i, "execute", (() => this._showView())); const o = Object.values($G).map((e => t.commands.get(e))); i.bind("isEnabled").toMany(o, "isEnabled", ((...t) => t.some((t => t)))); return i })) } destroy() { super.destroy(); if (this.view) { this.view.destroy() } } _createPropertiesView() { const t = this.editor; const e = t.config.get("table.tableProperties"); const n = EC(e.borderColors); const i = xC(t.locale, n); const o = EC(e.backgroundColors); const r = xC(t.locale, o); const s = new UG(t.locale, { borderColors: i, backgroundColors: r, defaultTableProperties: this._defaultTableProperties }); const a = t.t; s.render(); this.listenTo(s, "submit", (() => { this._hideView() })); this.listenTo(s, "cancel", (() => { if (this._undoStepBatch.operations.length) { t.execute("undo", this._undoStepBatch) } this._hideView() })); s.keystrokes.set("Esc", ((t, e) => { this._hideView(); e() })); y_({ emitter: s, activator: () => this._isViewInBalloon, contextElements: [this._balloon.view.element], callback: () => this._hideView() }); const c = PW(a); const l = OW(a); s.on("change:borderStyle", this._getPropertyChangeCallback("tableBorderStyle")); s.on("change:borderColor", this._getValidatedPropertyChangeCallback({ viewField: s.borderColorInput, commandName: "tableBorderColor", errorText: c, validator: RW })); s.on("change:borderWidth", this._getValidatedPropertyChangeCallback({ viewField: s.borderWidthInput, commandName: "tableBorderWidth", errorText: l, validator: jW })); s.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({ viewField: s.backgroundInput, commandName: "tableBackgroundColor", errorText: c, validator: RW })); s.on("change:width", this._getValidatedPropertyChangeCallback({ viewField: s.widthInput, commandName: "tableWidth", errorText: l, validator: VW })); s.on("change:height", this._getValidatedPropertyChangeCallback({ viewField: s.heightInput, commandName: "tableHeight", errorText: l, validator: VW })); s.on("change:alignment", this._getPropertyChangeCallback("tableAlignment")); return s } _fillViewFormFromCommandValues() { const t = this.editor.commands; const e = t.get("tableBorderStyle"); Object.entries($G).map((([e, n]) => { const i = e; const o = this._defaultTableProperties[i] || ""; return [i, t.get(n).value || o] })).forEach((([t, n]) => { if ((t === "borderColor" || t === "borderWidth") && e.value === "none") { return } this.view.set(t, n) })); this._isReady = true } _showView() { const t = this.editor; if (!this.view) { this.view = this._createPropertiesView() } this.listenTo(t.ui, "update", (() => { this._updateView() })); this._fillViewFormFromCommandValues(); this._balloon.add({ view: this.view, position: wq(t) }); this._undoStepBatch = t.model.createBatch(); this.view.focus() } _hideView() { const t = this.editor; this.stopListening(t.ui, "update"); this._isReady = false; this.view.saveButtonView.focus(); this._balloon.remove(this.view); this.editor.editing.view.focus() } _updateView() { const t = this.editor; const e = t.editing.view.document; if (!mq(e.selection)) { this._hideView() } else if (this._isViewVisible) { kq(t, "table") } } get _isViewVisible() { return !!this.view && this._balloon.visibleView === this.view } get _isViewInBalloon() { return !!this.view && this._balloon.hasView(this.view) } _getPropertyChangeCallback(t) { return (e, n, i) => { if (!this._isReady) { return } this.editor.execute(t, { value: i, batch: this._undoStepBatch }) } } _getValidatedPropertyChangeCallback(t) { const { commandName: e, viewField: n, validator: i, errorText: o } = t; const r = Yg((() => { n.errorText = o }), GG); return (t, o, s) => { r.cancel(); if (!this._isReady) { return } if (i(s)) { this.editor.execute(e, { value: s, batch: this._undoStepBatch }); n.errorText = null } else { r() } } } } class YG extends wl { static get pluginName() { return "TableProperties" } static get requires() { return [LG, KG] } } class QG extends wl { static get requires() { return [aS] } static get pluginName() { return "TableToolbar" } afterInit() { const t = this.editor; const e = t.t; const n = t.plugins.get(aS); const i = t.config.get("table.contentToolbar"); const o = t.config.get("table.tableToolbar"); if (i) { n.register("tableContent", { ariaLabel: e("Table toolbar"), items: i, getRelatedElement: mq }) } if (o) { n.register("table", { ariaLabel: e("Table toolbar"), items: o, getRelatedElement: gq }) } } } const ZG = "underline"; class JG extends wl { static get pluginName() { return "UnderlineEditing" } init() { const t = this.editor; t.model.schema.extend("$text", { allowAttributes: ZG }); t.model.schema.setAttributeProperties(ZG, { isFormatting: true, copyOnEnter: true }); t.conversion.attributeToElement({ model: ZG, view: "u", upcastAlso: { styles: { "text-decoration": "underline" } } }); t.commands.add(ZG, new FI(t, ZG)); t.keystrokes.set("CTRL+U", "underline") } } const XG = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>'; const t$ = "underline"; class e$ extends wl { static get pluginName() { return "UnderlineUI" } init() { const t = this.editor; const e = t.t; t.ui.componentFactory.add(t$, (n => { const i = t.commands.get(t$); const o = new wC(n); o.set({ label: e("Underline"), icon: XG, keystroke: "CTRL+U", tooltip: true, isToggleable: true }); o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"); this.listenTo(o, "execute", (() => { t.execute(t$); t.editing.view.focus() })); return o })) } } class n$ extends wl { static get requires() { return [JG, e$] } static get pluginName() { return "Underline" } } class i$ extends Px { } i$.builtinPlugins = [tE, dT, fT, yI, TI, jI, wx, GI, iM, zM, AB, QM, PB, XB, hL, yL, oN, gN, DN, rz, sz, Xz, oP, dP, pP, QP, aO, eR, GR, EV, DV, uj, jB, Jj, oF, zB, fz, yF, xF, EF, IF, SF, DF, TF, PF, HF, KF, hW, DW, $q, CG, YG, QG, HE, n$]; i$.defaultConfig = { toolbar: { items: ["bold", "italic", "link", "|", "highlight", "underline", "strikethrough"] }, language: "en", blockToolbar: ["heading", "imageUpload", "mediaEmbed", "insertTable", "bulletedList", "numberedList", "|", "alignment", "outdent", "indent", "removeFormat", "|", "blockQuote", "code", "codeBlock", "|", "specialCharacters", "subscript", "superscript", "horizontalLine"], image: { toolbar: ["imageTextAlternative", "toggleImageCaption", "imageStyle:inline", "imageStyle:block", "imageStyle:side", "linkImage"] }, table: { contentToolbar: ["tableColumn", "tableRow", "mergeTableCells", "tableCellProperties", "tableProperties"] } }; const o$ = i$ })(); i = i["default"]; return i })()));
//# sourceMappingURL=ckeditor.js.map